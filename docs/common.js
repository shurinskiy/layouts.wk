/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@fluejs/noscroll/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@fluejs/noscroll/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoScrollAttrs: () => (/* reexport safe */ _shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   NoScrollCssVars: () => (/* reexport safe */ _shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   adjustScrollbarWidth: () => (/* binding */ adjustScrollbarWidth),\n/* harmony export */   createNoScroll: () => (/* binding */ createNoScroll),\n/* harmony export */   createPageScrollToggler: () => (/* binding */ createPageScrollToggler),\n/* harmony export */   disablePageScroll: () => (/* binding */ disablePageScroll),\n/* harmony export */   disableScroll: () => (/* binding */ disableScroll),\n/* harmony export */   enablePageScroll: () => (/* binding */ enablePageScroll),\n/* harmony export */   enableScroll: () => (/* binding */ enableScroll),\n/* harmony export */   markScrollable: () => (/* binding */ markScrollable),\n/* harmony export */   pageScrollIsDisabled: () => (/* binding */ pageScrollIsDisabled),\n/* harmony export */   removeScrollbarWidthAdjustment: () => (/* binding */ removeScrollbarWidthAdjustment),\n/* harmony export */   unmarkScrollable: () => (/* binding */ unmarkScrollable),\n/* harmony export */   updateAllScrollbarWidthAdjustment: () => (/* binding */ updateAllScrollbarWidthAdjustment)\n/* harmony export */ });\n/* harmony import */ var _shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/noscroll.96a94b32.mjs */ \"./node_modules/@fluejs/noscroll/dist/shared/noscroll.96a94b32.mjs\");\n\n\nconst appendGlobalStyles = () => {\n  if (document.querySelector((0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.GLOBAL_STYLES))) {\n    return;\n  }\n  const scrollDisabledSelector = (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_DISABLED);\n  const scrollbarWidthAdjustmentSelector = (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLLBAR_WIDTH_ADJUSTMENT);\n  const scrollScrollbarWidthAdjustmentSelector = (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_SCROLLBAR_WIDTH_ADJUSTMENT);\n  const css = `    \n    ${scrollDisabledSelector} {\n        overflow: hidden !important;\n    }\n    \n    ${scrollDisabledSelector} ${scrollbarWidthAdjustmentSelector},\n    ${scrollDisabledSelector}${scrollScrollbarWidthAdjustmentSelector} {\n        padding-right: calc(var(${_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.b.TARGET_PADDING_RIGHT}) + var(${_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.b.TARGET_SCROLLBAR_WIDTH})) !important;\n    }\n    `;\n  const styleEl = document.createElement(\"style\");\n  styleEl.setAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.GLOBAL_STYLES, \"\");\n  styleEl.appendChild(document.createTextNode(css));\n  document.head.appendChild(styleEl);\n};\n\nconst createNoScroll = (options) => {\n  const adjustScrollbarWidth = (target) => {\n    (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(target).forEach((el) => {\n      el.removeAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLLBAR_WIDTH_ADJUSTMENT);\n      const computedStyle = window.getComputedStyle(el);\n      el.style.setProperty(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.b.TARGET_PADDING_RIGHT, computedStyle.paddingRight);\n      el.setAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLLBAR_WIDTH_ADJUSTMENT, \"\");\n    });\n  };\n  const removeScrollbarWidthAdjustment = (target) => {\n    (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(target).forEach((el) => {\n      el.removeAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLLBAR_WIDTH_ADJUSTMENT);\n      el.style.removeProperty(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.b.TARGET_PADDING_RIGHT);\n    });\n  };\n  const adjustScrollScrollbarWidth = (target) => {\n    (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(target).forEach((el) => {\n      let scrollDisabled = false;\n      el.removeAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_SCROLLBAR_WIDTH_ADJUSTMENT);\n      if (el.getAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_DISABLED) !== null) {\n        scrollDisabled = true;\n        el.removeAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_DISABLED);\n      }\n      el.style.setProperty(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.b.TARGET_SCROLLBAR_WIDTH, `${(0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(el)}px`);\n      if (scrollDisabled) {\n        el.setAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_DISABLED, \"\");\n      }\n      const computedStyle = window.getComputedStyle(el);\n      el.style.setProperty(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.b.TARGET_PADDING_RIGHT, computedStyle.paddingRight);\n      el.setAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_SCROLLBAR_WIDTH_ADJUSTMENT, \"\");\n    });\n  };\n  const removeScrollScrollbarWidthAdjustment = (target) => {\n    (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(target).forEach((el) => {\n      el.removeAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_SCROLLBAR_WIDTH_ADJUSTMENT);\n      el.style.removeProperty(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.b.TARGET_SCROLLBAR_WIDTH);\n      el.style.removeProperty(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.b.TARGET_PADDING_RIGHT);\n    });\n  };\n  const updateAllScrollbarWidthAdjustment = () => {\n    adjustScrollbarWidth(\n      [...document.querySelectorAll(\n        (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLLBAR_WIDTH_ADJUSTMENT)\n      )]\n    );\n    adjustScrollScrollbarWidth(\n      [...document.querySelectorAll(\n        (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_SCROLLBAR_WIDTH_ADJUSTMENT)\n      )]\n    );\n  };\n  const handleWindowResize = (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(\n    updateAllScrollbarWidthAdjustment,\n    options?.windowResizeThrottle ?? _shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.D\n  );\n  const {\n    init: initScrollDisable,\n    reset: resetScrollDisable\n  } = (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.d)(\n    () => {\n      if (!options?.noHandleWindowResize) {\n        window.addEventListener(\"resize\", handleWindowResize);\n      }\n      options?.onInitScrollDisable?.();\n    },\n    () => {\n      if (!options?.noHandleWindowResize) {\n        window.removeEventListener(\"resize\", handleWindowResize);\n      }\n      options?.onResetScrollDisable?.();\n    }\n  );\n  const disableScroll = (target, {\n    scrollbarWidthAdjustment = true\n  } = {}) => {\n    appendGlobalStyles();\n    initScrollDisable();\n    options?.onScrollDisable?.(target);\n    if (scrollbarWidthAdjustment) {\n      adjustScrollScrollbarWidth(target);\n    }\n    target.setAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_DISABLED, \"\");\n  };\n  const enableScroll = (target) => {\n    if (target.getAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_DISABLED) === null) {\n      return;\n    }\n    resetScrollDisable();\n    options?.onScrollEnable?.(target);\n    removeScrollScrollbarWidthAdjustment(target);\n    target.removeAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLL_DISABLED);\n  };\n  const {\n    init: disablePageScroll,\n    reset: enablePageScroll,\n    initIsCalled: pageScrollIsDisabled\n  } = (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.d)(\n    () => disableScroll(document.body),\n    () => enableScroll(document.body)\n  );\n  const createPageScrollToggler = () => {\n    let isDisabled = false;\n    const toggler = {\n      disablePageScroll() {\n        if (isDisabled) {\n          return;\n        }\n        disablePageScroll();\n        isDisabled = true;\n      },\n      enablePageScroll() {\n        if (!isDisabled) {\n          return;\n        }\n        enablePageScroll();\n        isDisabled = false;\n      },\n      togglePageScroll() {\n        if (isDisabled) {\n          toggler.enablePageScroll();\n        } else {\n          toggler.disablePageScroll();\n        }\n      }\n    };\n    return toggler;\n  };\n  const markScrollable = (target) => {\n    (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(target).forEach((el) => {\n      el.setAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLLABLE, \"\");\n    });\n  };\n  const unmarkScrollable = (target) => {\n    (0,_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(target).forEach((el) => {\n      el.removeAttribute(_shared_noscroll_96a94b32_mjs__WEBPACK_IMPORTED_MODULE_0__.N.SCROLLABLE);\n    });\n  };\n  return {\n    adjustScrollbarWidth,\n    removeScrollbarWidthAdjustment,\n    updateAllScrollbarWidthAdjustment,\n    disableScroll,\n    enableScroll,\n    disablePageScroll,\n    enablePageScroll,\n    pageScrollIsDisabled,\n    createPageScrollToggler,\n    markScrollable,\n    unmarkScrollable\n  };\n};\n\nconst {\n  adjustScrollbarWidth,\n  removeScrollbarWidthAdjustment,\n  updateAllScrollbarWidthAdjustment,\n  disableScroll,\n  enableScroll,\n  disablePageScroll,\n  enablePageScroll,\n  pageScrollIsDisabled,\n  createPageScrollToggler,\n  markScrollable,\n  unmarkScrollable\n} = createNoScroll();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZsdWVqcy9ub3Njcm9sbC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMk47O0FBRTNOO0FBQ0EsNkJBQTZCLGdFQUFjLENBQUMsNERBQWE7QUFDekQ7QUFDQTtBQUNBLGlDQUFpQyxnRUFBYyxDQUFDLDREQUFhO0FBQzdELDJDQUEyQyxnRUFBYyxDQUFDLDREQUFhO0FBQ3ZFLGlEQUFpRCxnRUFBYyxDQUFDLDREQUFhO0FBQzdFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQXdCLEVBQUUsaUNBQWlDO0FBQ2pFLE1BQU0sdUJBQXVCLEVBQUU7QUFDL0Isa0NBQWtDLDREQUFlLHNCQUFzQixVQUFVLDREQUFlLHdCQUF3QjtBQUN4SDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQWE7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGdFQUFPO0FBQ1gseUJBQXlCLDREQUFhO0FBQ3RDO0FBQ0EsMkJBQTJCLDREQUFlO0FBQzFDLHNCQUFzQiw0REFBYTtBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUksZ0VBQU87QUFDWCx5QkFBeUIsNERBQWE7QUFDdEMsOEJBQThCLDREQUFlO0FBQzdDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSxnRUFBTztBQUNYO0FBQ0EseUJBQXlCLDREQUFhO0FBQ3RDLDBCQUEwQiw0REFBYTtBQUN2QztBQUNBLDJCQUEyQiw0REFBYTtBQUN4QztBQUNBLDJCQUEyQiw0REFBZSw0QkFBNEIsZ0VBQWlCLEtBQUs7QUFDNUY7QUFDQSx3QkFBd0IsNERBQWE7QUFDckM7QUFDQTtBQUNBLDJCQUEyQiw0REFBZTtBQUMxQyxzQkFBc0IsNERBQWE7QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLGdFQUFPO0FBQ1gseUJBQXlCLDREQUFhO0FBQ3RDLDhCQUE4Qiw0REFBZTtBQUM3Qyw4QkFBOEIsNERBQWU7QUFDN0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRUFBYyxDQUFDLDREQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRUFBYyxDQUFDLDREQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnRUFBUTtBQUNyQztBQUNBLHFDQUFxQyw0REFBOEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsZ0VBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNERBQWE7QUFDckM7QUFDQTtBQUNBLDRCQUE0Qiw0REFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsZ0VBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFPO0FBQ1gsc0JBQXNCLDREQUFhO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSxnRUFBTztBQUNYLHlCQUF5Qiw0REFBYTtBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRW9TIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGZsdWVqcy9ub3Njcm9sbC9kaXN0L2luZGV4Lm1qcz81ZDg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGEgYXMgYXR0ckFzU2VsZWN0b3IsIE4gYXMgTm9TY3JvbGxBdHRycywgYiBhcyBOb1Njcm9sbENzc1ZhcnMsIHQgYXMgdGhyb3R0bGUsIEQgYXMgREVGQVVMVF9XSU5ET1dfUkVTSVpFX1RIUk9UVExFLCBjIGFzIGFzQXJyYXksIGQgYXMgY3JlYXRlUXVldWUsIGcgYXMgZ2V0U2Nyb2xsYmFyV2lkdGggfSBmcm9tICcuL3NoYXJlZC9ub3Njcm9sbC45NmE5NGIzMi5tanMnO1xuXG5jb25zdCBhcHBlbmRHbG9iYWxTdHlsZXMgPSAoKSA9PiB7XG4gIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGF0dHJBc1NlbGVjdG9yKE5vU2Nyb2xsQXR0cnMuR0xPQkFMX1NUWUxFUykpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNjcm9sbERpc2FibGVkU2VsZWN0b3IgPSBhdHRyQXNTZWxlY3RvcihOb1Njcm9sbEF0dHJzLlNDUk9MTF9ESVNBQkxFRCk7XG4gIGNvbnN0IHNjcm9sbGJhcldpZHRoQWRqdXN0bWVudFNlbGVjdG9yID0gYXR0ckFzU2VsZWN0b3IoTm9TY3JvbGxBdHRycy5TQ1JPTExCQVJfV0lEVEhfQURKVVNUTUVOVCk7XG4gIGNvbnN0IHNjcm9sbFNjcm9sbGJhcldpZHRoQWRqdXN0bWVudFNlbGVjdG9yID0gYXR0ckFzU2VsZWN0b3IoTm9TY3JvbGxBdHRycy5TQ1JPTExfU0NST0xMQkFSX1dJRFRIX0FESlVTVE1FTlQpO1xuICBjb25zdCBjc3MgPSBgICAgIFxuICAgICR7c2Nyb2xsRGlzYWJsZWRTZWxlY3Rvcn0ge1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuICFpbXBvcnRhbnQ7XG4gICAgfVxuICAgIFxuICAgICR7c2Nyb2xsRGlzYWJsZWRTZWxlY3Rvcn0gJHtzY3JvbGxiYXJXaWR0aEFkanVzdG1lbnRTZWxlY3Rvcn0sXG4gICAgJHtzY3JvbGxEaXNhYmxlZFNlbGVjdG9yfSR7c2Nyb2xsU2Nyb2xsYmFyV2lkdGhBZGp1c3RtZW50U2VsZWN0b3J9IHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogY2FsYyh2YXIoJHtOb1Njcm9sbENzc1ZhcnMuVEFSR0VUX1BBRERJTkdfUklHSFR9KSArIHZhcigke05vU2Nyb2xsQ3NzVmFycy5UQVJHRVRfU0NST0xMQkFSX1dJRFRIfSkpICFpbXBvcnRhbnQ7XG4gICAgfVxuICAgIGA7XG4gIGNvbnN0IHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlRWwuc2V0QXR0cmlidXRlKE5vU2Nyb2xsQXR0cnMuR0xPQkFMX1NUWUxFUywgXCJcIik7XG4gIHN0eWxlRWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG59O1xuXG5jb25zdCBjcmVhdGVOb1Njcm9sbCA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGFkanVzdFNjcm9sbGJhcldpZHRoID0gKHRhcmdldCkgPT4ge1xuICAgIGFzQXJyYXkodGFyZ2V0KS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKE5vU2Nyb2xsQXR0cnMuU0NST0xMQkFSX1dJRFRIX0FESlVTVE1FTlQpO1xuICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KE5vU2Nyb2xsQ3NzVmFycy5UQVJHRVRfUEFERElOR19SSUdIVCwgY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgICAgZWwuc2V0QXR0cmlidXRlKE5vU2Nyb2xsQXR0cnMuU0NST0xMQkFSX1dJRFRIX0FESlVTVE1FTlQsIFwiXCIpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCByZW1vdmVTY3JvbGxiYXJXaWR0aEFkanVzdG1lbnQgPSAodGFyZ2V0KSA9PiB7XG4gICAgYXNBcnJheSh0YXJnZXQpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoTm9TY3JvbGxBdHRycy5TQ1JPTExCQVJfV0lEVEhfQURKVVNUTUVOVCk7XG4gICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShOb1Njcm9sbENzc1ZhcnMuVEFSR0VUX1BBRERJTkdfUklHSFQpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBhZGp1c3RTY3JvbGxTY3JvbGxiYXJXaWR0aCA9ICh0YXJnZXQpID0+IHtcbiAgICBhc0FycmF5KHRhcmdldCkuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGxldCBzY3JvbGxEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKE5vU2Nyb2xsQXR0cnMuU0NST0xMX1NDUk9MTEJBUl9XSURUSF9BREpVU1RNRU5UKTtcbiAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoTm9TY3JvbGxBdHRycy5TQ1JPTExfRElTQUJMRUQpICE9PSBudWxsKSB7XG4gICAgICAgIHNjcm9sbERpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKE5vU2Nyb2xsQXR0cnMuU0NST0xMX0RJU0FCTEVEKTtcbiAgICAgIH1cbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KE5vU2Nyb2xsQ3NzVmFycy5UQVJHRVRfU0NST0xMQkFSX1dJRFRILCBgJHtnZXRTY3JvbGxiYXJXaWR0aChlbCl9cHhgKTtcbiAgICAgIGlmIChzY3JvbGxEaXNhYmxlZCkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoTm9TY3JvbGxBdHRycy5TQ1JPTExfRElTQUJMRUQsIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KE5vU2Nyb2xsQ3NzVmFycy5UQVJHRVRfUEFERElOR19SSUdIVCwgY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgICAgZWwuc2V0QXR0cmlidXRlKE5vU2Nyb2xsQXR0cnMuU0NST0xMX1NDUk9MTEJBUl9XSURUSF9BREpVU1RNRU5ULCBcIlwiKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlU2Nyb2xsU2Nyb2xsYmFyV2lkdGhBZGp1c3RtZW50ID0gKHRhcmdldCkgPT4ge1xuICAgIGFzQXJyYXkodGFyZ2V0KS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKE5vU2Nyb2xsQXR0cnMuU0NST0xMX1NDUk9MTEJBUl9XSURUSF9BREpVU1RNRU5UKTtcbiAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KE5vU2Nyb2xsQ3NzVmFycy5UQVJHRVRfU0NST0xMQkFSX1dJRFRIKTtcbiAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KE5vU2Nyb2xsQ3NzVmFycy5UQVJHRVRfUEFERElOR19SSUdIVCk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUFsbFNjcm9sbGJhcldpZHRoQWRqdXN0bWVudCA9ICgpID0+IHtcbiAgICBhZGp1c3RTY3JvbGxiYXJXaWR0aChcbiAgICAgIFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBhdHRyQXNTZWxlY3RvcihOb1Njcm9sbEF0dHJzLlNDUk9MTEJBUl9XSURUSF9BREpVU1RNRU5UKVxuICAgICAgKV1cbiAgICApO1xuICAgIGFkanVzdFNjcm9sbFNjcm9sbGJhcldpZHRoKFxuICAgICAgWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgIGF0dHJBc1NlbGVjdG9yKE5vU2Nyb2xsQXR0cnMuU0NST0xMX1NDUk9MTEJBUl9XSURUSF9BREpVU1RNRU5UKVxuICAgICAgKV1cbiAgICApO1xuICB9O1xuICBjb25zdCBoYW5kbGVXaW5kb3dSZXNpemUgPSB0aHJvdHRsZShcbiAgICB1cGRhdGVBbGxTY3JvbGxiYXJXaWR0aEFkanVzdG1lbnQsXG4gICAgb3B0aW9ucz8ud2luZG93UmVzaXplVGhyb3R0bGUgPz8gREVGQVVMVF9XSU5ET1dfUkVTSVpFX1RIUk9UVExFXG4gICk7XG4gIGNvbnN0IHtcbiAgICBpbml0OiBpbml0U2Nyb2xsRGlzYWJsZSxcbiAgICByZXNldDogcmVzZXRTY3JvbGxEaXNhYmxlXG4gIH0gPSBjcmVhdGVRdWV1ZShcbiAgICAoKSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbnM/Lm5vSGFuZGxlV2luZG93UmVzaXplKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICB9XG4gICAgICBvcHRpb25zPy5vbkluaXRTY3JvbGxEaXNhYmxlPy4oKTtcbiAgICB9LFxuICAgICgpID0+IHtcbiAgICAgIGlmICghb3B0aW9ucz8ubm9IYW5kbGVXaW5kb3dSZXNpemUpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlV2luZG93UmVzaXplKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnM/Lm9uUmVzZXRTY3JvbGxEaXNhYmxlPy4oKTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IGRpc2FibGVTY3JvbGwgPSAodGFyZ2V0LCB7XG4gICAgc2Nyb2xsYmFyV2lkdGhBZGp1c3RtZW50ID0gdHJ1ZVxuICB9ID0ge30pID0+IHtcbiAgICBhcHBlbmRHbG9iYWxTdHlsZXMoKTtcbiAgICBpbml0U2Nyb2xsRGlzYWJsZSgpO1xuICAgIG9wdGlvbnM/Lm9uU2Nyb2xsRGlzYWJsZT8uKHRhcmdldCk7XG4gICAgaWYgKHNjcm9sbGJhcldpZHRoQWRqdXN0bWVudCkge1xuICAgICAgYWRqdXN0U2Nyb2xsU2Nyb2xsYmFyV2lkdGgodGFyZ2V0KTtcbiAgICB9XG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShOb1Njcm9sbEF0dHJzLlNDUk9MTF9ESVNBQkxFRCwgXCJcIik7XG4gIH07XG4gIGNvbnN0IGVuYWJsZVNjcm9sbCA9ICh0YXJnZXQpID0+IHtcbiAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZShOb1Njcm9sbEF0dHJzLlNDUk9MTF9ESVNBQkxFRCkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzZXRTY3JvbGxEaXNhYmxlKCk7XG4gICAgb3B0aW9ucz8ub25TY3JvbGxFbmFibGU/Lih0YXJnZXQpO1xuICAgIHJlbW92ZVNjcm9sbFNjcm9sbGJhcldpZHRoQWRqdXN0bWVudCh0YXJnZXQpO1xuICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoTm9TY3JvbGxBdHRycy5TQ1JPTExfRElTQUJMRUQpO1xuICB9O1xuICBjb25zdCB7XG4gICAgaW5pdDogZGlzYWJsZVBhZ2VTY3JvbGwsXG4gICAgcmVzZXQ6IGVuYWJsZVBhZ2VTY3JvbGwsXG4gICAgaW5pdElzQ2FsbGVkOiBwYWdlU2Nyb2xsSXNEaXNhYmxlZFxuICB9ID0gY3JlYXRlUXVldWUoXG4gICAgKCkgPT4gZGlzYWJsZVNjcm9sbChkb2N1bWVudC5ib2R5KSxcbiAgICAoKSA9PiBlbmFibGVTY3JvbGwoZG9jdW1lbnQuYm9keSlcbiAgKTtcbiAgY29uc3QgY3JlYXRlUGFnZVNjcm9sbFRvZ2dsZXIgPSAoKSA9PiB7XG4gICAgbGV0IGlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICBjb25zdCB0b2dnbGVyID0ge1xuICAgICAgZGlzYWJsZVBhZ2VTY3JvbGwoKSB7XG4gICAgICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRpc2FibGVQYWdlU2Nyb2xsKCk7XG4gICAgICAgIGlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIGVuYWJsZVBhZ2VTY3JvbGwoKSB7XG4gICAgICAgIGlmICghaXNEaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbmFibGVQYWdlU2Nyb2xsKCk7XG4gICAgICAgIGlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVQYWdlU2Nyb2xsKCkge1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgIHRvZ2dsZXIuZW5hYmxlUGFnZVNjcm9sbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvZ2dsZXIuZGlzYWJsZVBhZ2VTY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRvZ2dsZXI7XG4gIH07XG4gIGNvbnN0IG1hcmtTY3JvbGxhYmxlID0gKHRhcmdldCkgPT4ge1xuICAgIGFzQXJyYXkodGFyZ2V0KS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKE5vU2Nyb2xsQXR0cnMuU0NST0xMQUJMRSwgXCJcIik7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVubWFya1Njcm9sbGFibGUgPSAodGFyZ2V0KSA9PiB7XG4gICAgYXNBcnJheSh0YXJnZXQpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoTm9TY3JvbGxBdHRycy5TQ1JPTExBQkxFKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhZGp1c3RTY3JvbGxiYXJXaWR0aCxcbiAgICByZW1vdmVTY3JvbGxiYXJXaWR0aEFkanVzdG1lbnQsXG4gICAgdXBkYXRlQWxsU2Nyb2xsYmFyV2lkdGhBZGp1c3RtZW50LFxuICAgIGRpc2FibGVTY3JvbGwsXG4gICAgZW5hYmxlU2Nyb2xsLFxuICAgIGRpc2FibGVQYWdlU2Nyb2xsLFxuICAgIGVuYWJsZVBhZ2VTY3JvbGwsXG4gICAgcGFnZVNjcm9sbElzRGlzYWJsZWQsXG4gICAgY3JlYXRlUGFnZVNjcm9sbFRvZ2dsZXIsXG4gICAgbWFya1Njcm9sbGFibGUsXG4gICAgdW5tYXJrU2Nyb2xsYWJsZVxuICB9O1xufTtcblxuY29uc3Qge1xuICBhZGp1c3RTY3JvbGxiYXJXaWR0aCxcbiAgcmVtb3ZlU2Nyb2xsYmFyV2lkdGhBZGp1c3RtZW50LFxuICB1cGRhdGVBbGxTY3JvbGxiYXJXaWR0aEFkanVzdG1lbnQsXG4gIGRpc2FibGVTY3JvbGwsXG4gIGVuYWJsZVNjcm9sbCxcbiAgZGlzYWJsZVBhZ2VTY3JvbGwsXG4gIGVuYWJsZVBhZ2VTY3JvbGwsXG4gIHBhZ2VTY3JvbGxJc0Rpc2FibGVkLFxuICBjcmVhdGVQYWdlU2Nyb2xsVG9nZ2xlcixcbiAgbWFya1Njcm9sbGFibGUsXG4gIHVubWFya1Njcm9sbGFibGVcbn0gPSBjcmVhdGVOb1Njcm9sbCgpO1xuXG5leHBvcnQgeyBOb1Njcm9sbEF0dHJzLCBOb1Njcm9sbENzc1ZhcnMsIGFkanVzdFNjcm9sbGJhcldpZHRoLCBjcmVhdGVOb1Njcm9sbCwgY3JlYXRlUGFnZVNjcm9sbFRvZ2dsZXIsIGRpc2FibGVQYWdlU2Nyb2xsLCBkaXNhYmxlU2Nyb2xsLCBlbmFibGVQYWdlU2Nyb2xsLCBlbmFibGVTY3JvbGwsIG1hcmtTY3JvbGxhYmxlLCBwYWdlU2Nyb2xsSXNEaXNhYmxlZCwgcmVtb3ZlU2Nyb2xsYmFyV2lkdGhBZGp1c3RtZW50LCB1bm1hcmtTY3JvbGxhYmxlLCB1cGRhdGVBbGxTY3JvbGxiYXJXaWR0aEFkanVzdG1lbnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fluejs/noscroll/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/@fluejs/noscroll/dist/shared/noscroll.96a94b32.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@fluejs/noscroll/dist/shared/noscroll.96a94b32.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ DEFAULT_WINDOW_RESIZE_THROTTLE),\n/* harmony export */   N: () => (/* binding */ NoScrollAttrs),\n/* harmony export */   a: () => (/* binding */ attrAsSelector),\n/* harmony export */   b: () => (/* binding */ NoScrollCssVars),\n/* harmony export */   c: () => (/* binding */ asArray),\n/* harmony export */   d: () => (/* binding */ createQueue),\n/* harmony export */   g: () => (/* binding */ getScrollbarWidth),\n/* harmony export */   t: () => (/* binding */ throttle)\n/* harmony export */ });\nconst isBody = (target) => target === document.body;\nconst attrAsSelector = (attr) => `[${attr}]`;\nconst getScrollbarWidth = (target) => {\n  if (isBody(target)) {\n    const documentWidth = document.documentElement.clientWidth;\n    const windowWidth = window.innerWidth;\n    return windowWidth - documentWidth;\n  }\n  const borderLeftWidthSavedValue = target.style.borderLeftWidth;\n  const borderRightWidthSavedValue = target.style.borderRightWidth;\n  target.style.borderLeftWidth = \"0px\";\n  target.style.borderRightWidth = \"0px\";\n  const scrollbarWidth = target.offsetWidth - target.clientWidth;\n  target.style.borderLeftWidth = borderLeftWidthSavedValue;\n  target.style.borderRightWidth = borderRightWidthSavedValue;\n  return scrollbarWidth;\n};\nconst asArray = (data) => {\n  if (Array.isArray(data)) {\n    return data;\n  }\n  return [data];\n};\nfunction throttle(fn, wait) {\n  let inThrottle;\n  let lastFn;\n  let lastTime;\n  return (...args) => {\n    if (!inThrottle) {\n      fn(...args);\n      lastTime = Date.now();\n      inThrottle = true;\n    } else {\n      clearTimeout(lastFn);\n      lastFn = setTimeout(() => {\n        if (Date.now() - lastTime >= wait) {\n          fn(...args);\n          lastTime = Date.now();\n        }\n      }, Math.max(wait - (Date.now() - lastTime), 0));\n    }\n  };\n}\nconst createQueue = (onInit, onReset, onClear) => {\n  let counter = 0;\n  let isInitCalled = false;\n  const init = () => {\n    if (counter <= 0) {\n      onInit();\n      isInitCalled = true;\n    }\n    counter += 1;\n  };\n  const reset = () => {\n    if (counter > 0) {\n      counter -= 1;\n    }\n    if (counter <= 0 && isInitCalled) {\n      onReset();\n    }\n  };\n  const clearAndReset = () => {\n    counter = 0;\n    isInitCalled = false;\n    onClear?.();\n    onReset();\n  };\n  const initIsCalled = () => isInitCalled;\n  return {\n    init,\n    reset,\n    clearAndReset,\n    initIsCalled\n  };\n};\n\nconst NoScrollAttrs = {\n  SCROLL_DISABLED: \"data-noscroll-target-scroll-disabled\",\n  // scrollbar width adjustment for an element with a disabled scrollbar.\n  SCROLL_SCROLLBAR_WIDTH_ADJUSTMENT: \"data-noscroll-target-scroll-scrollbar-width-adjustment\",\n  SCROLLBAR_WIDTH_ADJUSTMENT: \"data-noscroll-target-scrollbar-width-adjustment\",\n  SCROLLABLE: \"data-noscroll-target-scrollable\",\n  GLOBAL_STYLES: \"data-noscroll-global-styles\"\n};\nconst NoScrollCssVars = {\n  TARGET_SCROLLBAR_WIDTH: \"--noscroll-target-scrollbar-width\",\n  TARGET_PADDING_RIGHT: \"--noscroll-target-padding-right\"\n};\nconst DEFAULT_WINDOW_RESIZE_THROTTLE = 200;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZsdWVqcy9ub3Njcm9sbC9kaXN0L3NoYXJlZC9ub3Njcm9sbC45NmE5NGIzMi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndWxwLXNjc3Mtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AZmx1ZWpzL25vc2Nyb2xsL2Rpc3Qvc2hhcmVkL25vc2Nyb2xsLjk2YTk0YjMyLm1qcz9jOWMyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzQm9keSA9ICh0YXJnZXQpID0+IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keTtcbmNvbnN0IGF0dHJBc1NlbGVjdG9yID0gKGF0dHIpID0+IGBbJHthdHRyfV1gO1xuY29uc3QgZ2V0U2Nyb2xsYmFyV2lkdGggPSAodGFyZ2V0KSA9PiB7XG4gIGlmIChpc0JvZHkodGFyZ2V0KSkge1xuICAgIGNvbnN0IGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgY29uc3Qgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICByZXR1cm4gd2luZG93V2lkdGggLSBkb2N1bWVudFdpZHRoO1xuICB9XG4gIGNvbnN0IGJvcmRlckxlZnRXaWR0aFNhdmVkVmFsdWUgPSB0YXJnZXQuc3R5bGUuYm9yZGVyTGVmdFdpZHRoO1xuICBjb25zdCBib3JkZXJSaWdodFdpZHRoU2F2ZWRWYWx1ZSA9IHRhcmdldC5zdHlsZS5ib3JkZXJSaWdodFdpZHRoO1xuICB0YXJnZXQuc3R5bGUuYm9yZGVyTGVmdFdpZHRoID0gXCIwcHhcIjtcbiAgdGFyZ2V0LnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBcIjBweFwiO1xuICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRhcmdldC5vZmZzZXRXaWR0aCAtIHRhcmdldC5jbGllbnRXaWR0aDtcbiAgdGFyZ2V0LnN0eWxlLmJvcmRlckxlZnRXaWR0aCA9IGJvcmRlckxlZnRXaWR0aFNhdmVkVmFsdWU7XG4gIHRhcmdldC5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gYm9yZGVyUmlnaHRXaWR0aFNhdmVkVmFsdWU7XG4gIHJldHVybiBzY3JvbGxiYXJXaWR0aDtcbn07XG5jb25zdCBhc0FycmF5ID0gKGRhdGEpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gW2RhdGFdO1xufTtcbmZ1bmN0aW9uIHRocm90dGxlKGZuLCB3YWl0KSB7XG4gIGxldCBpblRocm90dGxlO1xuICBsZXQgbGFzdEZuO1xuICBsZXQgbGFzdFRpbWU7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGlmICghaW5UaHJvdHRsZSkge1xuICAgICAgZm4oLi4uYXJncyk7XG4gICAgICBsYXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBpblRocm90dGxlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KGxhc3RGbik7XG4gICAgICBsYXN0Rm4gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBsYXN0VGltZSA+PSB3YWl0KSB7XG4gICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgICAgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICB9LCBNYXRoLm1heCh3YWl0IC0gKERhdGUubm93KCkgLSBsYXN0VGltZSksIDApKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBjcmVhdGVRdWV1ZSA9IChvbkluaXQsIG9uUmVzZXQsIG9uQ2xlYXIpID0+IHtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICBsZXQgaXNJbml0Q2FsbGVkID0gZmFsc2U7XG4gIGNvbnN0IGluaXQgPSAoKSA9PiB7XG4gICAgaWYgKGNvdW50ZXIgPD0gMCkge1xuICAgICAgb25Jbml0KCk7XG4gICAgICBpc0luaXRDYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb3VudGVyICs9IDE7XG4gIH07XG4gIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgY291bnRlciAtPSAxO1xuICAgIH1cbiAgICBpZiAoY291bnRlciA8PSAwICYmIGlzSW5pdENhbGxlZCkge1xuICAgICAgb25SZXNldCgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYXJBbmRSZXNldCA9ICgpID0+IHtcbiAgICBjb3VudGVyID0gMDtcbiAgICBpc0luaXRDYWxsZWQgPSBmYWxzZTtcbiAgICBvbkNsZWFyPy4oKTtcbiAgICBvblJlc2V0KCk7XG4gIH07XG4gIGNvbnN0IGluaXRJc0NhbGxlZCA9ICgpID0+IGlzSW5pdENhbGxlZDtcbiAgcmV0dXJuIHtcbiAgICBpbml0LFxuICAgIHJlc2V0LFxuICAgIGNsZWFyQW5kUmVzZXQsXG4gICAgaW5pdElzQ2FsbGVkXG4gIH07XG59O1xuXG5jb25zdCBOb1Njcm9sbEF0dHJzID0ge1xuICBTQ1JPTExfRElTQUJMRUQ6IFwiZGF0YS1ub3Njcm9sbC10YXJnZXQtc2Nyb2xsLWRpc2FibGVkXCIsXG4gIC8vIHNjcm9sbGJhciB3aWR0aCBhZGp1c3RtZW50IGZvciBhbiBlbGVtZW50IHdpdGggYSBkaXNhYmxlZCBzY3JvbGxiYXIuXG4gIFNDUk9MTF9TQ1JPTExCQVJfV0lEVEhfQURKVVNUTUVOVDogXCJkYXRhLW5vc2Nyb2xsLXRhcmdldC1zY3JvbGwtc2Nyb2xsYmFyLXdpZHRoLWFkanVzdG1lbnRcIixcbiAgU0NST0xMQkFSX1dJRFRIX0FESlVTVE1FTlQ6IFwiZGF0YS1ub3Njcm9sbC10YXJnZXQtc2Nyb2xsYmFyLXdpZHRoLWFkanVzdG1lbnRcIixcbiAgU0NST0xMQUJMRTogXCJkYXRhLW5vc2Nyb2xsLXRhcmdldC1zY3JvbGxhYmxlXCIsXG4gIEdMT0JBTF9TVFlMRVM6IFwiZGF0YS1ub3Njcm9sbC1nbG9iYWwtc3R5bGVzXCJcbn07XG5jb25zdCBOb1Njcm9sbENzc1ZhcnMgPSB7XG4gIFRBUkdFVF9TQ1JPTExCQVJfV0lEVEg6IFwiLS1ub3Njcm9sbC10YXJnZXQtc2Nyb2xsYmFyLXdpZHRoXCIsXG4gIFRBUkdFVF9QQURESU5HX1JJR0hUOiBcIi0tbm9zY3JvbGwtdGFyZ2V0LXBhZGRpbmctcmlnaHRcIlxufTtcbmNvbnN0IERFRkFVTFRfV0lORE9XX1JFU0laRV9USFJPVFRMRSA9IDIwMDtcblxuZXhwb3J0IHsgREVGQVVMVF9XSU5ET1dfUkVTSVpFX1RIUk9UVExFIGFzIEQsIE5vU2Nyb2xsQXR0cnMgYXMgTiwgYXR0ckFzU2VsZWN0b3IgYXMgYSwgTm9TY3JvbGxDc3NWYXJzIGFzIGIsIGFzQXJyYXkgYXMgYywgY3JlYXRlUXVldWUgYXMgZCwgZ2V0U2Nyb2xsYmFyV2lkdGggYXMgZywgdGhyb3R0bGUgYXMgdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fluejs/noscroll/dist/shared/noscroll.96a94b32.mjs\n");

/***/ }),

/***/ "./node_modules/inputmask/dist/inputmask.js":
/*!**************************************************!*\
  !*** ./node_modules/inputmask/dist/inputmask.js ***!
  \**************************************************/
/***/ (function(module) {

eval("/*!\n * dist/inputmask\n * https://github.com/RobinHerbots/Inputmask\n * Copyright (c) 2010 - 2024 Robin Herbots\n * Licensed under the MIT license\n * Version: 5.0.9\n */\n!function(e, t) {\n    if (true) module.exports = t(); else // removed by dead control flow\n{ var i, n; }\n}(\"undefined\" != typeof self ? self : this, (function() {\n    return function() {\n        \"use strict\";\n        var e = {\n            3976: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0;\n                t.default = {\n                    _maxTestPos: 500,\n                    placeholder: \"_\",\n                    optionalmarker: [ \"[\", \"]\" ],\n                    quantifiermarker: [ \"{\", \"}\" ],\n                    groupmarker: [ \"(\", \")\" ],\n                    alternatormarker: \"|\",\n                    escapeChar: \"\\\\\",\n                    mask: null,\n                    regex: null,\n                    oncomplete: function() {},\n                    onincomplete: function() {},\n                    oncleared: function() {},\n                    repeat: 0,\n                    greedy: !1,\n                    autoUnmask: !1,\n                    removeMaskOnSubmit: !1,\n                    clearMaskOnLostFocus: !0,\n                    insertMode: !0,\n                    insertModeVisual: !0,\n                    clearIncomplete: !1,\n                    alias: null,\n                    onKeyDown: function() {},\n                    onBeforeMask: null,\n                    onBeforePaste: function(e, t) {\n                        return \"function\" == typeof t.onBeforeMask ? t.onBeforeMask.call(this, e, t) : e;\n                    },\n                    onBeforeWrite: null,\n                    onUnMask: null,\n                    showMaskOnFocus: !0,\n                    showMaskOnHover: !0,\n                    onKeyValidation: function() {},\n                    skipOptionalPartCharacter: \" \",\n                    numericInput: !1,\n                    rightAlign: !1,\n                    undoOnEscape: !0,\n                    radixPoint: \"\",\n                    _radixDance: !1,\n                    groupSeparator: \"\",\n                    keepStatic: null,\n                    positionCaretOnTab: !0,\n                    tabThrough: !1,\n                    supportsInputType: [ \"text\", \"tel\", \"url\", \"password\", \"search\" ],\n                    isComplete: null,\n                    preValidation: null,\n                    postValidation: null,\n                    staticDefinitionSymbol: void 0,\n                    jitMasking: !1,\n                    nullable: !0,\n                    inputEventOnly: !1,\n                    noValuePatching: !1,\n                    positionCaretOnClick: \"lvp\",\n                    casing: null,\n                    inputmode: \"text\",\n                    importDataAttributes: !0,\n                    shiftPositions: !0,\n                    usePrototypeDefinitions: !0,\n                    validationEventTimeOut: 3e3,\n                    substitutes: {}\n                };\n            },\n            7392: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0;\n                t.default = {\n                    9: {\n                        validator: \"[0-9\\uff10-\\uff19]\",\n                        definitionSymbol: \"*\"\n                    },\n                    a: {\n                        validator: \"[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\n                        definitionSymbol: \"*\"\n                    },\n                    \"*\": {\n                        validator: \"[0-9\\uff10-\\uff19A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\"\n                    }\n                };\n            },\n            253: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = function(e, t, n) {\n                    if (void 0 === n) return e.__data ? e.__data[t] : null;\n                    e.__data = e.__data || {}, e.__data[t] = n;\n                };\n            },\n            3776: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.Event = void 0, t.off = function(e, t) {\n                    var n, i;\n                    u(this[0]) && e && (n = this[0].eventRegistry, i = this[0], e.split(\" \").forEach((function(e) {\n                        var a = o(e.split(\".\"), 2);\n                        (function(e, i) {\n                            var a, r, o = [];\n                            if (e.length > 0) if (void 0 === t) for (a = 0, r = n[e][i].length; a < r; a++) o.push({\n                                ev: e,\n                                namespace: i && i.length > 0 ? i : \"global\",\n                                handler: n[e][i][a]\n                            }); else o.push({\n                                ev: e,\n                                namespace: i && i.length > 0 ? i : \"global\",\n                                handler: t\n                            }); else if (i.length > 0) for (var l in n) for (var s in n[l]) if (s === i) if (void 0 === t) for (a = 0, \n                            r = n[l][s].length; a < r; a++) o.push({\n                                ev: l,\n                                namespace: s,\n                                handler: n[l][s][a]\n                            }); else o.push({\n                                ev: l,\n                                namespace: s,\n                                handler: t\n                            });\n                            return o;\n                        })(a[0], a[1]).forEach((function(e) {\n                            var t = e.ev, a = e.handler;\n                            !function(e, t, a) {\n                                if (e in n == 1) if (i.removeEventListener ? i.removeEventListener(e, a, !1) : i.detachEvent && i.detachEvent(\"on\".concat(e), a), \n                                \"global\" === t) for (var r in n[e]) n[e][r].splice(n[e][r].indexOf(a), 1); else n[e][t].splice(n[e][t].indexOf(a), 1);\n                            }(t, e.namespace, a);\n                        }));\n                    })));\n                    return this;\n                }, t.on = function(e, t) {\n                    if (u(this[0])) {\n                        var n = this[0].eventRegistry, i = this[0];\n                        e.split(\" \").forEach((function(e) {\n                            var a = o(e.split(\".\"), 2), r = a[0], l = a[1];\n                            !function(e, a) {\n                                i.addEventListener ? i.addEventListener(e, t, !1) : i.attachEvent && i.attachEvent(\"on\".concat(e), t), \n                                n[e] = n[e] || {}, n[e][a] = n[e][a] || [], n[e][a].push(t);\n                            }(r, void 0 === l ? \"global\" : l);\n                        }));\n                    }\n                    return this;\n                }, t.trigger = function(e) {\n                    var t = arguments;\n                    if (u(this[0])) for (var n = this[0].eventRegistry, i = this[0], o = \"string\" == typeof e ? e.split(\" \") : [ e.type ], l = 0; l < o.length; l++) {\n                        var s = o[l].split(\".\"), f = s[0], p = s[1] || \"global\";\n                        if (void 0 !== c && \"global\" === p) {\n                            var d, h = {\n                                bubbles: !0,\n                                cancelable: !0,\n                                composed: !0,\n                                detail: arguments[1]\n                            };\n                            if (c.createEvent) {\n                                try {\n                                    if (\"input\" === f) h.inputType = \"insertText\", d = new InputEvent(f, h); else d = new CustomEvent(f, h);\n                                } catch (e) {\n                                    (d = c.createEvent(\"CustomEvent\")).initCustomEvent(f, h.bubbles, h.cancelable, h.detail);\n                                }\n                                e.type && (0, a.default)(d, e), i.dispatchEvent(d);\n                            } else (d = c.createEventObject()).eventType = f, d.detail = arguments[1], e.type && (0, \n                            a.default)(d, e), i.fireEvent(\"on\" + d.eventType, d);\n                        } else if (void 0 !== n[f]) {\n                            arguments[0] = arguments[0].type ? arguments[0] : r.default.Event(arguments[0]), \n                            arguments[0].detail = arguments.slice(1);\n                            var v = n[f];\n                            (\"global\" === p ? Object.values(v).flat() : v[p]).forEach((function(e) {\n                                return e.apply(i, t);\n                            }));\n                        }\n                    }\n                    return this;\n                };\n                var i = s(n(9380)), a = s(n(600)), r = s(n(4963));\n                function o(e, t) {\n                    return function(e) {\n                        if (Array.isArray(e)) return e;\n                    }(e) || function(e, t) {\n                        var n = null == e ? null : \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n                        if (null != n) {\n                            var i, a, r, o, l = [], s = !0, c = !1;\n                            try {\n                                if (r = (n = n.call(e)).next, 0 === t) {\n                                    if (Object(n) !== n) return;\n                                    s = !1;\n                                } else for (;!(s = (i = r.call(n)).done) && (l.push(i.value), l.length !== t); s = !0) ;\n                            } catch (e) {\n                                c = !0, a = e;\n                            } finally {\n                                try {\n                                    if (!s && null != n.return && (o = n.return(), Object(o) !== o)) return;\n                                } finally {\n                                    if (c) throw a;\n                                }\n                            }\n                            return l;\n                        }\n                    }(e, t) || function(e, t) {\n                        if (!e) return;\n                        if (\"string\" == typeof e) return l(e, t);\n                        var n = Object.prototype.toString.call(e).slice(8, -1);\n                        \"Object\" === n && e.constructor && (n = e.constructor.name);\n                        if (\"Map\" === n || \"Set\" === n) return Array.from(e);\n                        if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return l(e, t);\n                    }(e, t) || function() {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                    }();\n                }\n                function l(e, t) {\n                    (null == t || t > e.length) && (t = e.length);\n                    for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n                    return i;\n                }\n                function s(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var c = i.default.document;\n                function u(e) {\n                    return e instanceof Element;\n                }\n                var f = t.Event = void 0;\n                \"function\" == typeof i.default.CustomEvent ? t.Event = f = i.default.CustomEvent : i.default.Event && c && c.createEvent ? (t.Event = f = function(e, t) {\n                    t = t || {\n                        bubbles: !1,\n                        cancelable: !1,\n                        composed: !0,\n                        detail: void 0\n                    };\n                    var n = c.createEvent(\"CustomEvent\");\n                    return n.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), n;\n                }, f.prototype = i.default.Event.prototype) : \"undefined\" != typeof Event && (t.Event = f = Event);\n            },\n            600: function(e, t) {\n                function n(e) {\n                    return n = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    }, n(e);\n                }\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = function e() {\n                    var t, i, a, r, o, l, s = arguments[0] || {}, c = 1, u = arguments.length, f = !1;\n                    \"boolean\" == typeof s && (f = s, s = arguments[c] || {}, c++);\n                    \"object\" !== n(s) && \"function\" != typeof s && (s = {});\n                    for (;c < u; c++) if (null != (t = arguments[c])) for (i in t) a = s[i], s !== (r = t[i]) && (f && r && (\"[object Object]\" === Object.prototype.toString.call(r) || (o = Array.isArray(r))) ? (o ? (o = !1, \n                    l = a && Array.isArray(a) ? a : []) : l = a && \"[object Object]\" === Object.prototype.toString.call(a) ? a : {}, \n                    s[i] = e(f, l, r)) : void 0 !== r && (s[i] = r));\n                    return s;\n                };\n            },\n            4963: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0;\n                var i = l(n(9380)), a = l(n(253)), r = n(3776), o = l(n(600));\n                function l(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var s = i.default.document;\n                function c(e) {\n                    return e instanceof c ? e : this instanceof c ? void (null != e && e !== i.default && (this[0] = e.nodeName ? e : void 0 !== e[0] && e[0].nodeName ? e[0] : s.querySelector(e), \n                    void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new c(e);\n                }\n                c.prototype = {\n                    on: r.on,\n                    off: r.off,\n                    trigger: r.trigger\n                }, c.extend = o.default, c.data = a.default, c.Event = r.Event;\n                t.default = c;\n            },\n            9845: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.mobile = t.iphone = t.ie = void 0;\n                var i, a = (i = n(9380)) && i.__esModule ? i : {\n                    default: i\n                };\n                var r = a.default.navigator && a.default.navigator.userAgent || \"\";\n                t.ie = r.indexOf(\"MSIE \") > 0 || r.indexOf(\"Trident/\") > 0, t.mobile = a.default.navigator && a.default.navigator.userAgentData && a.default.navigator.userAgentData.mobile || a.default.navigator && a.default.navigator.maxTouchPoints || \"ontouchstart\" in a.default, \n                t.iphone = /iphone/i.test(r);\n            },\n            7184: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = function(e) {\n                    return e.replace(n, \"\\\\$1\");\n                };\n                var n = new RegExp(\"(\\\\\" + [ \"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\" ].join(\"|\\\\\") + \")\", \"gim\");\n            },\n            6030: function(e, t, n) {\n                function i(e) {\n                    return i = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    }, i(e);\n                }\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.EventHandlers = void 0;\n                var a, r = n(9845), o = (a = n(9380)) && a.__esModule ? a : {\n                    default: a\n                }, l = n(7760), s = n(2839), c = n(8711), u = n(7215), f = n(4713);\n                function p() {\n                    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ p = function() {\n                        return t;\n                    };\n                    var e, t = {}, n = Object.prototype, a = n.hasOwnProperty, r = Object.defineProperty || function(e, t, n) {\n                        e[t] = n.value;\n                    }, o = \"function\" == typeof Symbol ? Symbol : {}, l = o.iterator || \"@@iterator\", s = o.asyncIterator || \"@@asyncIterator\", c = o.toStringTag || \"@@toStringTag\";\n                    function u(e, t, n) {\n                        return Object.defineProperty(e, t, {\n                            value: n,\n                            enumerable: !0,\n                            configurable: !0,\n                            writable: !0\n                        }), e[t];\n                    }\n                    try {\n                        u({}, \"\");\n                    } catch (e) {\n                        u = function(e, t, n) {\n                            return e[t] = n;\n                        };\n                    }\n                    function f(e, t, n, i) {\n                        var a = t && t.prototype instanceof k ? t : k, o = Object.create(a.prototype), l = new D(i || []);\n                        return r(o, \"_invoke\", {\n                            value: E(e, n, l)\n                        }), o;\n                    }\n                    function d(e, t, n) {\n                        try {\n                            return {\n                                type: \"normal\",\n                                arg: e.call(t, n)\n                            };\n                        } catch (e) {\n                            return {\n                                type: \"throw\",\n                                arg: e\n                            };\n                        }\n                    }\n                    t.wrap = f;\n                    var h = \"suspendedStart\", v = \"suspendedYield\", m = \"executing\", g = \"completed\", y = {};\n                    function k() {}\n                    function b() {}\n                    function x() {}\n                    var w = {};\n                    u(w, l, (function() {\n                        return this;\n                    }));\n                    var P = Object.getPrototypeOf, S = P && P(P(L([])));\n                    S && S !== n && a.call(S, l) && (w = S);\n                    var O = x.prototype = k.prototype = Object.create(w);\n                    function _(e) {\n                        [ \"next\", \"throw\", \"return\" ].forEach((function(t) {\n                            u(e, t, (function(e) {\n                                return this._invoke(t, e);\n                            }));\n                        }));\n                    }\n                    function M(e, t) {\n                        function n(r, o, l, s) {\n                            var c = d(e[r], e, o);\n                            if (\"throw\" !== c.type) {\n                                var u = c.arg, f = u.value;\n                                return f && \"object\" == i(f) && a.call(f, \"__await\") ? t.resolve(f.__await).then((function(e) {\n                                    n(\"next\", e, l, s);\n                                }), (function(e) {\n                                    n(\"throw\", e, l, s);\n                                })) : t.resolve(f).then((function(e) {\n                                    u.value = e, l(u);\n                                }), (function(e) {\n                                    return n(\"throw\", e, l, s);\n                                }));\n                            }\n                            s(c.arg);\n                        }\n                        var o;\n                        r(this, \"_invoke\", {\n                            value: function(e, i) {\n                                function a() {\n                                    return new t((function(t, a) {\n                                        n(e, i, t, a);\n                                    }));\n                                }\n                                return o = o ? o.then(a, a) : a();\n                            }\n                        });\n                    }\n                    function E(t, n, i) {\n                        var a = h;\n                        return function(r, o) {\n                            if (a === m) throw new Error(\"Generator is already running\");\n                            if (a === g) {\n                                if (\"throw\" === r) throw o;\n                                return {\n                                    value: e,\n                                    done: !0\n                                };\n                            }\n                            for (i.method = r, i.arg = o; ;) {\n                                var l = i.delegate;\n                                if (l) {\n                                    var s = j(l, i);\n                                    if (s) {\n                                        if (s === y) continue;\n                                        return s;\n                                    }\n                                }\n                                if (\"next\" === i.method) i.sent = i._sent = i.arg; else if (\"throw\" === i.method) {\n                                    if (a === h) throw a = g, i.arg;\n                                    i.dispatchException(i.arg);\n                                } else \"return\" === i.method && i.abrupt(\"return\", i.arg);\n                                a = m;\n                                var c = d(t, n, i);\n                                if (\"normal\" === c.type) {\n                                    if (a = i.done ? g : v, c.arg === y) continue;\n                                    return {\n                                        value: c.arg,\n                                        done: i.done\n                                    };\n                                }\n                                \"throw\" === c.type && (a = g, i.method = \"throw\", i.arg = c.arg);\n                            }\n                        };\n                    }\n                    function j(t, n) {\n                        var i = n.method, a = t.iterator[i];\n                        if (a === e) return n.delegate = null, \"throw\" === i && t.iterator.return && (n.method = \"return\", \n                        n.arg = e, j(t, n), \"throw\" === n.method) || \"return\" !== i && (n.method = \"throw\", \n                        n.arg = new TypeError(\"The iterator does not provide a '\" + i + \"' method\")), y;\n                        var r = d(a, t.iterator, n.arg);\n                        if (\"throw\" === r.type) return n.method = \"throw\", n.arg = r.arg, n.delegate = null, \n                        y;\n                        var o = r.arg;\n                        return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, \"return\" !== n.method && (n.method = \"next\", \n                        n.arg = e), n.delegate = null, y) : o : (n.method = \"throw\", n.arg = new TypeError(\"iterator result is not an object\"), \n                        n.delegate = null, y);\n                    }\n                    function T(e) {\n                        var t = {\n                            tryLoc: e[0]\n                        };\n                        1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), \n                        this.tryEntries.push(t);\n                    }\n                    function A(e) {\n                        var t = e.completion || {};\n                        t.type = \"normal\", delete t.arg, e.completion = t;\n                    }\n                    function D(e) {\n                        this.tryEntries = [ {\n                            tryLoc: \"root\"\n                        } ], e.forEach(T, this), this.reset(!0);\n                    }\n                    function L(t) {\n                        if (t || \"\" === t) {\n                            var n = t[l];\n                            if (n) return n.call(t);\n                            if (\"function\" == typeof t.next) return t;\n                            if (!isNaN(t.length)) {\n                                var r = -1, o = function n() {\n                                    for (;++r < t.length; ) if (a.call(t, r)) return n.value = t[r], n.done = !1, n;\n                                    return n.value = e, n.done = !0, n;\n                                };\n                                return o.next = o;\n                            }\n                        }\n                        throw new TypeError(i(t) + \" is not iterable\");\n                    }\n                    return b.prototype = x, r(O, \"constructor\", {\n                        value: x,\n                        configurable: !0\n                    }), r(x, \"constructor\", {\n                        value: b,\n                        configurable: !0\n                    }), b.displayName = u(x, c, \"GeneratorFunction\"), t.isGeneratorFunction = function(e) {\n                        var t = \"function\" == typeof e && e.constructor;\n                        return !!t && (t === b || \"GeneratorFunction\" === (t.displayName || t.name));\n                    }, t.mark = function(e) {\n                        return Object.setPrototypeOf ? Object.setPrototypeOf(e, x) : (e.__proto__ = x, u(e, c, \"GeneratorFunction\")), \n                        e.prototype = Object.create(O), e;\n                    }, t.awrap = function(e) {\n                        return {\n                            __await: e\n                        };\n                    }, _(M.prototype), u(M.prototype, s, (function() {\n                        return this;\n                    })), t.AsyncIterator = M, t.async = function(e, n, i, a, r) {\n                        void 0 === r && (r = Promise);\n                        var o = new M(f(e, n, i, a), r);\n                        return t.isGeneratorFunction(n) ? o : o.next().then((function(e) {\n                            return e.done ? e.value : o.next();\n                        }));\n                    }, _(O), u(O, c, \"Generator\"), u(O, l, (function() {\n                        return this;\n                    })), u(O, \"toString\", (function() {\n                        return \"[object Generator]\";\n                    })), t.keys = function(e) {\n                        var t = Object(e), n = [];\n                        for (var i in t) n.push(i);\n                        return n.reverse(), function e() {\n                            for (;n.length; ) {\n                                var i = n.pop();\n                                if (i in t) return e.value = i, e.done = !1, e;\n                            }\n                            return e.done = !0, e;\n                        };\n                    }, t.values = L, D.prototype = {\n                        constructor: D,\n                        reset: function(t) {\n                            if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, \n                            this.method = \"next\", this.arg = e, this.tryEntries.forEach(A), !t) for (var n in this) \"t\" === n.charAt(0) && a.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e);\n                        },\n                        stop: function() {\n                            this.done = !0;\n                            var e = this.tryEntries[0].completion;\n                            if (\"throw\" === e.type) throw e.arg;\n                            return this.rval;\n                        },\n                        dispatchException: function(t) {\n                            if (this.done) throw t;\n                            var n = this;\n                            function i(i, a) {\n                                return l.type = \"throw\", l.arg = t, n.next = i, a && (n.method = \"next\", n.arg = e), \n                                !!a;\n                            }\n                            for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n                                var o = this.tryEntries[r], l = o.completion;\n                                if (\"root\" === o.tryLoc) return i(\"end\");\n                                if (o.tryLoc <= this.prev) {\n                                    var s = a.call(o, \"catchLoc\"), c = a.call(o, \"finallyLoc\");\n                                    if (s && c) {\n                                        if (this.prev < o.catchLoc) return i(o.catchLoc, !0);\n                                        if (this.prev < o.finallyLoc) return i(o.finallyLoc);\n                                    } else if (s) {\n                                        if (this.prev < o.catchLoc) return i(o.catchLoc, !0);\n                                    } else {\n                                        if (!c) throw new Error(\"try statement without catch or finally\");\n                                        if (this.prev < o.finallyLoc) return i(o.finallyLoc);\n                                    }\n                                }\n                            }\n                        },\n                        abrupt: function(e, t) {\n                            for (var n = this.tryEntries.length - 1; n >= 0; --n) {\n                                var i = this.tryEntries[n];\n                                if (i.tryLoc <= this.prev && a.call(i, \"finallyLoc\") && this.prev < i.finallyLoc) {\n                                    var r = i;\n                                    break;\n                                }\n                            }\n                            r && (\"break\" === e || \"continue\" === e) && r.tryLoc <= t && t <= r.finallyLoc && (r = null);\n                            var o = r ? r.completion : {};\n                            return o.type = e, o.arg = t, r ? (this.method = \"next\", this.next = r.finallyLoc, \n                            y) : this.complete(o);\n                        },\n                        complete: function(e, t) {\n                            if (\"throw\" === e.type) throw e.arg;\n                            return \"break\" === e.type || \"continue\" === e.type ? this.next = e.arg : \"return\" === e.type ? (this.rval = this.arg = e.arg, \n                            this.method = \"return\", this.next = \"end\") : \"normal\" === e.type && t && (this.next = t), \n                            y;\n                        },\n                        finish: function(e) {\n                            for (var t = this.tryEntries.length - 1; t >= 0; --t) {\n                                var n = this.tryEntries[t];\n                                if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), A(n), y;\n                            }\n                        },\n                        catch: function(e) {\n                            for (var t = this.tryEntries.length - 1; t >= 0; --t) {\n                                var n = this.tryEntries[t];\n                                if (n.tryLoc === e) {\n                                    var i = n.completion;\n                                    if (\"throw\" === i.type) {\n                                        var a = i.arg;\n                                        A(n);\n                                    }\n                                    return a;\n                                }\n                            }\n                            throw new Error(\"illegal catch attempt\");\n                        },\n                        delegateYield: function(t, n, i) {\n                            return this.delegate = {\n                                iterator: L(t),\n                                resultName: n,\n                                nextLoc: i\n                            }, \"next\" === this.method && (this.arg = e), y;\n                        }\n                    }, t;\n                }\n                function d(e, t) {\n                    var n = \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n                    if (!n) {\n                        if (Array.isArray(e) || (n = function(e, t) {\n                            if (!e) return;\n                            if (\"string\" == typeof e) return h(e, t);\n                            var n = Object.prototype.toString.call(e).slice(8, -1);\n                            \"Object\" === n && e.constructor && (n = e.constructor.name);\n                            if (\"Map\" === n || \"Set\" === n) return Array.from(e);\n                            if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return h(e, t);\n                        }(e)) || t && e && \"number\" == typeof e.length) {\n                            n && (e = n);\n                            var i = 0, a = function() {};\n                            return {\n                                s: a,\n                                n: function() {\n                                    return i >= e.length ? {\n                                        done: !0\n                                    } : {\n                                        done: !1,\n                                        value: e[i++]\n                                    };\n                                },\n                                e: function(e) {\n                                    throw e;\n                                },\n                                f: a\n                            };\n                        }\n                        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                    }\n                    var r, o = !0, l = !1;\n                    return {\n                        s: function() {\n                            n = n.call(e);\n                        },\n                        n: function() {\n                            var e = n.next();\n                            return o = e.done, e;\n                        },\n                        e: function(e) {\n                            l = !0, r = e;\n                        },\n                        f: function() {\n                            try {\n                                o || null == n.return || n.return();\n                            } finally {\n                                if (l) throw r;\n                            }\n                        }\n                    };\n                }\n                function h(e, t) {\n                    (null == t || t > e.length) && (t = e.length);\n                    for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n                    return i;\n                }\n                function v(e, t, n, i, a, r, o) {\n                    try {\n                        var l = e[r](o), s = l.value;\n                    } catch (e) {\n                        return void n(e);\n                    }\n                    l.done ? t(s) : Promise.resolve(s).then(i, a);\n                }\n                var m, g, y = t.EventHandlers = {\n                    keyEvent: function(e, t, n, i, a) {\n                        var o = this.inputmask, p = o.opts, d = o.dependencyLib, h = o.maskset, v = this, m = d(v), g = e.key, k = c.caret.call(o, v), b = p.onKeyDown.call(this, e, c.getBuffer.call(o), k, p);\n                        if (void 0 !== b) return b;\n                        if (g === s.keys.Backspace || g === s.keys.Delete || r.iphone && g === s.keys.BACKSPACE_SAFARI || e.ctrlKey && g === s.keys.x && !(\"oncut\" in v)) e.preventDefault(), \n                        u.handleRemove.call(o, v, g, k), (0, l.writeBuffer)(v, c.getBuffer.call(o, !0), h.p, e, v.inputmask._valueGet() !== c.getBuffer.call(o).join(\"\")); else if (g === s.keys.End || g === s.keys.PageDown) {\n                            e.preventDefault();\n                            var x = c.seekNext.call(o, c.getLastValidPosition.call(o));\n                            c.caret.call(o, v, e.shiftKey ? k.begin : x, x, !0);\n                        } else g === s.keys.Home && !e.shiftKey || g === s.keys.PageUp ? (e.preventDefault(), \n                        c.caret.call(o, v, 0, e.shiftKey ? k.begin : 0, !0)) : p.undoOnEscape && g === s.keys.Escape && !0 !== e.altKey ? ((0, \n                        l.checkVal)(v, !0, !1, o.undoValue.split(\"\")), m.trigger(\"click\")) : g !== s.keys.Insert || e.shiftKey || e.ctrlKey || void 0 !== o.userOptions.insertMode ? !0 === p.tabThrough && g === s.keys.Tab ? !0 === e.shiftKey ? (k.end = c.seekPrevious.call(o, k.end, !0), \n                        !0 === f.getTest.call(o, k.end - 1).match.static && k.end--, k.begin = c.seekPrevious.call(o, k.end, !0), \n                        k.begin >= 0 && k.end > 0 && (e.preventDefault(), c.caret.call(o, v, k.begin, k.end))) : (k.begin = c.seekNext.call(o, k.begin, !0), \n                        k.end = c.seekNext.call(o, k.begin, !0), k.end < h.maskLength && k.end--, k.begin <= h.maskLength && (e.preventDefault(), \n                        c.caret.call(o, v, k.begin, k.end))) : e.shiftKey || (p.insertModeVisual && !1 === p.insertMode ? g === s.keys.ArrowRight ? setTimeout((function() {\n                            var e = c.caret.call(o, v);\n                            c.caret.call(o, v, e.begin);\n                        }), 0) : g === s.keys.ArrowLeft && setTimeout((function() {\n                            var e = c.translatePosition.call(o, v.inputmask.caretPos.begin);\n                            c.translatePosition.call(o, v.inputmask.caretPos.end);\n                            o.isRTL ? c.caret.call(o, v, e + (e === h.maskLength ? 0 : 1)) : c.caret.call(o, v, e - (0 === e ? 0 : 1));\n                        }), 0) : void 0 === o.keyEventHook || o.keyEventHook(e)) : u.isSelection.call(o, k) ? p.insertMode = !p.insertMode : (p.insertMode = !p.insertMode, \n                        c.caret.call(o, v, k.begin, k.begin));\n                        return o.isComposing = g == s.keys.Process || g == s.keys.Unidentified, o.ignorable = g.length > 1 && !(\"textarea\" === v.tagName.toLowerCase() && g == s.keys.Enter), \n                        y.keypressEvent.call(this, e, t, n, i, a);\n                    },\n                    keypressEvent: function(e, t, n, i, a) {\n                        var r = this.inputmask || this, o = r.opts, f = r.dependencyLib, p = r.maskset, d = r.el, h = f(d), v = e.key;\n                        if (!0 === t || e.ctrlKey && e.altKey && !r.ignorable || !(e.ctrlKey || e.metaKey || r.ignorable)) {\n                            if (v) {\n                                var m, g = t ? {\n                                    begin: a,\n                                    end: a\n                                } : c.caret.call(r, d);\n                                t || (v = o.substitutes[v] || v), p.writeOutBuffer = !0;\n                                var y = u.isValid.call(r, g, v, i, void 0, void 0, void 0, t);\n                                if (!1 !== y && (c.resetMaskSet.call(r, !0), m = void 0 !== y.caret ? y.caret : c.seekNext.call(r, y.pos.begin ? y.pos.begin : y.pos), \n                                p.p = m), m = o.numericInput && void 0 === y.caret ? c.seekPrevious.call(r, m) : m, \n                                !1 !== n && (setTimeout((function() {\n                                    o.onKeyValidation.call(d, v, y);\n                                }), 0), p.writeOutBuffer && !1 !== y)) {\n                                    var k = c.getBuffer.call(r);\n                                    (0, l.writeBuffer)(d, k, m, e, !0 !== t);\n                                }\n                                if (e.preventDefault(), t) return !1 !== y && (y.forwardPosition = m), y;\n                            }\n                        } else v === s.keys.Enter && r.undoValue !== r._valueGet(!0) && (r.undoValue = r._valueGet(!0), \n                        setTimeout((function() {\n                            h.trigger(\"change\");\n                        }), 0));\n                    },\n                    pasteEvent: (m = p().mark((function e(t) {\n                        var n, i, a, r, s, u;\n                        return p().wrap((function(e) {\n                            for (;;) switch (e.prev = e.next) {\n                              case 0:\n                                n = function(e, n, i, a, o) {\n                                    var s = c.caret.call(e, n, void 0, void 0, !0), u = i.substr(0, s.begin), f = i.substr(s.end, i.length);\n                                    if (u == (e.isRTL ? c.getBufferTemplate.call(e).slice().reverse() : c.getBufferTemplate.call(e)).slice(0, s.begin).join(\"\") && (u = \"\"), \n                                    f == (e.isRTL ? c.getBufferTemplate.call(e).slice().reverse() : c.getBufferTemplate.call(e)).slice(s.end).join(\"\") && (f = \"\"), \n                                    a = u + a + f, e.isRTL && !0 !== r.numericInput) {\n                                        a = a.split(\"\");\n                                        var p, h = d(c.getBufferTemplate.call(e));\n                                        try {\n                                            for (h.s(); !(p = h.n()).done; ) {\n                                                var v = p.value;\n                                                a[0] === v && a.shift();\n                                            }\n                                        } catch (e) {\n                                            h.e(e);\n                                        } finally {\n                                            h.f();\n                                        }\n                                        a = a.reverse().join(\"\");\n                                    }\n                                    var m = a;\n                                    if (\"function\" == typeof o) {\n                                        if (!1 === (m = o.call(e, m, r))) return !1;\n                                        m || (m = i);\n                                    }\n                                    (0, l.checkVal)(n, !0, !1, m.toString().split(\"\"), t);\n                                }, i = this, a = this.inputmask, r = a.opts, s = a._valueGet(!0), a.skipInputEvent = !0, \n                                t.clipboardData && t.clipboardData.getData ? u = t.clipboardData.getData(\"text/plain\") : o.default.clipboardData && o.default.clipboardData.getData && (u = o.default.clipboardData.getData(\"Text\")), \n                                n(a, i, s, u, r.onBeforePaste), t.preventDefault();\n\n                              case 7:\n                              case \"end\":\n                                return e.stop();\n                            }\n                        }), e, this);\n                    })), g = function() {\n                        var e = this, t = arguments;\n                        return new Promise((function(n, i) {\n                            var a = m.apply(e, t);\n                            function r(e) {\n                                v(a, n, i, r, o, \"next\", e);\n                            }\n                            function o(e) {\n                                v(a, n, i, r, o, \"throw\", e);\n                            }\n                            r(void 0);\n                        }));\n                    }, function(e) {\n                        return g.apply(this, arguments);\n                    }),\n                    inputFallBackEvent: function(e) {\n                        var t = this.inputmask, n = t.opts, i = t.dependencyLib;\n                        var a, o = this, u = o.inputmask._valueGet(!0), p = (t.isRTL ? c.getBuffer.call(t).slice().reverse() : c.getBuffer.call(t)).join(\"\"), d = c.caret.call(t, o, void 0, void 0, !0);\n                        if (p !== u) {\n                            if (a = function(e, i, a) {\n                                for (var r, o, l, s = e.substr(0, a.begin).split(\"\"), u = e.substr(a.begin).split(\"\"), p = i.substr(0, a.begin).split(\"\"), d = i.substr(a.begin).split(\"\"), h = s.length >= p.length ? s.length : p.length, v = u.length >= d.length ? u.length : d.length, m = \"\", g = [], y = \"~\"; s.length < h; ) s.push(y);\n                                for (;p.length < h; ) p.push(y);\n                                for (;u.length < v; ) u.unshift(y);\n                                for (;d.length < v; ) d.unshift(y);\n                                var k = s.concat(u), b = p.concat(d);\n                                for (o = 0, r = k.length; o < r; o++) switch (l = f.getPlaceholder.call(t, c.translatePosition.call(t, o)), \n                                m) {\n                                  case \"insertText\":\n                                    b[o - 1] === k[o] && a.begin == k.length - 1 && g.push(k[o]), o = r;\n                                    break;\n\n                                  case \"insertReplacementText\":\n                                  case \"deleteContentBackward\":\n                                    k[o] === y ? a.end++ : o = r;\n                                    break;\n\n                                  default:\n                                    k[o] !== b[o] && (k[o + 1] !== y && k[o + 1] !== l && void 0 !== k[o + 1] || (b[o] !== l || b[o + 1] !== y) && b[o] !== y ? b[o + 1] === y && b[o] === k[o + 1] ? (m = \"insertText\", \n                                    g.push(k[o]), a.begin--, a.end--) : k[o] !== l && k[o] !== y && (k[o + 1] === y || b[o] !== k[o] && b[o + 1] === k[o + 1]) ? (m = \"insertReplacementText\", \n                                    g.push(k[o]), a.begin--) : k[o] === y ? (m = \"deleteContentBackward\", (c.isMask.call(t, c.translatePosition.call(t, o), !0) || b[o] === n.radixPoint) && a.end++) : o = r : (m = \"insertText\", \n                                    g.push(k[o]), a.begin--, a.end--));\n                                }\n                                return {\n                                    action: m,\n                                    data: g,\n                                    caret: a\n                                };\n                            }(u, p, d), (o.inputmask.shadowRoot || o.ownerDocument).activeElement !== o && o.focus(), \n                            (0, l.writeBuffer)(o, c.getBuffer.call(t)), c.caret.call(t, o, d.begin, d.end, !0), \n                            !r.mobile && t.skipNextInsert && \"insertText\" === e.inputType && \"insertText\" === a.action && t.isComposing) return !1;\n                            switch (\"insertCompositionText\" === e.inputType && \"insertText\" === a.action && t.isComposing ? t.skipNextInsert = !0 : t.skipNextInsert = !1, \n                            a.action) {\n                              case \"insertText\":\n                              case \"insertReplacementText\":\n                                a.data.forEach((function(e, n) {\n                                    var a = new i.Event(\"keypress\");\n                                    a.key = e, t.ignorable = !1, y.keypressEvent.call(o, a);\n                                })), setTimeout((function() {\n                                    t.$el.trigger(\"keyup\");\n                                }), 0);\n                                break;\n\n                              case \"deleteContentBackward\":\n                                var h = new i.Event(\"keydown\");\n                                h.key = s.keys.Backspace, y.keyEvent.call(o, h);\n                                break;\n\n                              default:\n                                (0, l.applyInputValue)(o, u), c.caret.call(t, o, d.begin, d.end, !0);\n                            }\n                            e.preventDefault();\n                        }\n                    },\n                    setValueEvent: function(e) {\n                        var t = this.inputmask, n = t.dependencyLib, i = this, a = e && e.detail ? e.detail[0] : arguments[1];\n                        void 0 === a && (a = i.inputmask._valueGet(!0)), (0, l.applyInputValue)(i, a, new n.Event(\"input\")), \n                        (e.detail && void 0 !== e.detail[1] || void 0 !== arguments[2]) && c.caret.call(t, i, e.detail ? e.detail[1] : arguments[2]);\n                    },\n                    focusEvent: function(e) {\n                        var t = this.inputmask, n = t.opts, i = t && t._valueGet();\n                        n.showMaskOnFocus && i !== c.getBuffer.call(t).join(\"\") && (0, l.writeBuffer)(this, c.getBuffer.call(t), c.seekNext.call(t, c.getLastValidPosition.call(t))), \n                        !0 !== n.positionCaretOnTab || !1 !== t.mouseEnter || u.isComplete.call(t, c.getBuffer.call(t)) && -1 !== c.getLastValidPosition.call(t) || y.clickEvent.apply(this, [ e, !0 ]), \n                        t.undoValue = t && t._valueGet(!0);\n                    },\n                    invalidEvent: function(e) {\n                        this.inputmask.validationEvent = !0;\n                    },\n                    mouseleaveEvent: function() {\n                        var e = this.inputmask, t = e.opts, n = this;\n                        e.mouseEnter = !1, t.clearMaskOnLostFocus && (n.inputmask.shadowRoot || n.ownerDocument).activeElement !== n && (0, \n                        l.HandleNativePlaceholder)(n, e.originalPlaceholder);\n                    },\n                    clickEvent: function(e, t) {\n                        var n = this.inputmask;\n                        n.clicked++;\n                        var i = this;\n                        if ((i.inputmask.shadowRoot || i.ownerDocument).activeElement === i) {\n                            var a = c.determineNewCaretPosition.call(n, c.caret.call(n, i), t);\n                            void 0 !== a && c.caret.call(n, i, a);\n                        }\n                    },\n                    cutEvent: function(e) {\n                        var t = this.inputmask, n = t.maskset, i = this, a = c.caret.call(t, i), r = t.isRTL ? c.getBuffer.call(t).slice(a.end, a.begin) : c.getBuffer.call(t).slice(a.begin, a.end), f = t.isRTL ? r.reverse().join(\"\") : r.join(\"\");\n                        o.default.navigator && o.default.navigator.clipboard ? o.default.navigator.clipboard.writeText(f) : o.default.clipboardData && o.default.clipboardData.getData && o.default.clipboardData.setData(\"Text\", f), \n                        u.handleRemove.call(t, i, s.keys.Delete, a), (0, l.writeBuffer)(i, c.getBuffer.call(t), n.p, e, t.undoValue !== t._valueGet(!0));\n                    },\n                    blurEvent: function(e) {\n                        var t = this.inputmask, n = t.opts, i = t.dependencyLib;\n                        t.clicked = 0;\n                        var a = i(this), r = this;\n                        if (r.inputmask) {\n                            (0, l.HandleNativePlaceholder)(r, t.originalPlaceholder);\n                            var o = r.inputmask._valueGet(), s = c.getBuffer.call(t).slice();\n                            \"\" !== o && (n.clearMaskOnLostFocus && (-1 === c.getLastValidPosition.call(t) && o === c.getBufferTemplate.call(t).join(\"\") ? s = [] : l.clearOptionalTail.call(t, s)), \n                            !1 === u.isComplete.call(t, s) && (setTimeout((function() {\n                                a.trigger(\"incomplete\");\n                            }), 0), n.clearIncomplete && (c.resetMaskSet.call(t, !1), s = n.clearMaskOnLostFocus ? [] : c.getBufferTemplate.call(t).slice())), \n                            (0, l.writeBuffer)(r, s, void 0, e)), o = t._valueGet(!0), t.undoValue !== o && (\"\" != o || t.undoValue != c.getBufferTemplate.call(t).join(\"\") || t.undoValue == c.getBufferTemplate.call(t).join(\"\") && t.maskset.validPositions.length > 0) && (t.undoValue = o, \n                            a.trigger(\"change\"));\n                        }\n                    },\n                    mouseenterEvent: function() {\n                        var e = this.inputmask, t = e.opts.showMaskOnHover, n = this;\n                        if (e.mouseEnter = !0, (n.inputmask.shadowRoot || n.ownerDocument).activeElement !== n) {\n                            var i = (e.isRTL ? c.getBufferTemplate.call(e).slice().reverse() : c.getBufferTemplate.call(e)).join(\"\");\n                            t && (0, l.HandleNativePlaceholder)(n, i);\n                        }\n                    },\n                    submitEvent: function() {\n                        var e = this.inputmask, t = e.opts;\n                        e.undoValue !== e._valueGet(!0) && e.$el.trigger(\"change\"), -1 === c.getLastValidPosition.call(e) && e._valueGet && e._valueGet() === c.getBufferTemplate.call(e).join(\"\") && e._valueSet(\"\"), \n                        t.clearIncomplete && !1 === u.isComplete.call(e, c.getBuffer.call(e)) && e._valueSet(\"\"), \n                        t.removeMaskOnSubmit && (e._valueSet(e.unmaskedvalue(), !0), setTimeout((function() {\n                            (0, l.writeBuffer)(e.el, c.getBuffer.call(e));\n                        }), 0));\n                    },\n                    resetEvent: function() {\n                        var e = this.inputmask;\n                        e.refreshValue = !0, setTimeout((function() {\n                            (0, l.applyInputValue)(e.el, e._valueGet(!0));\n                        }), 0);\n                    }\n                };\n            },\n            9716: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.EventRuler = void 0;\n                var i, a = n(7760), r = (i = n(2394)) && i.__esModule ? i : {\n                    default: i\n                }, o = n(2839), l = n(8711);\n                t.EventRuler = {\n                    on: function(e, t, n) {\n                        var i = e.inputmask.dependencyLib, s = function(t) {\n                            t.originalEvent && (t = t.originalEvent || t, arguments[0] = t);\n                            var s, c = this, u = c.inputmask, f = u ? u.opts : void 0;\n                            if (void 0 === u && \"FORM\" !== this.nodeName) {\n                                var p = i.data(c, \"_inputmask_opts\");\n                                i(c).off(), p && new r.default(p).mask(c);\n                            } else {\n                                if ([ \"submit\", \"reset\", \"setvalue\" ].includes(t.type) || \"FORM\" === this.nodeName || !(c.disabled || c.readOnly && !(\"keydown\" === t.type && t.ctrlKey && t.key === o.keys.c || !1 === f.tabThrough && t.key === o.keys.Tab))) {\n                                    switch (t.type) {\n                                      case \"input\":\n                                        if (!0 === u.skipInputEvent) return u.skipInputEvent = !1, t.preventDefault();\n                                        break;\n\n                                      case \"click\":\n                                      case \"focus\":\n                                        return u.validationEvent ? (u.validationEvent = !1, e.blur(), (0, a.HandleNativePlaceholder)(e, (u.isRTL ? l.getBufferTemplate.call(u).slice().reverse() : l.getBufferTemplate.call(u)).join(\"\")), \n                                        setTimeout((function() {\n                                            e.focus();\n                                        }), f.validationEventTimeOut), !1) : (s = arguments, void setTimeout((function() {\n                                            e.inputmask && n.apply(c, s);\n                                        }), 0));\n                                    }\n                                    var d = n.apply(c, arguments);\n                                    return !1 === d && (t.preventDefault(), t.stopPropagation()), d;\n                                }\n                                t.preventDefault();\n                            }\n                        };\n                        [ \"submit\", \"reset\" ].includes(t) ? (s = s.bind(e), null !== e.form && i(e.form).on(t, s)) : i(e).on(t, s), \n                        e.inputmask.events[t] = e.inputmask.events[t] || [], e.inputmask.events[t].push(s);\n                    },\n                    off: function(e, t) {\n                        if (e.inputmask && e.inputmask.events) {\n                            var n = e.inputmask.dependencyLib, i = e.inputmask.events;\n                            for (var a in t && ((i = [])[t] = e.inputmask.events[t]), i) {\n                                for (var r = i[a]; r.length > 0; ) {\n                                    var o = r.pop();\n                                    [ \"submit\", \"reset\" ].includes(a) ? null !== e.form && n(e.form).off(a, o) : n(e).off(a, o);\n                                }\n                                delete e.inputmask.events[a];\n                            }\n                        }\n                    }\n                };\n            },\n            219: function(e, t, n) {\n                var i = p(n(7184)), a = p(n(2394)), r = n(2839), o = n(8711), l = n(4713);\n                function s(e, t) {\n                    return function(e) {\n                        if (Array.isArray(e)) return e;\n                    }(e) || function(e, t) {\n                        var n = null == e ? null : \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n                        if (null != n) {\n                            var i, a, r, o, l = [], s = !0, c = !1;\n                            try {\n                                if (r = (n = n.call(e)).next, 0 === t) {\n                                    if (Object(n) !== n) return;\n                                    s = !1;\n                                } else for (;!(s = (i = r.call(n)).done) && (l.push(i.value), l.length !== t); s = !0) ;\n                            } catch (e) {\n                                c = !0, a = e;\n                            } finally {\n                                try {\n                                    if (!s && null != n.return && (o = n.return(), Object(o) !== o)) return;\n                                } finally {\n                                    if (c) throw a;\n                                }\n                            }\n                            return l;\n                        }\n                    }(e, t) || function(e, t) {\n                        if (!e) return;\n                        if (\"string\" == typeof e) return c(e, t);\n                        var n = Object.prototype.toString.call(e).slice(8, -1);\n                        \"Object\" === n && e.constructor && (n = e.constructor.name);\n                        if (\"Map\" === n || \"Set\" === n) return Array.from(e);\n                        if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return c(e, t);\n                    }(e, t) || function() {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                    }();\n                }\n                function c(e, t) {\n                    (null == t || t > e.length) && (t = e.length);\n                    for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n                    return i;\n                }\n                function u(e) {\n                    return u = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    }, u(e);\n                }\n                function f(e, t) {\n                    for (var n = 0; n < t.length; n++) {\n                        var i = t[n];\n                        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), \n                        Object.defineProperty(e, (a = i.key, r = void 0, r = function(e, t) {\n                            if (\"object\" !== u(e) || null === e) return e;\n                            var n = e[Symbol.toPrimitive];\n                            if (void 0 !== n) {\n                                var i = n.call(e, t || \"default\");\n                                if (\"object\" !== u(i)) return i;\n                                throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                            }\n                            return (\"string\" === t ? String : Number)(e);\n                        }(a, \"string\"), \"symbol\" === u(r) ? r : String(r)), i);\n                    }\n                    var a, r;\n                }\n                function p(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                n(1313);\n                var d = a.default.dependencyLib, h = function() {\n                    function e(t, n, i, a) {\n                        !function(e, t) {\n                            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n                        }(this, e), this.mask = t, this.format = n, this.opts = i, this.inputmask = a, this._date = new Date(1, 0, 1), \n                        this.initDateObject(t, this.opts, this.inputmask);\n                    }\n                    var t, n, i;\n                    return t = e, (n = [ {\n                        key: \"date\",\n                        get: function() {\n                            return void 0 === this._date && (this._date = new Date(1, 0, 1), this.initDateObject(void 0, this.opts, this.inputmask)), \n                            this._date;\n                        }\n                    }, {\n                        key: \"initDateObject\",\n                        value: function(e, t, n) {\n                            var i;\n                            for (P(t).lastIndex = 0; i = P(t).exec(this.format); ) {\n                                var a = /\\d+$/.exec(i[0]), r = a ? i[0][0] + \"x\" : i[0], o = void 0;\n                                if (void 0 !== e) {\n                                    if (a) {\n                                        var s = P(t).lastIndex, c = j.call(n, i.index, t, n && n.maskset);\n                                        P(t).lastIndex = s, o = e.slice(0, e.indexOf(c.nextMatch[0]));\n                                    } else {\n                                        for (var u = i[0][0], f = i.index; n && (t.placeholder[l.getTest.call(n, f).match.placeholder] || l.getTest.call(n, f).match.placeholder) === u; ) f++;\n                                        var p = f - i.index;\n                                        o = e.slice(0, p || y[r] && y[r][4] || r.length);\n                                    }\n                                    e = e.slice(o.length);\n                                }\n                                Object.prototype.hasOwnProperty.call(y, r) && this.setValue(this, o, r, y[r][2], y[r][1]);\n                            }\n                        }\n                    }, {\n                        key: \"setValue\",\n                        value: function(e, t, n, i, a) {\n                            if (void 0 !== t) switch (i) {\n                              case \"ampm\":\n                                e[i] = t, e[\"raw\" + i] = t.replace(/\\s/g, \"_\");\n                                break;\n\n                              case \"month\":\n                                if (\"mmm\" === n || \"mmmm\" === n) {\n                                    e[i] = _(\"mmm\" === n ? m.monthNames.slice(0, 12).findIndex((function(e) {\n                                        return t.toLowerCase() === e.toLowerCase();\n                                    })) + 1 : m.monthNames.slice(12, 24).findIndex((function(e) {\n                                        return t.toLowerCase() === e.toLowerCase();\n                                    })) + 1, 2), e[i] = \"00\" === e[i] ? \"\" : e[i].toString(), e[\"raw\" + i] = e[i];\n                                    break;\n                                }\n\n                              default:\n                                e[i] = t.replace(/[^0-9]/g, \"0\"), e[\"raw\" + i] = t.replace(/\\s/g, \"_\");\n                            }\n                            if (void 0 !== a) {\n                                var r = e[i];\n                                (\"day\" === i && 29 === parseInt(r) || \"month\" === i && 2 === parseInt(r)) && (29 !== parseInt(e.day) || 2 !== parseInt(e.month) || \"\" !== e.year && void 0 !== e.year || e._date.setFullYear(2012, 1, 29)), \n                                \"day\" === i && (g = !0, 0 === parseInt(r) && (r = 1)), \"month\" === i && (g = !0), \n                                \"year\" === i && (g = !0, r.length < y[n][4] && (r = _(r, y[n][4], !0))), (\"\" !== r && !isNaN(r) || \"ampm\" === i) && a.call(e._date, r);\n                            }\n                        }\n                    }, {\n                        key: \"reset\",\n                        value: function() {\n                            this._date = new Date(1, 0, 1);\n                        }\n                    }, {\n                        key: \"reInit\",\n                        value: function() {\n                            this._date = void 0, this.date;\n                        }\n                    } ]) && f(t.prototype, n), i && f(t, i), Object.defineProperty(t, \"prototype\", {\n                        writable: !1\n                    }), e;\n                }(), v = (new Date).getFullYear(), m = a.default.prototype.i18n, g = !1, y = {\n                    d: [ \"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate ],\n                    dd: [ \"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function() {\n                        return _(Date.prototype.getDate.call(this), 2);\n                    } ],\n                    ddd: [ \"\" ],\n                    dddd: [ \"\" ],\n                    m: [ \"[1-9]|1[012]\", function(e) {\n                        var t = e ? parseInt(e) : 0;\n                        return t > 0 && t--, Date.prototype.setMonth.call(this, t);\n                    }, \"month\", function() {\n                        return Date.prototype.getMonth.call(this) + 1;\n                    } ],\n                    mm: [ \"0[1-9]|1[012]\", function(e) {\n                        var t = e ? parseInt(e) : 0;\n                        return t > 0 && t--, Date.prototype.setMonth.call(this, t);\n                    }, \"month\", function() {\n                        return _(Date.prototype.getMonth.call(this) + 1, 2);\n                    } ],\n                    mmm: [ m.monthNames.slice(0, 12).join(\"|\"), function(e) {\n                        var t = m.monthNames.slice(0, 12).findIndex((function(t) {\n                            return e.toLowerCase() === t.toLowerCase();\n                        }));\n                        return -1 !== t && Date.prototype.setMonth.call(this, t);\n                    }, \"month\", function() {\n                        return m.monthNames.slice(0, 12)[Date.prototype.getMonth.call(this)];\n                    } ],\n                    mmmm: [ m.monthNames.slice(12, 24).join(\"|\"), function(e) {\n                        var t = m.monthNames.slice(12, 24).findIndex((function(t) {\n                            return e.toLowerCase() === t.toLowerCase();\n                        }));\n                        return -1 !== t && Date.prototype.setMonth.call(this, t);\n                    }, \"month\", function() {\n                        return m.monthNames.slice(12, 24)[Date.prototype.getMonth.call(this)];\n                    } ],\n                    yy: [ \"[0-9]{2}\", function(e) {\n                        var t = (new Date).getFullYear().toString().slice(0, 2);\n                        Date.prototype.setFullYear.call(this, \"\".concat(t).concat(e));\n                    }, \"year\", function() {\n                        return _(Date.prototype.getFullYear.call(this), 2);\n                    }, 2 ],\n                    yyyy: [ \"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function() {\n                        return _(Date.prototype.getFullYear.call(this), 4);\n                    }, 4 ],\n                    h: [ \"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\n                    hh: [ \"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function() {\n                        return _(Date.prototype.getHours.call(this), 2);\n                    } ],\n                    hx: [ function(e) {\n                        return \"[0-9]{\".concat(e, \"}\");\n                    }, Date.prototype.setHours, \"hours\", function(e) {\n                        return Date.prototype.getHours;\n                    } ],\n                    H: [ \"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\n                    HH: [ \"0[0-9]|1[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function() {\n                        return _(Date.prototype.getHours.call(this), 2);\n                    } ],\n                    Hx: [ function(e) {\n                        return \"[0-9]{\".concat(e, \"}\");\n                    }, Date.prototype.setHours, \"hours\", function(e) {\n                        return function() {\n                            return _(Date.prototype.getHours.call(this), e);\n                        };\n                    } ],\n                    M: [ \"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes ],\n                    MM: [ \"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setMinutes, \"minutes\", function() {\n                        return _(Date.prototype.getMinutes.call(this), 2);\n                    } ],\n                    s: [ \"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds ],\n                    ss: [ \"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setSeconds, \"seconds\", function() {\n                        return _(Date.prototype.getSeconds.call(this), 2);\n                    } ],\n                    l: [ \"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function() {\n                        return _(Date.prototype.getMilliseconds.call(this), 3);\n                    }, 3 ],\n                    L: [ \"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function() {\n                        return _(Date.prototype.getMilliseconds.call(this), 2);\n                    }, 2 ],\n                    t: [ \"[ap]\", b, \"ampm\", x, 1 ],\n                    tt: [ \"[ap]m\", b, \"ampm\", x, 2 ],\n                    T: [ \"[AP]\", b, \"ampm\", x, 1 ],\n                    TT: [ \"[AP]M\", b, \"ampm\", x, 2 ],\n                    Z: [ \".*\", void 0, \"Z\", function() {\n                        var e = this.toString().match(/\\((.+)\\)/)[1];\n                        e.includes(\" \") && (e = (e = e.replace(\"-\", \" \").toUpperCase()).split(\" \").map((function(e) {\n                            return s(e, 1)[0];\n                        })).join(\"\"));\n                        return e;\n                    } ],\n                    o: [ \"\" ],\n                    S: [ \"\" ]\n                }, k = {\n                    isoDate: \"yyyy-mm-dd\",\n                    isoTime: \"HH:MM:ss\",\n                    isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\",\n                    isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\"\n                };\n                function b(e) {\n                    var t = this.getHours();\n                    e.toLowerCase().includes(\"p\") ? this.setHours(t + 12) : e.toLowerCase().includes(\"a\") && t >= 12 && this.setHours(t - 12);\n                }\n                function x() {\n                    var e = this.getHours();\n                    return (e = e || 12) >= 12 ? \"PM\" : \"AM\";\n                }\n                function w(e) {\n                    var t = /\\d+$/.exec(e[0]);\n                    if (t && void 0 !== t[0]) {\n                        var n = y[e[0][0] + \"x\"].slice(\"\");\n                        return n[0] = n[0](t[0]), n[3] = n[3](t[0]), n;\n                    }\n                    if (y[e[0]]) return y[e[0]];\n                }\n                function P(e) {\n                    if (!e.tokenizer) {\n                        var t = [], n = [];\n                        for (var i in y) if (/\\.*x$/.test(i)) {\n                            var a = i[0] + \"\\\\d+\";\n                            -1 === n.indexOf(a) && n.push(a);\n                        } else -1 === t.indexOf(i[0]) && t.push(i[0]);\n                        e.tokenizer = \"(\" + (n.length > 0 ? n.join(\"|\") + \"|\" : \"\") + t.join(\"+|\") + \")+?|.\", \n                        e.tokenizer = new RegExp(e.tokenizer, \"g\");\n                    }\n                    return e.tokenizer;\n                }\n                function S(e, t, n) {\n                    if (!g) return !0;\n                    if (void 0 === e.rawday || !isFinite(e.rawday) && new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day || \"29\" == e.day && (!isFinite(e.rawyear) || void 0 === e.rawyear || \"\" === e.rawyear) || new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day) return t;\n                    if (\"29\" == e.day) {\n                        var i = j.call(this, t.pos, n, this.maskset);\n                        if (i.targetMatch && \"yyyy\" === i.targetMatch[0] && t.pos - i.targetMatchIndex == 2) return t.remove = t.pos + 1, \n                        t;\n                    } else if (2 == e.date.getMonth() && \"30\" == e.day && void 0 !== t.c) return e.day = \"03\", \n                    e.date.setDate(3), e.date.setMonth(1), t.insert = [ {\n                        pos: t.pos,\n                        c: \"0\"\n                    }, {\n                        pos: t.pos + 1,\n                        c: t.c\n                    } ], t.caret = o.seekNext.call(this, t.pos + 1), t;\n                    return !1;\n                }\n                function O(e, t, n, a) {\n                    var r, o, l = \"\", s = 0, c = {};\n                    for (P(n).lastIndex = 0; r = P(n).exec(e); ) {\n                        if (void 0 === t) if (o = w(r)) l += \"(\" + o[0] + \")\", n.placeholder && \"\" !== n.placeholder ? (c[s] = n.placeholder[r.index % n.placeholder.length], \n                        c[n.placeholder[r.index % n.placeholder.length]] = r[0].charAt(0)) : c[s] = r[0].charAt(0); else switch (r[0]) {\n                          case \"[\":\n                            l += \"(\";\n                            break;\n\n                          case \"]\":\n                            l += \")?\";\n                            break;\n\n                          default:\n                            l += (0, i.default)(r[0]), c[s] = r[0].charAt(0);\n                        } else if (o = w(r)) if (!0 !== a && o[3]) l += o[3].call(t.date); else o[2] ? l += t[\"raw\" + o[2]] : l += r[0]; else l += r[0];\n                        s++;\n                    }\n                    return void 0 === t && (n.placeholder = c), l;\n                }\n                function _(e, t, n) {\n                    for (e = String(e), t = t || 2; e.length < t; ) e = n ? e + \"0\" : \"0\" + e;\n                    return e;\n                }\n                function M(e, t, n) {\n                    return \"string\" == typeof e ? new h(e, t, n, this) : e && \"object\" === u(e) && Object.prototype.hasOwnProperty.call(e, \"date\") ? e : void 0;\n                }\n                function E(e, t) {\n                    return O(t.inputFormat, {\n                        date: e\n                    }, t);\n                }\n                function j(e, t, n) {\n                    var i, a, r = this, o = n && n.tests[e] ? t.placeholder[n.tests[e][0].match.placeholder] || n.tests[e][0].match.placeholder : \"\", s = 0, c = 0;\n                    for (P(t).lastIndex = 0; a = P(t).exec(t.inputFormat); ) {\n                        var u = /\\d+$/.exec(a[0]);\n                        if (u) c = parseInt(u[0]); else {\n                            for (var f = a[0][0], p = s; r && (t.placeholder[l.getTest.call(r, p).match.placeholder] || l.getTest.call(r, p).match.placeholder) === f; ) p++;\n                            0 === (c = p - s) && (c = a[0].length);\n                        }\n                        if (s += c, -1 != a[0].indexOf(o) || s >= e + 1) {\n                            i = a, a = P(t).exec(t.inputFormat);\n                            break;\n                        }\n                    }\n                    return {\n                        targetMatchIndex: s - c,\n                        nextMatch: a,\n                        targetMatch: i\n                    };\n                }\n                a.default.extendAliases({\n                    datetime: {\n                        mask: function(e) {\n                            return e.numericInput = !1, y.S = m.ordinalSuffix.join(\"|\"), e.inputFormat = k[e.inputFormat] || e.inputFormat, \n                            e.displayFormat = k[e.displayFormat] || e.displayFormat || e.inputFormat, e.outputFormat = k[e.outputFormat] || e.outputFormat || e.inputFormat, \n                            e.regex = O(e.inputFormat, void 0, e), e.min = M(e.min, e.inputFormat, e), e.max = M(e.max, e.inputFormat, e), \n                            null;\n                        },\n                        placeholder: \"\",\n                        inputFormat: \"isoDateTime\",\n                        displayFormat: null,\n                        outputFormat: null,\n                        min: null,\n                        max: null,\n                        skipOptionalPartCharacter: \"\",\n                        preValidation: function(e, t, n, i, a, r, o, l) {\n                            if (l) return !0;\n                            if (isNaN(n) && e[t] !== n) {\n                                var s = j.call(this, t, a, r);\n                                if (s.nextMatch && s.nextMatch[0] === n && s.targetMatch[0].length > 1) {\n                                    var c = w(s.targetMatch)[0];\n                                    if (new RegExp(c).test(\"0\" + e[t - 1])) return e[t] = e[t - 1], e[t - 1] = \"0\", \n                                    {\n                                        fuzzy: !0,\n                                        buffer: e,\n                                        refreshFromBuffer: {\n                                            start: t - 1,\n                                            end: t + 1\n                                        },\n                                        pos: t + 1\n                                    };\n                                }\n                            }\n                            return !0;\n                        },\n                        postValidation: function(e, t, n, i, a, r, o, s) {\n                            var c, u, f = this;\n                            if (o) return !0;\n                            if (!1 === i && (((c = j.call(f, t + 1, a, r)).targetMatch && c.targetMatchIndex === t && c.targetMatch[0].length > 1 && void 0 !== y[c.targetMatch[0]] || (c = j.call(f, t + 2, a, r)).targetMatch && c.targetMatchIndex === t + 1 && c.targetMatch[0].length > 1 && void 0 !== y[c.targetMatch[0]]) && (u = w(c.targetMatch)[0]), \n                            void 0 !== u && (void 0 !== r.validPositions[t + 1] && new RegExp(u).test(n + \"0\") ? (e[t] = n, \n                            e[t + 1] = \"0\", i = {\n                                pos: t + 2,\n                                caret: t\n                            }) : new RegExp(u).test(\"0\" + n) && (e[t] = \"0\", e[t + 1] = n, i = {\n                                pos: t + 2\n                            })), !1 === i)) return i;\n                            if (i.fuzzy && (e = i.buffer, t = i.pos), (c = j.call(f, t, a, r)).targetMatch && c.targetMatch[0] && void 0 !== y[c.targetMatch[0]]) {\n                                var p = w(c.targetMatch);\n                                u = p[0];\n                                var d = e.slice(c.targetMatchIndex, c.targetMatchIndex + c.targetMatch[0].length);\n                                if (!1 === new RegExp(u).test(d.join(\"\")) && 2 === c.targetMatch[0].length && r.validPositions[c.targetMatchIndex] && r.validPositions[c.targetMatchIndex + 1] && (r.validPositions[c.targetMatchIndex + 1].input = \"0\"), \n                                \"year\" == p[2]) for (var h = l.getMaskTemplate.call(f, !1, 1, void 0, !0), m = t + 1; m < e.length; m++) e[m] = h[m], \n                                r.validPositions.splice(t + 1, 1);\n                            }\n                            var g = i, k = M.call(f, e.join(\"\"), a.inputFormat, a);\n                            return g && !isNaN(k.date.getTime()) && (a.prefillYear && (g = function(e, t, n) {\n                                if (e.year !== e.rawyear) {\n                                    var i = v.toString(), a = e.rawyear.replace(/[^0-9]/g, \"\"), r = i.slice(0, a.length), o = i.slice(a.length);\n                                    if (2 === a.length && a === r) {\n                                        var l = new Date(v, e.month - 1, e.day);\n                                        e.day == l.getDate() && (!n.max || n.max.date.getTime() >= l.getTime()) && (e.date.setFullYear(v), \n                                        e.year = i, t.insert = [ {\n                                            pos: t.pos + 1,\n                                            c: o[0]\n                                        }, {\n                                            pos: t.pos + 2,\n                                            c: o[1]\n                                        } ]);\n                                    }\n                                }\n                                return t;\n                            }(k, g, a)), g = function(e, t, n, i, a) {\n                                if (!t) return t;\n                                if (t && n.min && !isNaN(n.min.date.getTime())) {\n                                    var r;\n                                    for (e.reset(), P(n).lastIndex = 0; r = P(n).exec(n.inputFormat); ) {\n                                        var o;\n                                        if ((o = w(r)) && o[3]) {\n                                            for (var l = o[1], s = e[o[2]], c = n.min[o[2]], u = n.max ? n.max[o[2]] : c + 1, f = [], p = !1, d = 0; d < c.length; d++) void 0 !== i.validPositions[d + r.index] || p ? (f[d] = s[d], \n                                            p = p || s[d] > c[d]) : (d + r.index == 0 && s[d] < c[d] ? (f[d] = s[d], p = !0) : f[d] = c[d], \n                                            \"year\" === o[2] && s.length - 1 == d && c != u && (f = (parseInt(f.join(\"\")) + 1).toString().split(\"\")), \n                                            \"ampm\" === o[2] && c != u && n.min.date.getTime() > e.date.getTime() && (f[d] = u[d]));\n                                            l.call(e._date, f.join(\"\"));\n                                        }\n                                    }\n                                    t = n.min.date.getTime() <= e.date.getTime(), e.reInit();\n                                }\n                                return t && n.max && (isNaN(n.max.date.getTime()) || (t = n.max.date.getTime() >= e.date.getTime())), \n                                t;\n                            }(k, g = S.call(f, k, g, a), a, r)), void 0 !== t && g && i.pos !== t ? {\n                                buffer: O(a.inputFormat, k, a).split(\"\"),\n                                refreshFromBuffer: {\n                                    start: t,\n                                    end: i.pos\n                                },\n                                pos: i.caret || i.pos\n                            } : g;\n                        },\n                        onKeyDown: function(e, t, n, i) {\n                            e.ctrlKey && e.key === r.keys.ArrowRight && (this.inputmask._valueSet(E(new Date, i)), \n                            d(this).trigger(\"setvalue\"));\n                        },\n                        onUnMask: function(e, t, n) {\n                            return t ? O(n.outputFormat, M.call(this, e, n.inputFormat, n), n, !0) : t;\n                        },\n                        casing: function(e, t, n, i) {\n                            if (0 == t.nativeDef.indexOf(\"[ap]\")) return e.toLowerCase();\n                            if (0 == t.nativeDef.indexOf(\"[AP]\")) return e.toUpperCase();\n                            var a = l.getTest.call(this, [ n - 1 ]);\n                            return 0 == a.match.def.indexOf(\"[AP]\") || 0 === n || a && a.input === String.fromCharCode(r.keyCode.Space) || a && a.match.def === String.fromCharCode(r.keyCode.Space) ? e.toUpperCase() : e.toLowerCase();\n                        },\n                        onBeforeMask: function(e, t) {\n                            return \"[object Date]\" === Object.prototype.toString.call(e) && (e = E(e, t)), e;\n                        },\n                        insertMode: !1,\n                        insertModeVisual: !1,\n                        shiftPositions: !1,\n                        keepStatic: !1,\n                        inputmode: \"numeric\",\n                        prefillYear: !0\n                    }\n                });\n            },\n            1313: function(e, t, n) {\n                var i, a = (i = n(2394)) && i.__esModule ? i : {\n                    default: i\n                };\n                a.default.dependencyLib.extend(!0, a.default.prototype.i18n, {\n                    dayNames: [ \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\" ],\n                    monthNames: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ],\n                    ordinalSuffix: [ \"st\", \"nd\", \"rd\", \"th\" ]\n                });\n            },\n            3851: function(e, t, n) {\n                var i, a = (i = n(2394)) && i.__esModule ? i : {\n                    default: i\n                }, r = n(8711), o = n(4713);\n                function l(e) {\n                    return function(e) {\n                        if (Array.isArray(e)) return s(e);\n                    }(e) || function(e) {\n                        if (\"undefined\" != typeof Symbol && null != e[Symbol.iterator] || null != e[\"@@iterator\"]) return Array.from(e);\n                    }(e) || function(e, t) {\n                        if (!e) return;\n                        if (\"string\" == typeof e) return s(e, t);\n                        var n = Object.prototype.toString.call(e).slice(8, -1);\n                        \"Object\" === n && e.constructor && (n = e.constructor.name);\n                        if (\"Map\" === n || \"Set\" === n) return Array.from(e);\n                        if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return s(e, t);\n                    }(e) || function() {\n                        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                    }();\n                }\n                function s(e, t) {\n                    (null == t || t > e.length) && (t = e.length);\n                    for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n                    return i;\n                }\n                a.default.extendDefinitions({\n                    A: {\n                        validator: \"[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\n                        casing: \"upper\"\n                    },\n                    \"&\": {\n                        validator: \"[0-9A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\n                        casing: \"upper\"\n                    },\n                    \"#\": {\n                        validator: \"[0-9A-Fa-f]\",\n                        casing: \"upper\"\n                    }\n                });\n                var c = /25[0-5]|2[0-4][0-9]|[01][0-9][0-9]/;\n                function u(e, t, n, i, a) {\n                    if (n - 1 > -1 && \".\" !== t.buffer[n - 1] ? (e = t.buffer[n - 1] + e, e = n - 2 > -1 && \".\" !== t.buffer[n - 2] ? t.buffer[n - 2] + e : \"0\" + e) : e = \"00\" + e, \n                    a.greedy && parseInt(e) > 255 && c.test(\"00\" + e.charAt(2))) {\n                        var r = [].concat(l(t.buffer.slice(0, n)), [ \".\", e.charAt(2) ]);\n                        if (r.join(\"\").match(/\\./g).length < 4) return {\n                            refreshFromBuffer: !0,\n                            buffer: r,\n                            caret: n + 2\n                        };\n                    }\n                    return c.test(e);\n                }\n                a.default.extendAliases({\n                    cssunit: {\n                        regex: \"[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\"\n                    },\n                    url: {\n                        regex: \"(https?|ftp)://.*\",\n                        autoUnmask: !1,\n                        keepStatic: !1,\n                        tabThrough: !0\n                    },\n                    ip: {\n                        mask: \"i{1,3}.j{1,3}.k{1,3}.l{1,3}\",\n                        definitions: {\n                            i: {\n                                validator: u\n                            },\n                            j: {\n                                validator: u\n                            },\n                            k: {\n                                validator: u\n                            },\n                            l: {\n                                validator: u\n                            }\n                        },\n                        onUnMask: function(e, t, n) {\n                            return e;\n                        },\n                        inputmode: \"decimal\",\n                        substitutes: {\n                            \",\": \".\"\n                        }\n                    },\n                    email: {\n                        mask: function(e) {\n                            var t = e.separator, n = e.quantifier, i = \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\", a = i;\n                            if (t) for (var r = 0; r < n; r++) a += \"[\".concat(t).concat(i, \"]\");\n                            return a;\n                        },\n                        greedy: !1,\n                        casing: \"lower\",\n                        separator: null,\n                        quantifier: 5,\n                        skipOptionalPartCharacter: \"\",\n                        onBeforePaste: function(e, t) {\n                            return (e = e.toLowerCase()).replace(\"mailto:\", \"\");\n                        },\n                        definitions: {\n                            \"*\": {\n                                validator: \"[0-9\\uff11-\\uff19A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5!#$%&'*+/=?^_`{|}~-]\"\n                            },\n                            \"-\": {\n                                validator: \"[0-9A-Za-z-]\"\n                            }\n                        },\n                        onUnMask: function(e, t, n) {\n                            return e;\n                        },\n                        inputmode: \"email\"\n                    },\n                    mac: {\n                        mask: \"##:##:##:##:##:##\"\n                    },\n                    vin: {\n                        mask: \"V{13}9{4}\",\n                        definitions: {\n                            V: {\n                                validator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\n                                casing: \"upper\"\n                            }\n                        },\n                        clearIncomplete: !0,\n                        autoUnmask: !0\n                    },\n                    ssn: {\n                        mask: \"999-99-9999\",\n                        postValidation: function(e, t, n, i, a, l, s) {\n                            var c = o.getMaskTemplate.call(this, !0, r.getLastValidPosition.call(this), !0, !0);\n                            return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(c.join(\"\"));\n                        }\n                    }\n                });\n            },\n            207: function(e, t, n) {\n                var i = l(n(7184)), a = l(n(2394)), r = n(2839), o = n(8711);\n                function l(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var s = a.default.dependencyLib;\n                function c(e, t) {\n                    for (var n = \"\", i = 0; i < e.length; i++) a.default.prototype.definitions[e.charAt(i)] || t.definitions[e.charAt(i)] || t.optionalmarker[0] === e.charAt(i) || t.optionalmarker[1] === e.charAt(i) || t.quantifiermarker[0] === e.charAt(i) || t.quantifiermarker[1] === e.charAt(i) || t.groupmarker[0] === e.charAt(i) || t.groupmarker[1] === e.charAt(i) || t.alternatormarker === e.charAt(i) ? n += \"\\\\\" + e.charAt(i) : n += e.charAt(i);\n                    return n;\n                }\n                function u(e, t, n, i) {\n                    if (e.length > 0 && t > 0 && (!n.digitsOptional || i)) {\n                        var a = e.indexOf(n.radixPoint), r = !1;\n                        n.negationSymbol.back === e[e.length - 1] && (r = !0, e.length--), -1 === a && (e.push(n.radixPoint), \n                        a = e.length - 1);\n                        for (var o = 1; o <= t; o++) isFinite(e[a + o]) || (e[a + o] = \"0\");\n                    }\n                    return r && e.push(n.negationSymbol.back), e;\n                }\n                function f(e, t) {\n                    var n = 0;\n                    for (var i in \"+\" === e && (n = o.seekNext.call(this, t.validPositions.length - 1)), \n                    t.tests) if ((i = parseInt(i)) >= n) for (var a = 0, r = t.tests[i].length; a < r; a++) if ((void 0 === t.validPositions[i] || \"-\" === e) && t.tests[i][a].match.def === e) return i + (void 0 !== t.validPositions[i] && \"-\" !== e ? 1 : 0);\n                    return n;\n                }\n                function p(e, t) {\n                    for (var n = -1, i = 0, a = t.validPositions.length; i < a; i++) {\n                        var r = t.validPositions[i];\n                        if (r && r.match.def === e) {\n                            n = i;\n                            break;\n                        }\n                    }\n                    return n;\n                }\n                function d(e, t, n, i, a) {\n                    var r = t.buffer ? t.buffer.indexOf(a.radixPoint) : -1, o = (-1 !== r || i && a.jitMasking) && new RegExp(a.definitions[9].validator).test(e);\n                    return !i && a._radixDance && -1 !== r && o && null == t.validPositions[r] ? {\n                        insert: {\n                            pos: r === n ? r + 1 : r,\n                            c: a.radixPoint\n                        },\n                        pos: n\n                    } : o;\n                }\n                a.default.extendAliases({\n                    numeric: {\n                        mask: function(e) {\n                            e.repeat = 0, e.groupSeparator === e.radixPoint && e.digits && \"0\" !== e.digits && (\".\" === e.radixPoint ? e.groupSeparator = \",\" : \",\" === e.radixPoint ? e.groupSeparator = \".\" : e.groupSeparator = \"\"), \n                            \" \" === e.groupSeparator && (e.skipOptionalPartCharacter = void 0), e.placeholder.length > 1 && (e.placeholder = e.placeholder.charAt(0)), \n                            \"radixFocus\" === e.positionCaretOnClick && \"\" === e.placeholder && (e.positionCaretOnClick = \"lvp\");\n                            var t = \"0\", n = e.radixPoint;\n                            !0 === e.numericInput && void 0 === e.__financeInput ? (t = \"1\", e.positionCaretOnClick = \"radixFocus\" === e.positionCaretOnClick ? \"lvp\" : e.positionCaretOnClick, \n                            e.digitsOptional = !1, isNaN(e.digits) && (e.digits = 2), e._radixDance = !1, n = \",\" === e.radixPoint ? \"?\" : \"!\", \n                            \"\" !== e.radixPoint && void 0 === e.definitions[n] && (e.definitions[n] = {}, e.definitions[n].validator = \"[\" + e.radixPoint + \"]\", \n                            e.definitions[n].placeholder = e.radixPoint, e.definitions[n].static = !0, e.definitions[n].generated = !0)) : (e.__financeInput = !1, \n                            e.numericInput = !0);\n                            var a, r = \"[+]\";\n                            if (r += c(e.prefix, e), \"\" !== e.groupSeparator ? (void 0 === e.definitions[e.groupSeparator] && (e.definitions[e.groupSeparator] = {}, \n                            e.definitions[e.groupSeparator].validator = \"[\" + e.groupSeparator + \"]\", e.definitions[e.groupSeparator].placeholder = e.groupSeparator, \n                            e.definitions[e.groupSeparator].static = !0, e.definitions[e.groupSeparator].generated = !0), \n                            r += e._mask(e)) : r += \"9{+}\", void 0 !== e.digits && 0 !== e.digits) {\n                                var o = e.digits.toString().split(\",\");\n                                isFinite(o[0]) && o[1] && isFinite(o[1]) ? r += n + t + \"{\" + e.digits + \"}\" : (isNaN(e.digits) || parseInt(e.digits) > 0) && (e.digitsOptional || e.jitMasking ? (a = r + n + t + \"{0,\" + e.digits + \"}\", \n                                e.keepStatic = !0) : r += n + t + \"{\" + e.digits + \"}\");\n                            } else e.inputmode = \"numeric\";\n                            return r += c(e.suffix, e), r += \"[-]\", a && (r = [ a + c(e.suffix, e) + \"[-]\", r ]), \n                            e.greedy = !1, function(e) {\n                                void 0 === e.parseMinMaxOptions && (null !== e.min && (e.min = e.min.toString().replace(new RegExp((0, \n                                i.default)(e.groupSeparator), \"g\"), \"\"), \",\" === e.radixPoint && (e.min = e.min.replace(e.radixPoint, \".\")), \n                                e.min = isFinite(e.min) ? parseFloat(e.min) : NaN, isNaN(e.min) && (e.min = Number.MIN_VALUE)), \n                                null !== e.max && (e.max = e.max.toString().replace(new RegExp((0, i.default)(e.groupSeparator), \"g\"), \"\"), \n                                \",\" === e.radixPoint && (e.max = e.max.replace(e.radixPoint, \".\")), e.max = isFinite(e.max) ? parseFloat(e.max) : NaN, \n                                isNaN(e.max) && (e.max = Number.MAX_VALUE)), e.parseMinMaxOptions = \"done\");\n                            }(e), \"\" !== e.radixPoint && e.substituteRadixPoint && (e.substitutes[\".\" == e.radixPoint ? \",\" : \".\"] = e.radixPoint), \n                            r;\n                        },\n                        _mask: function(e) {\n                            return \"(\" + e.groupSeparator + \"999){+|1}\";\n                        },\n                        digits: \"*\",\n                        digitsOptional: !0,\n                        enforceDigitsOnBlur: !1,\n                        radixPoint: \".\",\n                        positionCaretOnClick: \"radixFocus\",\n                        _radixDance: !0,\n                        groupSeparator: \"\",\n                        allowMinus: !0,\n                        negationSymbol: {\n                            front: \"-\",\n                            back: \"\"\n                        },\n                        prefix: \"\",\n                        suffix: \"\",\n                        min: null,\n                        max: null,\n                        SetMaxOnOverflow: !1,\n                        step: 1,\n                        inputType: \"text\",\n                        unmaskAsNumber: !1,\n                        roundingFN: Math.round,\n                        inputmode: \"decimal\",\n                        shortcuts: {\n                            k: \"1000\",\n                            m: \"1000000\"\n                        },\n                        placeholder: \"0\",\n                        greedy: !1,\n                        rightAlign: !0,\n                        insertMode: !0,\n                        autoUnmask: !1,\n                        skipOptionalPartCharacter: \"\",\n                        usePrototypeDefinitions: !1,\n                        stripLeadingZeroes: !0,\n                        substituteRadixPoint: !0,\n                        definitions: {\n                            0: {\n                                validator: d\n                            },\n                            1: {\n                                validator: d,\n                                definitionSymbol: \"9\"\n                            },\n                            9: {\n                                validator: \"[0-9\\uff10-\\uff19\\u0660-\\u0669\\u06f0-\\u06f9]\",\n                                definitionSymbol: \"*\"\n                            },\n                            \"+\": {\n                                validator: function(e, t, n, i, a) {\n                                    return a.allowMinus && (\"-\" === e || e === a.negationSymbol.front);\n                                }\n                            },\n                            \"-\": {\n                                validator: function(e, t, n, i, a) {\n                                    return a.allowMinus && e === a.negationSymbol.back;\n                                }\n                            }\n                        },\n                        preValidation: function(e, t, n, i, a, r, o, l) {\n                            var s = this;\n                            if (!1 !== a.__financeInput && n === a.radixPoint) return !1;\n                            var c = e.indexOf(a.radixPoint), u = t;\n                            if (t = function(e, t, n, i, a) {\n                                return a._radixDance && a.numericInput && t !== a.negationSymbol.back && e <= n && (n > 0 || t == a.radixPoint) && (void 0 === i.validPositions[e - 1] || i.validPositions[e - 1].input !== a.negationSymbol.back) && (e -= 1), \n                                e;\n                            }(t, n, c, r, a), \"-\" === n || n === a.negationSymbol.front) {\n                                if (!0 !== a.allowMinus) return !1;\n                                var d = !1, h = p(\"+\", r), v = p(\"-\", r);\n                                return -1 !== h && (d = [ h ], -1 !== v && d.push(v)), !1 !== d ? {\n                                    remove: d,\n                                    caret: u - a.negationSymbol.back.length\n                                } : {\n                                    insert: [ {\n                                        pos: f.call(s, \"+\", r),\n                                        c: a.negationSymbol.front,\n                                        fromIsValid: !0\n                                    }, {\n                                        pos: f.call(s, \"-\", r),\n                                        c: a.negationSymbol.back,\n                                        fromIsValid: void 0\n                                    } ],\n                                    caret: u + a.negationSymbol.back.length\n                                };\n                            }\n                            if (n === a.groupSeparator) return {\n                                caret: u\n                            };\n                            if (l) return !0;\n                            if (-1 !== c && !0 === a._radixDance && !1 === i && n === a.radixPoint && void 0 !== a.digits && (isNaN(a.digits) || parseInt(a.digits) > 0) && c !== t) {\n                                var m = f.call(s, a.radixPoint, r);\n                                return r.validPositions[m] && (r.validPositions[m].generatedInput = r.validPositions[m].generated || !1), \n                                {\n                                    caret: a._radixDance && t === c - 1 ? c + 1 : c\n                                };\n                            }\n                            if (!1 === a.__financeInput) if (i) {\n                                if (a.digitsOptional) return {\n                                    rewritePosition: o.end\n                                };\n                                if (!a.digitsOptional) {\n                                    if (o.begin > c && o.end <= c) return n === a.radixPoint ? {\n                                        insert: {\n                                            pos: c + 1,\n                                            c: \"0\",\n                                            fromIsValid: !0\n                                        },\n                                        rewritePosition: c\n                                    } : {\n                                        rewritePosition: c + 1\n                                    };\n                                    if (o.begin < c) return {\n                                        rewritePosition: o.begin - 1\n                                    };\n                                }\n                            } else if (!a.showMaskOnHover && !a.showMaskOnFocus && !a.digitsOptional && a.digits > 0 && \"\" === this.__valueGet.call(this.el)) return {\n                                rewritePosition: c\n                            };\n                            return {\n                                rewritePosition: t\n                            };\n                        },\n                        postValidation: function(e, t, n, i, a, r, o) {\n                            if (!1 === i) return i;\n                            if (o) return !0;\n                            if (null !== a.min || null !== a.max) {\n                                var l = a.onUnMask(e.slice().reverse().join(\"\"), void 0, s.extend({}, a, {\n                                    unmaskAsNumber: !0\n                                }));\n                                if (null !== a.min && l < a.min && (l.toString().length > a.min.toString().length || l < 0)) return !1;\n                                if (null !== a.max && l > a.max) return !!a.SetMaxOnOverflow && {\n                                    refreshFromBuffer: !0,\n                                    buffer: u(a.max.toString().replace(\".\", a.radixPoint).split(\"\"), a.digits, a).reverse()\n                                };\n                            }\n                            return i;\n                        },\n                        onUnMask: function(e, t, n) {\n                            if (\"\" === t && !0 === n.nullable) return t;\n                            var a = e.replace(n.prefix, \"\");\n                            return a = (a = a.replace(n.suffix, \"\")).replace(new RegExp((0, i.default)(n.groupSeparator), \"g\"), \"\"), \n                            \"\" !== n.placeholder.charAt(0) && (a = a.replace(new RegExp(n.placeholder.charAt(0), \"g\"), \"0\")), \n                            n.unmaskAsNumber ? (\"\" !== n.radixPoint && -1 !== a.indexOf(n.radixPoint) && (a = a.replace(i.default.call(this, n.radixPoint), \".\")), \n                            a = (a = a.replace(new RegExp(\"^\" + (0, i.default)(n.negationSymbol.front)), \"-\")).replace(new RegExp((0, \n                            i.default)(n.negationSymbol.back) + \"$\"), \"\"), Number(a)) : a;\n                        },\n                        isComplete: function(e, t) {\n                            var n = (t.numericInput ? e.slice().reverse() : e).join(\"\");\n                            return n = (n = (n = (n = (n = n.replace(new RegExp(\"^\" + (0, i.default)(t.negationSymbol.front)), \"-\")).replace(new RegExp((0, \n                            i.default)(t.negationSymbol.back) + \"$\"), \"\")).replace(t.prefix, \"\")).replace(t.suffix, \"\")).replace(new RegExp((0, \n                            i.default)(t.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\"), \",\" === t.radixPoint && (n = n.replace((0, \n                            i.default)(t.radixPoint), \".\")), isFinite(n);\n                        },\n                        onBeforeMask: function(e, t) {\n                            var n;\n                            e = null !== (n = e) && void 0 !== n ? n : \"\";\n                            var a = t.radixPoint || \",\";\n                            isFinite(t.digits) && (t.digits = parseInt(t.digits)), \"number\" != typeof e && \"number\" !== t.inputType || \"\" === a || (e = e.toString().replace(\".\", a));\n                            var r = \"-\" === e.charAt(0) || e.charAt(0) === t.negationSymbol.front, o = e.split(a), l = o[0].replace(/[^\\-0-9]/g, \"\"), s = o.length > 1 ? o[1].replace(/[^0-9]/g, \"\") : \"\", c = o.length > 1;\n                            e = l + (\"\" !== s ? a + s : s);\n                            var f = 0;\n                            if (\"\" !== a && (f = t.digitsOptional ? t.digits < s.length ? t.digits : s.length : t.digits, \n                            \"\" !== s || !t.digitsOptional)) {\n                                var p = Math.pow(10, f || 1);\n                                e = e.replace((0, i.default)(a), \".\"), isNaN(parseFloat(e)) || (e = (t.roundingFN(parseFloat(e) * p) / p).toFixed(f)), \n                                e = e.toString().replace(\".\", a);\n                            }\n                            if (0 === t.digits && -1 !== e.indexOf(a) && (e = e.substring(0, e.indexOf(a))), \n                            null !== t.min || null !== t.max) {\n                                var d = e.toString().replace(a, \".\");\n                                null !== t.min && d < t.min ? e = t.min.toString().replace(\".\", a) : null !== t.max && d > t.max && (e = t.max.toString().replace(\".\", a));\n                            }\n                            return r && \"-\" !== e.charAt(0) && (e = \"-\" + e), u(e.toString().split(\"\"), f, t, c).join(\"\");\n                        },\n                        onBeforeWrite: function(e, t, n, a) {\n                            function r(e, t) {\n                                if (!1 !== a.__financeInput || t) {\n                                    var n = e.indexOf(a.radixPoint);\n                                    -1 !== n && e.splice(n, 1);\n                                }\n                                if (\"\" !== a.groupSeparator) for (;-1 !== (n = e.indexOf(a.groupSeparator)); ) e.splice(n, 1);\n                                return e;\n                            }\n                            var o, l;\n                            if (a.stripLeadingZeroes && (l = function(e, t) {\n                                var n = new RegExp(\"(^\" + (\"\" !== t.negationSymbol.front ? (0, i.default)(t.negationSymbol.front) + \"?\" : \"\") + (0, \n                                i.default)(t.prefix) + \")(.*)(\" + (0, i.default)(t.suffix) + (\"\" != t.negationSymbol.back ? (0, \n                                i.default)(t.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(e.slice().reverse().join(\"\")), a = n ? n[2] : \"\", r = !1;\n                                return a && (a = a.split(t.radixPoint.charAt(0))[0], r = new RegExp(\"^[0\" + t.groupSeparator + \"]*\").exec(a)), \n                                !(!r || !(r[0].length > 1 || r[0].length > 0 && r[0].length < a.length)) && r;\n                            }(t, a))) for (var c = t.join(\"\").lastIndexOf(l[0].split(\"\").reverse().join(\"\")) - (l[0] == l.input ? 0 : 1), f = l[0] == l.input ? 1 : 0, p = l[0].length - f; p > 0; p--) this.maskset.validPositions.splice(c + p, 1), \n                            delete t[c + p];\n                            if (e) switch (e.type) {\n                              case \"blur\":\n                              case \"checkval\":\n                                if (null !== a.min) {\n                                    var d = a.onUnMask(t.slice().reverse().join(\"\"), void 0, s.extend({}, a, {\n                                        unmaskAsNumber: !0\n                                    }));\n                                    if (null !== a.min && d < a.min) return {\n                                        refreshFromBuffer: !0,\n                                        buffer: u(a.min.toString().replace(\".\", a.radixPoint).split(\"\"), a.digits, a).reverse()\n                                    };\n                                }\n                                if (t[t.length - 1] === a.negationSymbol.front) {\n                                    var h = new RegExp(\"(^\" + (\"\" != a.negationSymbol.front ? (0, i.default)(a.negationSymbol.front) + \"?\" : \"\") + (0, \n                                    i.default)(a.prefix) + \")(.*)(\" + (0, i.default)(a.suffix) + (\"\" != a.negationSymbol.back ? (0, \n                                    i.default)(a.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(r(t.slice(), !0).reverse().join(\"\"));\n                                    0 == (h ? h[2] : \"\") && (o = {\n                                        refreshFromBuffer: !0,\n                                        buffer: [ 0 ]\n                                    });\n                                } else if (\"\" !== a.radixPoint) {\n                                    t.indexOf(a.radixPoint) === a.suffix.length && (o && o.buffer ? o.buffer.splice(0, 1 + a.suffix.length) : (t.splice(0, 1 + a.suffix.length), \n                                    o = {\n                                        refreshFromBuffer: !0,\n                                        buffer: r(t)\n                                    }));\n                                }\n                                if (a.enforceDigitsOnBlur) {\n                                    var v = (o = o || {}) && o.buffer || t.slice().reverse();\n                                    o.refreshFromBuffer = !0, o.buffer = u(v, a.digits, a, !0).reverse();\n                                }\n                            }\n                            return o;\n                        },\n                        onKeyDown: function(e, t, n, i) {\n                            var a, o = s(this);\n                            if (3 != e.location) {\n                                var l, c = e.key;\n                                if ((l = i.shortcuts && i.shortcuts[c]) && l.length > 1) return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) * parseInt(l)), \n                                o.trigger(\"setvalue\"), !1;\n                            }\n                            if (e.ctrlKey) switch (e.key) {\n                              case r.keys.ArrowUp:\n                                return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(i.step)), \n                                o.trigger(\"setvalue\"), !1;\n\n                              case r.keys.ArrowDown:\n                                return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(i.step)), \n                                o.trigger(\"setvalue\"), !1;\n                            }\n                            if (!e.shiftKey && (e.key === r.keys.Delete || e.key === r.keys.Backspace || e.key === r.keys.BACKSPACE_SAFARI) && n.begin !== t.length) {\n                                if (t[e.key === r.keys.Delete ? n.begin - 1 : n.end] === i.negationSymbol.front) return a = t.slice().reverse(), \n                                \"\" !== i.negationSymbol.front && a.shift(), \"\" !== i.negationSymbol.back && a.pop(), \n                                o.trigger(\"setvalue\", [ a.join(\"\"), n.begin ]), !1;\n                                if (!0 === i._radixDance) {\n                                    var f, p = t.indexOf(i.radixPoint);\n                                    if (i.digitsOptional) {\n                                        if (0 === p) return (a = t.slice().reverse()).pop(), o.trigger(\"setvalue\", [ a.join(\"\"), n.begin >= a.length ? a.length : n.begin ]), \n                                        !1;\n                                    } else if (-1 !== p && (n.begin < p || n.end < p || e.key === r.keys.Delete && (n.begin === p || n.begin - 1 === p))) return n.begin === n.end && (e.key === r.keys.Backspace || e.key === r.keys.BACKSPACE_SAFARI ? n.begin++ : e.key === r.keys.Delete && n.begin - 1 === p && (f = s.extend({}, n), \n                                    n.begin--, n.end--)), (a = t.slice().reverse()).splice(a.length - n.begin, n.begin - n.end + 1), \n                                    a = u(a, i.digits, i).join(\"\"), f && (n = f), o.trigger(\"setvalue\", [ a, n.begin >= a.length ? p + 1 : n.begin ]), \n                                    !1;\n                                }\n                            }\n                        }\n                    },\n                    currency: {\n                        prefix: \"\",\n                        groupSeparator: \",\",\n                        alias: \"numeric\",\n                        digits: 2,\n                        digitsOptional: !1\n                    },\n                    decimal: {\n                        alias: \"numeric\"\n                    },\n                    integer: {\n                        alias: \"numeric\",\n                        inputmode: \"numeric\",\n                        digits: 0\n                    },\n                    percentage: {\n                        alias: \"numeric\",\n                        min: 0,\n                        max: 100,\n                        suffix: \" %\",\n                        digits: 0,\n                        allowMinus: !1\n                    },\n                    indianns: {\n                        alias: \"numeric\",\n                        _mask: function(e) {\n                            return \"(\" + e.groupSeparator + \"99){*|1}(\" + e.groupSeparator + \"999){1|1}\";\n                        },\n                        groupSeparator: \",\",\n                        radixPoint: \".\",\n                        placeholder: \"0\",\n                        digits: 2,\n                        digitsOptional: !1\n                    }\n                });\n            },\n            9380: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0;\n                var n = !(\"undefined\" == typeof window || !window.document || !window.document.createElement);\n                t.default = n ? window : {};\n            },\n            7760: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.HandleNativePlaceholder = function(e, t) {\n                    var n = e ? e.inputmask : this;\n                    if (i.ie) {\n                        if (e.inputmask._valueGet() !== t && (e.placeholder !== t || \"\" === e.placeholder)) {\n                            var a = o.getBuffer.call(n).slice(), r = e.inputmask._valueGet();\n                            if (r !== t) {\n                                var l = o.getLastValidPosition.call(n);\n                                -1 === l && r === o.getBufferTemplate.call(n).join(\"\") ? a = [] : -1 !== l && u.call(n, a), \n                                p(e, a);\n                            }\n                        }\n                    } else e.placeholder !== t && (e.placeholder = t, \"\" === e.placeholder && e.removeAttribute(\"placeholder\"));\n                }, t.applyInputValue = c, t.checkVal = f, t.clearOptionalTail = u, t.unmaskedvalue = function(e) {\n                    var t = e ? e.inputmask : this, n = t.opts, i = t.maskset;\n                    if (e) {\n                        if (void 0 === e.inputmask) return e.value;\n                        e.inputmask && e.inputmask.refreshValue && c(e, e.inputmask._valueGet(!0));\n                    }\n                    for (var a = [], r = i.validPositions, l = 0, s = r.length; l < s; l++) r[l] && r[l].match && (1 != r[l].match.static || Array.isArray(i.metadata) && !0 !== r[l].generatedInput) && a.push(r[l].input);\n                    var u = 0 === a.length ? \"\" : (t.isRTL ? a.reverse() : a).join(\"\");\n                    if (\"function\" == typeof n.onUnMask) {\n                        var f = (t.isRTL ? o.getBuffer.call(t).slice().reverse() : o.getBuffer.call(t)).join(\"\");\n                        u = n.onUnMask.call(t, f, u, n);\n                    }\n                    return u;\n                }, t.writeBuffer = p;\n                var i = n(9845), a = n(6030), r = n(2839), o = n(8711), l = n(7215), s = n(4713);\n                function c(e, t, n) {\n                    var i = e ? e.inputmask : this, a = i.opts;\n                    e.inputmask.refreshValue = !1, \"function\" == typeof a.onBeforeMask && (t = a.onBeforeMask.call(i, t, a) || t), \n                    f(e, !0, !1, t = (t || \"\").toString().split(\"\"), n), i.undoValue = i._valueGet(!0), \n                    (a.clearMaskOnLostFocus || a.clearIncomplete) && e.inputmask._valueGet() === o.getBufferTemplate.call(i).join(\"\") && -1 === o.getLastValidPosition.call(i) && e.inputmask._valueSet(\"\");\n                }\n                function u(e) {\n                    e.length = 0;\n                    for (var t, n = s.getMaskTemplate.call(this, !0, 0, !0, void 0, !0); void 0 !== (t = n.shift()); ) e.push(t);\n                    return e;\n                }\n                function f(e, t, n, i, r) {\n                    var c, u = e ? e.inputmask : this, f = u.maskset, d = u.opts, h = u.dependencyLib, v = i.slice(), m = \"\", g = -1, y = d.skipOptionalPartCharacter;\n                    d.skipOptionalPartCharacter = \"\", o.resetMaskSet.call(u, !1), u.clicked = 0, g = d.radixPoint ? o.determineNewCaretPosition.call(u, {\n                        begin: 0,\n                        end: 0\n                    }, !1, !1 === d.__financeInput ? \"radixFocus\" : void 0).begin : 0, f.p = g, u.caretPos = {\n                        begin: g\n                    };\n                    var k = [], b = u.caretPos;\n                    if (v.forEach((function(e, t) {\n                        if (void 0 !== e) {\n                            var i = new h.Event(\"_checkval\");\n                            i.key = e, m += e;\n                            var r = o.getLastValidPosition.call(u, void 0, !0);\n                            !function(e, t) {\n                                for (var n = s.getMaskTemplate.call(u, !0, 0).slice(e, o.seekNext.call(u, e, !1, !1)).join(\"\").replace(/'/g, \"\"), i = n.indexOf(t); i > 0 && \" \" === n[i - 1]; ) i--;\n                                var a = 0 === i && !o.isMask.call(u, e) && (s.getTest.call(u, e).match.nativeDef === t.charAt(0) || !0 === s.getTest.call(u, e).match.static && s.getTest.call(u, e).match.nativeDef === \"'\" + t.charAt(0) || \" \" === s.getTest.call(u, e).match.nativeDef && (s.getTest.call(u, e + 1).match.nativeDef === t.charAt(0) || !0 === s.getTest.call(u, e + 1).match.static && s.getTest.call(u, e + 1).match.nativeDef === \"'\" + t.charAt(0)));\n                                if (!a && i > 0 && !o.isMask.call(u, e, !1, !0)) {\n                                    var r = o.seekNext.call(u, e);\n                                    u.caretPos.begin < r && (u.caretPos = {\n                                        begin: r\n                                    });\n                                }\n                                return a;\n                            }(g, m) ? (c = a.EventHandlers.keypressEvent.call(u, i, !0, !1, n, u.caretPos.begin)) && (g = u.caretPos.begin + 1, \n                            m = \"\") : c = a.EventHandlers.keypressEvent.call(u, i, !0, !1, n, r + 1), c ? (void 0 !== c.pos && f.validPositions[c.pos] && !0 === f.validPositions[c.pos].match.static && void 0 === f.validPositions[c.pos].alternation && (k.push(c.pos), \n                            u.isRTL || (c.forwardPosition = c.pos + 1)), p.call(u, void 0, o.getBuffer.call(u), c.forwardPosition, i, !1), \n                            u.caretPos = {\n                                begin: c.forwardPosition,\n                                end: c.forwardPosition\n                            }, b = u.caretPos) : void 0 === f.validPositions[t] && v[t] === s.getPlaceholder.call(u, t) && o.isMask.call(u, t, !0) ? u.caretPos.begin++ : u.caretPos = b;\n                        }\n                    })), k.length > 0) {\n                        var x, w, P = o.seekNext.call(u, -1, void 0, !1);\n                        if (!l.isComplete.call(u, o.getBuffer.call(u)) && k.length <= P || l.isComplete.call(u, o.getBuffer.call(u)) && k.length > 0 && k.length !== P && 0 === k[0]) for (var S = P; void 0 !== (x = k.shift()); ) if (x < S) {\n                            var O = new h.Event(\"_checkval\");\n                            if ((w = f.validPositions[x]).generatedInput = !0, O.key = w.input, (c = a.EventHandlers.keypressEvent.call(u, O, !0, !1, n, S)) && void 0 !== c.pos && c.pos !== x && f.validPositions[c.pos] && !0 === f.validPositions[c.pos].match.static) k.push(c.pos); else if (!c) break;\n                            S++;\n                        }\n                    }\n                    t && p.call(u, e, o.getBuffer.call(u), c ? c.forwardPosition : u.caretPos.begin, r || new h.Event(\"checkval\"), r && (\"input\" === r.type && u.undoValue !== o.getBuffer.call(u).join(\"\") || \"paste\" === r.type)), \n                    d.skipOptionalPartCharacter = y;\n                }\n                function p(e, t, n, i, a) {\n                    var s = e ? e.inputmask : this, c = s.opts, u = s.dependencyLib;\n                    if (i && \"function\" == typeof c.onBeforeWrite) {\n                        var f = c.onBeforeWrite.call(s, i, t, n, c);\n                        if (f) {\n                            if (f.refreshFromBuffer) {\n                                var p = f.refreshFromBuffer;\n                                l.refreshFromBuffer.call(s, !0 === p ? p : p.start, p.end, f.buffer || t), t = o.getBuffer.call(s, !0);\n                            }\n                            void 0 !== n && (n = void 0 !== f.caret ? f.caret : n);\n                        }\n                    }\n                    if (void 0 !== e && (e.inputmask._valueSet(t.join(\"\")), void 0 === n || void 0 !== i && \"blur\" === i.type || o.caret.call(s, e, n, void 0, void 0, void 0 !== i && \"keydown\" === i.type && (i.key === r.keys.Delete || i.key === r.keys.Backspace)), \n                    void 0 === e.inputmask.writeBufferHook || e.inputmask.writeBufferHook(n), !0 === a)) {\n                        var d = u(e), h = e.inputmask._valueGet();\n                        e.inputmask.skipInputEvent = !0, d.trigger(\"input\"), setTimeout((function() {\n                            h === o.getBufferTemplate.call(s).join(\"\") ? d.trigger(\"cleared\") : !0 === l.isComplete.call(s, t) && d.trigger(\"complete\");\n                        }), 0);\n                    }\n                }\n            },\n            2394: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0;\n                var i = v(n(3976)), a = v(n(7392)), r = v(n(4963)), o = n(9716), l = v(n(9380)), s = n(7760), c = n(157), u = n(2391), f = n(8711), p = n(7215), d = n(4713);\n                function h(e) {\n                    return h = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    }, h(e);\n                }\n                function v(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var m = l.default.document, g = \"_inputmask_opts\";\n                function y(e, t, n) {\n                    if (!(this instanceof y)) return new y(e, t, n);\n                    this.dependencyLib = r.default, this.el = void 0, this.events = {}, this.maskset = void 0, \n                    !0 !== n && (\"[object Object]\" === Object.prototype.toString.call(e) ? t = e : (t = t || {}, \n                    e && (t.alias = e)), this.opts = r.default.extend(!0, {}, this.defaults, t), this.noMasksCache = t && void 0 !== t.definitions, \n                    this.userOptions = t || {}, k(this.opts.alias, t, this.opts)), this.refreshValue = !1, \n                    this.undoValue = void 0, this.$el = void 0, this.skipInputEvent = !1, this.validationEvent = !1, \n                    this.ignorable = !1, this.maxLength, this.mouseEnter = !1, this.clicked = 0, this.originalPlaceholder = void 0, \n                    this.isComposing = !1, this.hasAlternator = !1;\n                }\n                function k(e, t, n) {\n                    var i = y.prototype.aliases[e];\n                    return i ? (i.alias && k(i.alias, void 0, n), r.default.extend(!0, n, i), r.default.extend(!0, n, t), \n                    !0) : (null === n.mask && (n.mask = e), !1);\n                }\n                y.prototype = {\n                    dataAttribute: \"data-inputmask\",\n                    defaults: i.default,\n                    definitions: a.default,\n                    aliases: {},\n                    masksCache: {},\n                    i18n: {},\n                    get isRTL() {\n                        return this.opts.isRTL || this.opts.numericInput;\n                    },\n                    mask: function(e) {\n                        var t = this;\n                        return \"string\" == typeof e && (e = m.getElementById(e) || m.querySelectorAll(e)), \n                        (e = e.nodeName ? [ e ] : Array.isArray(e) ? e : [].slice.call(e)).forEach((function(e, n) {\n                            var i = r.default.extend(!0, {}, t.opts);\n                            if (function(e, t, n, i) {\n                                function a(t, a) {\n                                    var r = \"\" === i ? t : i + \"-\" + t;\n                                    null !== (a = void 0 !== a ? a : e.getAttribute(r)) && (\"string\" == typeof a && (0 === t.indexOf(\"on\") ? a = l.default[a] : \"false\" === a ? a = !1 : \"true\" === a && (a = !0)), \n                                    n[t] = a);\n                                }\n                                if (!0 === t.importDataAttributes) {\n                                    var o, s, c, u, f = e.getAttribute(i);\n                                    if (f && \"\" !== f && (f = f.replace(/'/g, '\"'), s = JSON.parse(\"{\" + f + \"}\")), \n                                    s) for (u in c = void 0, s) if (\"alias\" === u.toLowerCase()) {\n                                        c = s[u];\n                                        break;\n                                    }\n                                    for (o in a(\"alias\", c), n.alias && k(n.alias, n, t), t) {\n                                        if (s) for (u in c = void 0, s) if (u.toLowerCase() === o.toLowerCase()) {\n                                            c = s[u];\n                                            break;\n                                        }\n                                        a(o, c);\n                                    }\n                                }\n                                r.default.extend(!0, t, n), (\"rtl\" === e.dir || t.rightAlign) && (e.style.textAlign = \"right\");\n                                (\"rtl\" === e.dir || t.numericInput) && (e.dir = \"ltr\", e.removeAttribute(\"dir\"), \n                                t.isRTL = !0);\n                                return Object.keys(n).length;\n                            }(e, i, r.default.extend(!0, {}, t.userOptions), t.dataAttribute)) {\n                                var a = (0, u.generateMaskSet)(i, t.noMasksCache);\n                                void 0 !== a && (void 0 !== e.inputmask && (e.inputmask.opts.autoUnmask = !0, e.inputmask.remove()), \n                                e.inputmask = new y(void 0, void 0, !0), e.inputmask.opts = i, e.inputmask.noMasksCache = t.noMasksCache, \n                                e.inputmask.userOptions = r.default.extend(!0, {}, t.userOptions), e.inputmask.el = e, \n                                e.inputmask.$el = (0, r.default)(e), e.inputmask.maskset = a, r.default.data(e, g, t.userOptions), \n                                c.mask.call(e.inputmask));\n                            }\n                        })), e && e[0] && e[0].inputmask || this;\n                    },\n                    option: function(e, t) {\n                        return \"string\" == typeof e ? this.opts[e] : \"object\" === h(e) ? (r.default.extend(this.userOptions, e), \n                        this.el && !0 !== t && this.mask(this.el), this) : void 0;\n                    },\n                    unmaskedvalue: function(e) {\n                        if (this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), \n                        void 0 === this.el || void 0 !== e) {\n                            var t = (\"function\" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split(\"\");\n                            s.checkVal.call(this, void 0, !1, !1, t), \"function\" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, f.getBuffer.call(this), 0, this.opts);\n                        }\n                        return s.unmaskedvalue.call(this, this.el);\n                    },\n                    remove: function() {\n                        if (this.el) {\n                            r.default.data(this.el, g, null);\n                            var e = this.opts.autoUnmask ? (0, s.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);\n                            e !== f.getBufferTemplate.call(this).join(\"\") ? this._valueSet(e, this.opts.autoUnmask) : this._valueSet(\"\"), \n                            o.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), \"value\") && this.__valueGet && Object.defineProperty(this.el, \"value\", {\n                                get: this.__valueGet,\n                                set: this.__valueSet,\n                                configurable: !0\n                            }) : m.__lookupGetter__ && this.el.__lookupGetter__(\"value\") && this.__valueGet && (this.el.__defineGetter__(\"value\", this.__valueGet), \n                            this.el.__defineSetter__(\"value\", this.__valueSet)), this.el.inputmask = void 0;\n                        }\n                        return this.el;\n                    },\n                    getemptymask: function() {\n                        return this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), \n                        (this.isRTL ? f.getBufferTemplate.call(this).reverse() : f.getBufferTemplate.call(this)).join(\"\");\n                    },\n                    hasMaskedValue: function() {\n                        return !this.opts.autoUnmask;\n                    },\n                    isComplete: function() {\n                        return this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), \n                        p.isComplete.call(this, f.getBuffer.call(this));\n                    },\n                    getmetadata: function() {\n                        if (this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), \n                        Array.isArray(this.maskset.metadata)) {\n                            var e = d.getMaskTemplate.call(this, !0, 0, !1).join(\"\");\n                            return this.maskset.metadata.forEach((function(t) {\n                                return t.mask !== e || (e = t, !1);\n                            })), e;\n                        }\n                        return this.maskset.metadata;\n                    },\n                    isValid: function(e) {\n                        if (this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), \n                        e) {\n                            var t = (\"function\" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split(\"\");\n                            s.checkVal.call(this, void 0, !0, !1, t);\n                        } else e = this.isRTL ? f.getBuffer.call(this).slice().reverse().join(\"\") : f.getBuffer.call(this).join(\"\");\n                        for (var n = f.getBuffer.call(this), i = f.determineLastRequiredPosition.call(this), a = n.length - 1; a > i && !f.isMask.call(this, a); a--) ;\n                        return n.splice(i, a + 1 - i), p.isComplete.call(this, n) && e === (this.isRTL ? f.getBuffer.call(this).slice().reverse().join(\"\") : f.getBuffer.call(this).join(\"\"));\n                    },\n                    format: function(e, t) {\n                        this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache);\n                        var n = (\"function\" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split(\"\");\n                        s.checkVal.call(this, void 0, !0, !1, n);\n                        var i = this.isRTL ? f.getBuffer.call(this).slice().reverse().join(\"\") : f.getBuffer.call(this).join(\"\");\n                        return t ? {\n                            value: i,\n                            metadata: this.getmetadata()\n                        } : i;\n                    },\n                    setValue: function(e) {\n                        this.el && (0, r.default)(this.el).trigger(\"setvalue\", [ e ]);\n                    },\n                    analyseMask: u.analyseMask\n                }, y.extendDefaults = function(e) {\n                    r.default.extend(!0, y.prototype.defaults, e);\n                }, y.extendDefinitions = function(e) {\n                    r.default.extend(!0, y.prototype.definitions, e);\n                }, y.extendAliases = function(e) {\n                    r.default.extend(!0, y.prototype.aliases, e);\n                }, y.format = function(e, t, n) {\n                    return y(t).format(e, n);\n                }, y.unmask = function(e, t) {\n                    return y(t).unmaskedvalue(e);\n                }, y.isValid = function(e, t) {\n                    return y(t).isValid(e);\n                }, y.remove = function(e) {\n                    \"string\" == typeof e && (e = m.getElementById(e) || m.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {\n                        e.inputmask && e.inputmask.remove();\n                    }));\n                }, y.setValue = function(e, t) {\n                    \"string\" == typeof e && (e = m.getElementById(e) || m.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {\n                        e.inputmask ? e.inputmask.setValue(t) : (0, r.default)(e).trigger(\"setvalue\", [ t ]);\n                    }));\n                }, y.dependencyLib = r.default, l.default.Inputmask = y;\n                t.default = y;\n            },\n            5296: function(e, t, n) {\n                function i(e) {\n                    return i = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    }, i(e);\n                }\n                var a = d(n(9380)), r = d(n(2394));\n                function o(e, t) {\n                    for (var n = 0; n < t.length; n++) {\n                        var a = t[n];\n                        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), \n                        Object.defineProperty(e, (r = a.key, o = void 0, o = function(e, t) {\n                            if (\"object\" !== i(e) || null === e) return e;\n                            var n = e[Symbol.toPrimitive];\n                            if (void 0 !== n) {\n                                var a = n.call(e, t || \"default\");\n                                if (\"object\" !== i(a)) return a;\n                                throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                            }\n                            return (\"string\" === t ? String : Number)(e);\n                        }(r, \"string\"), \"symbol\" === i(o) ? o : String(o)), a);\n                    }\n                    var r, o;\n                }\n                function l(e) {\n                    var t = u();\n                    return function() {\n                        var n, a = p(e);\n                        if (t) {\n                            var r = p(this).constructor;\n                            n = Reflect.construct(a, arguments, r);\n                        } else n = a.apply(this, arguments);\n                        return function(e, t) {\n                            if (t && (\"object\" === i(t) || \"function\" == typeof t)) return t;\n                            if (void 0 !== t) throw new TypeError(\"Derived constructors may only return object or undefined\");\n                            return function(e) {\n                                if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                                return e;\n                            }(e);\n                        }(this, n);\n                    };\n                }\n                function s(e) {\n                    var t = \"function\" == typeof Map ? new Map : void 0;\n                    return s = function(e) {\n                        if (null === e || !function(e) {\n                            try {\n                                return -1 !== Function.toString.call(e).indexOf(\"[native code]\");\n                            } catch (t) {\n                                return \"function\" == typeof e;\n                            }\n                        }(e)) return e;\n                        if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n                        if (void 0 !== t) {\n                            if (t.has(e)) return t.get(e);\n                            t.set(e, n);\n                        }\n                        function n() {\n                            return c(e, arguments, p(this).constructor);\n                        }\n                        return n.prototype = Object.create(e.prototype, {\n                            constructor: {\n                                value: n,\n                                enumerable: !1,\n                                writable: !0,\n                                configurable: !0\n                            }\n                        }), f(n, e);\n                    }, s(e);\n                }\n                function c(e, t, n) {\n                    return c = u() ? Reflect.construct.bind() : function(e, t, n) {\n                        var i = [ null ];\n                        i.push.apply(i, t);\n                        var a = new (Function.bind.apply(e, i));\n                        return n && f(a, n.prototype), a;\n                    }, c.apply(null, arguments);\n                }\n                function u() {\n                    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n                    if (Reflect.construct.sham) return !1;\n                    if (\"function\" == typeof Proxy) return !0;\n                    try {\n                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), \n                        !0;\n                    } catch (e) {\n                        return !1;\n                    }\n                }\n                function f(e, t) {\n                    return f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {\n                        return e.__proto__ = t, e;\n                    }, f(e, t);\n                }\n                function p(e) {\n                    return p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {\n                        return e.__proto__ || Object.getPrototypeOf(e);\n                    }, p(e);\n                }\n                function d(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var h = a.default.document;\n                if (h && h.head && h.head.attachShadow && a.default.customElements && void 0 === a.default.customElements.get(\"input-mask\")) {\n                    var v = function(e) {\n                        !function(e, t) {\n                            if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n                            e.prototype = Object.create(t && t.prototype, {\n                                constructor: {\n                                    value: e,\n                                    writable: !0,\n                                    configurable: !0\n                                }\n                            }), Object.defineProperty(e, \"prototype\", {\n                                writable: !1\n                            }), t && f(e, t);\n                        }(s, e);\n                        var t, n, i, a = l(s);\n                        function s() {\n                            var e;\n                            !function(e, t) {\n                                if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n                            }(this, s);\n                            var t = (e = a.call(this)).getAttributeNames(), n = e.attachShadow({\n                                mode: \"closed\"\n                            });\n                            for (var i in e.input = h.createElement(\"input\"), e.input.type = \"text\", n.appendChild(e.input), \n                            t) Object.prototype.hasOwnProperty.call(t, i) && e.input.setAttribute(t[i], e.getAttribute(t[i]));\n                            var o = new r.default;\n                            return o.dataAttribute = \"\", o.mask(e.input), e.input.inputmask.shadowRoot = n, \n                            e;\n                        }\n                        return t = s, (n = [ {\n                            key: \"attributeChangedCallback\",\n                            value: function(e, t, n) {\n                                this.input.setAttribute(e, n);\n                            }\n                        }, {\n                            key: \"value\",\n                            get: function() {\n                                return this.input.value;\n                            },\n                            set: function(e) {\n                                this.input.value = e;\n                            }\n                        } ]) && o(t.prototype, n), i && o(t, i), Object.defineProperty(t, \"prototype\", {\n                            writable: !1\n                        }), s;\n                    }(s(HTMLElement));\n                    a.default.customElements.define(\"input-mask\", v);\n                }\n            },\n            2839: function(e, t) {\n                function n(e) {\n                    return n = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    }, n(e);\n                }\n                function i(e, t) {\n                    return function(e) {\n                        if (Array.isArray(e)) return e;\n                    }(e) || function(e, t) {\n                        var n = null == e ? null : \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n                        if (null != n) {\n                            var i, a, r, o, l = [], s = !0, c = !1;\n                            try {\n                                if (r = (n = n.call(e)).next, 0 === t) {\n                                    if (Object(n) !== n) return;\n                                    s = !1;\n                                } else for (;!(s = (i = r.call(n)).done) && (l.push(i.value), l.length !== t); s = !0) ;\n                            } catch (e) {\n                                c = !0, a = e;\n                            } finally {\n                                try {\n                                    if (!s && null != n.return && (o = n.return(), Object(o) !== o)) return;\n                                } finally {\n                                    if (c) throw a;\n                                }\n                            }\n                            return l;\n                        }\n                    }(e, t) || function(e, t) {\n                        if (!e) return;\n                        if (\"string\" == typeof e) return a(e, t);\n                        var n = Object.prototype.toString.call(e).slice(8, -1);\n                        \"Object\" === n && e.constructor && (n = e.constructor.name);\n                        if (\"Map\" === n || \"Set\" === n) return Array.from(e);\n                        if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return a(e, t);\n                    }(e, t) || function() {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                    }();\n                }\n                function a(e, t) {\n                    (null == t || t > e.length) && (t = e.length);\n                    for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n                    return i;\n                }\n                function r(e, t) {\n                    var n = Object.keys(e);\n                    if (Object.getOwnPropertySymbols) {\n                        var i = Object.getOwnPropertySymbols(e);\n                        t && (i = i.filter((function(t) {\n                            return Object.getOwnPropertyDescriptor(e, t).enumerable;\n                        }))), n.push.apply(n, i);\n                    }\n                    return n;\n                }\n                function o(e, t, i) {\n                    return (t = function(e) {\n                        var t = function(e, t) {\n                            if (\"object\" !== n(e) || null === e) return e;\n                            var i = e[Symbol.toPrimitive];\n                            if (void 0 !== i) {\n                                var a = i.call(e, t || \"default\");\n                                if (\"object\" !== n(a)) return a;\n                                throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                            }\n                            return (\"string\" === t ? String : Number)(e);\n                        }(e, \"string\");\n                        return \"symbol\" === n(t) ? t : String(t);\n                    }(t)) in e ? Object.defineProperty(e, t, {\n                        value: i,\n                        enumerable: !0,\n                        configurable: !0,\n                        writable: !0\n                    }) : e[t] = i, e;\n                }\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.keys = t.keyCode = void 0, t.toKey = function(e, t) {\n                    return s[e] || (t ? String.fromCharCode(e) : String.fromCharCode(e).toLowerCase());\n                }, t.toKeyCode = function(e) {\n                    return l[e];\n                };\n                var l = t.keyCode = function(e) {\n                    for (var t = 1; t < arguments.length; t++) {\n                        var n = null != arguments[t] ? arguments[t] : {};\n                        t % 2 ? r(Object(n), !0).forEach((function(t) {\n                            o(e, t, n[t]);\n                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r(Object(n)).forEach((function(t) {\n                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n                        }));\n                    }\n                    return e;\n                }({\n                    c: 67,\n                    x: 88,\n                    z: 90,\n                    BACKSPACE_SAFARI: 127,\n                    Enter: 13,\n                    Meta_LEFT: 91,\n                    Meta_RIGHT: 92,\n                    Space: 32\n                }, {\n                    Alt: 18,\n                    AltGraph: 18,\n                    ArrowDown: 40,\n                    ArrowLeft: 37,\n                    ArrowRight: 39,\n                    ArrowUp: 38,\n                    Backspace: 8,\n                    CapsLock: 20,\n                    Control: 17,\n                    ContextMenu: 93,\n                    Dead: 221,\n                    Delete: 46,\n                    End: 35,\n                    Escape: 27,\n                    F1: 112,\n                    F2: 113,\n                    F3: 114,\n                    F4: 115,\n                    F5: 116,\n                    F6: 117,\n                    F7: 118,\n                    F8: 119,\n                    F9: 120,\n                    F10: 121,\n                    F11: 122,\n                    F12: 123,\n                    Home: 36,\n                    Insert: 45,\n                    NumLock: 144,\n                    PageDown: 34,\n                    PageUp: 33,\n                    Pause: 19,\n                    PrintScreen: 44,\n                    Process: 229,\n                    Shift: 16,\n                    ScrollLock: 145,\n                    Tab: 9,\n                    Unidentified: 229\n                }), s = Object.entries(l).reduce((function(e, t) {\n                    var n = i(t, 2), a = n[0], r = n[1];\n                    return e[r] = void 0 === e[r] ? a : e[r], e;\n                }), {});\n                t.keys = Object.entries(l).reduce((function(e, t) {\n                    var n = i(t, 2), a = n[0];\n                    n[1];\n                    return e[a] = \"Space\" === a ? \" \" : a, e;\n                }), {});\n            },\n            2391: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.analyseMask = function(e, t, n) {\n                    var i, a, s, c, u, f, p = /(?:[?*+]|\\{[0-9+*]+(?:,[0-9+*]*)?(?:\\|[0-9+*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g, d = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g, h = !1, v = new o.default, m = [], g = [], y = !1;\n                    function k(e, i, a) {\n                        a = void 0 !== a ? a : e.matches.length;\n                        var o = e.matches[a - 1];\n                        if (t) {\n                            if (0 === i.indexOf(\"[\") || h && /\\\\d|\\\\s|\\\\w|\\\\p/i.test(i) || \".\" === i) {\n                                var s = n.casing ? \"i\" : \"\";\n                                /\\\\p\\{.*}/i.test(i) && (s += \"u\"), e.matches.splice(a++, 0, {\n                                    fn: new RegExp(i, s),\n                                    static: !1,\n                                    optionality: !1,\n                                    newBlockMarker: void 0 === o ? \"master\" : o.def !== i,\n                                    casing: null,\n                                    def: i,\n                                    placeholder: \"object\" === l(n.placeholder) ? n.placeholder[v.matches.length] : void 0,\n                                    nativeDef: i\n                                });\n                            } else h && (i = i[i.length - 1]), i.split(\"\").forEach((function(t, i) {\n                                o = e.matches[a - 1], e.matches.splice(a++, 0, {\n                                    fn: /[a-z]/i.test(n.staticDefinitionSymbol || t) ? new RegExp(\"[\" + (n.staticDefinitionSymbol || t) + \"]\", n.casing ? \"i\" : \"\") : null,\n                                    static: !0,\n                                    optionality: !1,\n                                    newBlockMarker: void 0 === o ? \"master\" : o.def !== t && !0 !== o.static,\n                                    casing: null,\n                                    def: n.staticDefinitionSymbol || t,\n                                    placeholder: void 0 !== n.staticDefinitionSymbol ? t : \"object\" === l(n.placeholder) ? n.placeholder[v.matches.length] : void 0,\n                                    nativeDef: (h ? \"'\" : \"\") + t\n                                });\n                            }));\n                            h = !1;\n                        } else {\n                            var c = n.definitions && n.definitions[i] || n.usePrototypeDefinitions && r.default.prototype.definitions[i];\n                            c && !h ? e.matches.splice(a++, 0, {\n                                fn: c.validator ? \"string\" == typeof c.validator ? new RegExp(c.validator, n.casing ? \"i\" : \"\") : new function() {\n                                    this.test = c.validator;\n                                } : /./,\n                                static: c.static || !1,\n                                optionality: c.optional || !1,\n                                defOptionality: c.optional || !1,\n                                newBlockMarker: void 0 === o || c.optional ? \"master\" : o.def !== (c.definitionSymbol || i),\n                                casing: c.casing,\n                                def: c.definitionSymbol || i,\n                                placeholder: c.placeholder,\n                                nativeDef: i,\n                                generated: c.generated\n                            }) : (e.matches.splice(a++, 0, {\n                                fn: /[a-z]/i.test(n.staticDefinitionSymbol || i) ? new RegExp(\"[\" + (n.staticDefinitionSymbol || i) + \"]\", n.casing ? \"i\" : \"\") : null,\n                                static: !0,\n                                optionality: !1,\n                                newBlockMarker: void 0 === o ? \"master\" : o.def !== i && !0 !== o.static,\n                                casing: null,\n                                def: n.staticDefinitionSymbol || i,\n                                placeholder: void 0 !== n.staticDefinitionSymbol ? i : void 0,\n                                nativeDef: (h ? \"'\" : \"\") + i\n                            }), h = !1);\n                        }\n                    }\n                    function b() {\n                        if (m.length > 0) {\n                            if (k(c = m[m.length - 1], a), c.isAlternator) {\n                                u = m.pop();\n                                for (var e = 0; e < u.matches.length; e++) u.matches[e].isGroup && (u.matches[e].isGroup = !1);\n                                m.length > 0 ? (c = m[m.length - 1]).matches.push(u) : v.matches.push(u);\n                            }\n                        } else k(v, a);\n                    }\n                    function x(e) {\n                        var t = new o.default(!0);\n                        return t.openGroup = !1, t.matches = e, t;\n                    }\n                    function w() {\n                        if ((s = m.pop()).openGroup = !1, void 0 !== s) if (m.length > 0) {\n                            if ((c = m[m.length - 1]).matches.push(s), c.isAlternator) {\n                                u = m.pop();\n                                for (var e = 0; e < u.matches.length; e++) u.matches[e].isGroup = !1, u.matches[e].alternatorGroup = !1;\n                                m.length > 0 ? (c = m[m.length - 1]).matches.push(u) : v.matches.push(u);\n                            }\n                        } else v.matches.push(s); else b();\n                    }\n                    function P(e) {\n                        var t = e.pop();\n                        return t.isQuantifier && (t = x([ e.pop(), t ])), t;\n                    }\n                    t && (n.optionalmarker[0] = void 0, n.optionalmarker[1] = void 0);\n                    for (;i = t ? d.exec(e) : p.exec(e); ) {\n                        if (a = i[0], t) {\n                            switch (a.charAt(0)) {\n                              case \"?\":\n                                a = \"{0,1}\";\n                                break;\n\n                              case \"+\":\n                              case \"*\":\n                                a = \"{\" + a + \"}\";\n                                break;\n\n                              case \"|\":\n                                if (0 === m.length) {\n                                    var S = x(v.matches);\n                                    S.openGroup = !0, m.push(S), v.matches = [], y = !0;\n                                }\n                            }\n                            switch (a) {\n                              case \"\\\\d\":\n                                a = \"[0-9]\";\n                                break;\n\n                              case \"\\\\p\":\n                                a += d.exec(e)[0], a += d.exec(e)[0];\n                            }\n                        }\n                        if (h) b(); else switch (a.charAt(0)) {\n                          case \"$\":\n                          case \"^\":\n                            t || b();\n                            break;\n\n                          case n.escapeChar:\n                            h = !0, t && b();\n                            break;\n\n                          case n.optionalmarker[1]:\n                          case n.groupmarker[1]:\n                            w();\n                            break;\n\n                          case n.optionalmarker[0]:\n                            m.push(new o.default(!1, !0));\n                            break;\n\n                          case n.groupmarker[0]:\n                            m.push(new o.default(!0));\n                            break;\n\n                          case n.quantifiermarker[0]:\n                            var O = new o.default(!1, !1, !0), _ = (a = a.replace(/[{}?]/g, \"\")).split(\"|\"), M = _[0].split(\",\"), E = isNaN(M[0]) ? M[0] : parseInt(M[0]), j = 1 === M.length ? E : isNaN(M[1]) ? M[1] : parseInt(M[1]), T = isNaN(_[1]) ? _[1] : parseInt(_[1]);\n                            \"*\" !== E && \"+\" !== E || (E = \"*\" === j ? 0 : 1), O.quantifier = {\n                                min: E,\n                                max: j,\n                                jit: T\n                            };\n                            var A = m.length > 0 ? m[m.length - 1].matches : v.matches;\n                            (i = A.pop()).isGroup || (i = x([ i ])), A.push(i), A.push(O);\n                            break;\n\n                          case n.alternatormarker:\n                            if (m.length > 0) {\n                                var D = (c = m[m.length - 1]).matches[c.matches.length - 1];\n                                f = c.openGroup && (void 0 === D.matches || !1 === D.isGroup && !1 === D.isAlternator) ? m.pop() : P(c.matches);\n                            } else f = P(v.matches);\n                            if (f.isAlternator) m.push(f); else if (f.alternatorGroup ? (u = m.pop(), f.alternatorGroup = !1) : u = new o.default(!1, !1, !1, !0), \n                            u.matches.push(f), m.push(u), f.openGroup) {\n                                f.openGroup = !1;\n                                var L = new o.default(!0);\n                                L.alternatorGroup = !0, m.push(L);\n                            }\n                            break;\n\n                          default:\n                            b();\n                        }\n                    }\n                    y && w();\n                    for (;m.length > 0; ) s = m.pop(), v.matches.push(s);\n                    v.matches.length > 0 && (!function e(i) {\n                        i && i.matches && i.matches.forEach((function(a, r) {\n                            var o = i.matches[r + 1];\n                            (void 0 === o || void 0 === o.matches || !1 === o.isQuantifier) && a && a.isGroup && (a.isGroup = !1, \n                            t || (k(a, n.groupmarker[0], 0), !0 !== a.openGroup && k(a, n.groupmarker[1]))), \n                            e(a);\n                        }));\n                    }(v), g.push(v));\n                    (n.numericInput || n.isRTL) && function e(t) {\n                        for (var i in t.matches = t.matches.reverse(), t.matches) if (Object.prototype.hasOwnProperty.call(t.matches, i)) {\n                            var a = parseInt(i);\n                            if (t.matches[i].isQuantifier && t.matches[a + 1] && t.matches[a + 1].isGroup) {\n                                var r = t.matches[i];\n                                t.matches.splice(i, 1), t.matches.splice(a + 1, 0, r);\n                            }\n                            void 0 !== t.matches[i].matches ? t.matches[i] = e(t.matches[i]) : t.matches[i] = ((o = t.matches[i]) === n.optionalmarker[0] ? o = n.optionalmarker[1] : o === n.optionalmarker[1] ? o = n.optionalmarker[0] : o === n.groupmarker[0] ? o = n.groupmarker[1] : o === n.groupmarker[1] && (o = n.groupmarker[0]), \n                            o);\n                        }\n                        var o;\n                        return t;\n                    }(g[0]);\n                    return g;\n                }, t.generateMaskSet = function(e, t) {\n                    var n;\n                    function o(e, t) {\n                        var n = t.repeat, i = t.groupmarker, r = t.quantifiermarker, o = t.keepStatic;\n                        if (n > 0 || \"*\" === n || \"+\" === n) {\n                            var l = \"*\" === n ? 0 : \"+\" === n ? 1 : n;\n                            if (l != n) e = i[0] + e + i[1] + r[0] + l + \",\" + n + r[1]; else for (var c = e, u = 1; u < l; u++) e += c;\n                        }\n                        if (!0 === o) {\n                            var f = e.match(new RegExp(\"(.)\\\\[([^\\\\]]*)\\\\]\", \"g\"));\n                            f && f.forEach((function(t, n) {\n                                var i = function(e, t) {\n                                    return function(e) {\n                                        if (Array.isArray(e)) return e;\n                                    }(e) || function(e, t) {\n                                        var n = null == e ? null : \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n                                        if (null != n) {\n                                            var i, a, r, o, l = [], s = !0, c = !1;\n                                            try {\n                                                if (r = (n = n.call(e)).next, 0 === t) {\n                                                    if (Object(n) !== n) return;\n                                                    s = !1;\n                                                } else for (;!(s = (i = r.call(n)).done) && (l.push(i.value), l.length !== t); s = !0) ;\n                                            } catch (e) {\n                                                c = !0, a = e;\n                                            } finally {\n                                                try {\n                                                    if (!s && null != n.return && (o = n.return(), Object(o) !== o)) return;\n                                                } finally {\n                                                    if (c) throw a;\n                                                }\n                                            }\n                                            return l;\n                                        }\n                                    }(e, t) || function(e, t) {\n                                        if (!e) return;\n                                        if (\"string\" == typeof e) return s(e, t);\n                                        var n = Object.prototype.toString.call(e).slice(8, -1);\n                                        \"Object\" === n && e.constructor && (n = e.constructor.name);\n                                        if (\"Map\" === n || \"Set\" === n) return Array.from(e);\n                                        if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return s(e, t);\n                                    }(e, t) || function() {\n                                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n                                    }();\n                                }(t.split(\"[\"), 2), r = i[0], o = i[1];\n                                o = o.replace(\"]\", \"\"), e = e.replace(new RegExp(\"\".concat((0, a.default)(r), \"\\\\[\").concat((0, \n                                a.default)(o), \"\\\\]\")), r.charAt(0) === o.charAt(0) ? \"(\".concat(r, \"|\").concat(r).concat(o, \")\") : \"\".concat(r, \"[\").concat(o, \"]\"));\n                            }));\n                        }\n                        return e;\n                    }\n                    function c(e, n, a) {\n                        var s, c, u = !1;\n                        return null !== e && \"\" !== e || ((u = null !== a.regex) ? e = (e = a.regex).replace(/^(\\^)(.*)(\\$)$/, \"$2\") : (u = !0, \n                        e = \".*\")), 1 === e.length && !1 === a.greedy && 0 !== a.repeat && (a.placeholder = \"\"), \n                        e = o(e, a), c = u ? \"regex_\" + a.regex : a.numericInput ? e.split(\"\").reverse().join(\"\") : e, \n                        null !== a.keepStatic && (c = \"ks_\" + a.keepStatic + c), \"object\" === l(a.placeholder) && (c = \"ph_\" + JSON.stringify(a.placeholder) + c), \n                        void 0 === r.default.prototype.masksCache[c] || !0 === t ? (s = {\n                            mask: e,\n                            maskToken: r.default.prototype.analyseMask(e, u, a),\n                            validPositions: [],\n                            _buffer: void 0,\n                            buffer: void 0,\n                            tests: {},\n                            excludes: {},\n                            metadata: n,\n                            maskLength: void 0,\n                            jitOffset: {}\n                        }, !0 !== t && (r.default.prototype.masksCache[c] = s, s = i.default.extend(!0, {}, r.default.prototype.masksCache[c]))) : s = i.default.extend(!0, {}, r.default.prototype.masksCache[c]), \n                        s;\n                    }\n                    \"function\" == typeof e.mask && (e.mask = e.mask(e));\n                    if (Array.isArray(e.mask)) {\n                        if (e.mask.length > 1) {\n                            null === e.keepStatic && (e.keepStatic = !0);\n                            var u = e.groupmarker[0];\n                            return (e.isRTL ? e.mask.reverse() : e.mask).forEach((function(t) {\n                                u.length > 1 && (u += e.alternatormarker), void 0 !== t.mask && \"function\" != typeof t.mask ? u += t.mask : u += t;\n                            })), c(u += e.groupmarker[1], e.mask, e);\n                        }\n                        e.mask = e.mask.pop();\n                    }\n                    n = e.mask && void 0 !== e.mask.mask && \"function\" != typeof e.mask.mask ? c(e.mask.mask, e.mask, e) : c(e.mask, e.mask, e);\n                    null === e.keepStatic && (e.keepStatic = !1);\n                    return n;\n                };\n                var i = c(n(4963)), a = c(n(7184)), r = c(n(2394)), o = c(n(9695));\n                function l(e) {\n                    return l = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    }, l(e);\n                }\n                function s(e, t) {\n                    (null == t || t > e.length) && (t = e.length);\n                    for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n                    return i;\n                }\n                function c(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n            },\n            157: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.mask = function() {\n                    var e = this, t = this.opts, n = this.el, c = this.dependencyLib;\n                    r.EventRuler.off(n);\n                    var u = function(t, n) {\n                        var i = t.getAttribute(\"type\"), a = \"input\" === t.tagName.toLowerCase() && n.supportsInputType.includes(i) || t.isContentEditable || \"textarea\" === t.tagName.toLowerCase();\n                        if (!a) if (\"input\" === t.tagName.toLowerCase()) {\n                            var s = document.createElement(\"input\");\n                            s.setAttribute(\"type\", i), a = \"text\" === s.type, s = null;\n                        } else a = \"partial\";\n                        return !1 !== a ? function(t) {\n                            var i, a;\n                            function s() {\n                                return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== l.getLastValidPosition.call(e) || !0 !== n.nullable ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && n.clearMaskOnLostFocus ? (e.isRTL ? o.clearOptionalTail.call(e, l.getBuffer.call(e).slice()).reverse() : o.clearOptionalTail.call(e, l.getBuffer.call(e).slice())).join(\"\") : i.call(this) : \"\" : i.call(this);\n                            }\n                            function u(e) {\n                                a.call(this, e), this.inputmask && (0, o.applyInputValue)(this, e);\n                            }\n                            if (!t.inputmask.__valueGet) {\n                                if (!0 !== n.noValuePatching) {\n                                    if (Object.getOwnPropertyDescriptor) {\n                                        var f = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t), \"value\") : void 0;\n                                        f && f.get && f.set ? (i = f.get, a = f.set, Object.defineProperty(t, \"value\", {\n                                            get: s,\n                                            set: u,\n                                            configurable: !0\n                                        })) : \"input\" !== t.tagName.toLowerCase() && (i = function() {\n                                            return this.textContent;\n                                        }, a = function(e) {\n                                            this.textContent = e;\n                                        }, Object.defineProperty(t, \"value\", {\n                                            get: s,\n                                            set: u,\n                                            configurable: !0\n                                        }));\n                                    } else document.__lookupGetter__ && t.__lookupGetter__(\"value\") && (i = t.__lookupGetter__(\"value\"), \n                                    a = t.__lookupSetter__(\"value\"), t.__defineGetter__(\"value\", s), t.__defineSetter__(\"value\", u));\n                                    t.inputmask.__valueGet = i, t.inputmask.__valueSet = a;\n                                }\n                                t.inputmask._valueGet = function(t) {\n                                    return e.isRTL && !0 !== t ? i.call(this.el).split(\"\").reverse().join(\"\") : i.call(this.el);\n                                }, t.inputmask._valueSet = function(t, n) {\n                                    a.call(this.el, null == t ? \"\" : !0 !== n && e.isRTL ? t.split(\"\").reverse().join(\"\") : t);\n                                }, void 0 === i && (i = function() {\n                                    return this.value;\n                                }, a = function(e) {\n                                    this.value = e;\n                                }, function(t) {\n                                    if (c.valHooks && (void 0 === c.valHooks[t] || !0 !== c.valHooks[t].inputmaskpatch)) {\n                                        var i = c.valHooks[t] && c.valHooks[t].get ? c.valHooks[t].get : function(e) {\n                                            return e.value;\n                                        }, a = c.valHooks[t] && c.valHooks[t].set ? c.valHooks[t].set : function(e, t) {\n                                            return e.value = t, e;\n                                        };\n                                        c.valHooks[t] = {\n                                            get: function(t) {\n                                                if (t.inputmask) {\n                                                    if (t.inputmask.opts.autoUnmask) return t.inputmask.unmaskedvalue();\n                                                    var a = i(t);\n                                                    return -1 !== l.getLastValidPosition.call(e, void 0, void 0, t.inputmask.maskset.validPositions) || !0 !== n.nullable ? a : \"\";\n                                                }\n                                                return i(t);\n                                            },\n                                            set: function(e, t) {\n                                                var n = a(e, t);\n                                                return e.inputmask && (0, o.applyInputValue)(e, t), n;\n                                            },\n                                            inputmaskpatch: !0\n                                        };\n                                    }\n                                }(t.type), function(e) {\n                                    r.EventRuler.on(e, \"mouseenter\", (function() {\n                                        var e = this, t = e.inputmask._valueGet(!0);\n                                        t != (e.inputmask.isRTL ? l.getBuffer.call(e.inputmask).slice().reverse() : l.getBuffer.call(e.inputmask)).join(\"\") && (0, \n                                        o.applyInputValue)(e, t);\n                                    }));\n                                }(t));\n                            }\n                        }(t) : t.inputmask = void 0, a;\n                    }(n, t);\n                    if (!1 !== u) {\n                        e.originalPlaceholder = n.placeholder, e.maxLength = void 0 !== n ? n.maxLength : void 0, \n                        -1 === e.maxLength && (e.maxLength = void 0), \"inputMode\" in n && null === n.getAttribute(\"inputmode\") && (n.inputMode = t.inputmode, \n                        n.setAttribute(\"inputmode\", t.inputmode)), !0 === u && (t.showMaskOnFocus = t.showMaskOnFocus && -1 === [ \"cc-number\", \"cc-exp\" ].indexOf(n.autocomplete), \n                        i.iphone && (t.insertModeVisual = !1, n.setAttribute(\"autocorrect\", \"off\")), r.EventRuler.on(n, \"submit\", a.EventHandlers.submitEvent), \n                        r.EventRuler.on(n, \"reset\", a.EventHandlers.resetEvent), r.EventRuler.on(n, \"blur\", a.EventHandlers.blurEvent), \n                        r.EventRuler.on(n, \"focus\", a.EventHandlers.focusEvent), r.EventRuler.on(n, \"invalid\", a.EventHandlers.invalidEvent), \n                        r.EventRuler.on(n, \"click\", a.EventHandlers.clickEvent), r.EventRuler.on(n, \"mouseleave\", a.EventHandlers.mouseleaveEvent), \n                        r.EventRuler.on(n, \"mouseenter\", a.EventHandlers.mouseenterEvent), r.EventRuler.on(n, \"paste\", a.EventHandlers.pasteEvent), \n                        r.EventRuler.on(n, \"cut\", a.EventHandlers.cutEvent), r.EventRuler.on(n, \"complete\", t.oncomplete), \n                        r.EventRuler.on(n, \"incomplete\", t.onincomplete), r.EventRuler.on(n, \"cleared\", t.oncleared), \n                        !0 !== t.inputEventOnly && r.EventRuler.on(n, \"keydown\", a.EventHandlers.keyEvent), \n                        (i.mobile || t.inputEventOnly) && n.removeAttribute(\"maxLength\"), r.EventRuler.on(n, \"input\", a.EventHandlers.inputFallBackEvent)), \n                        r.EventRuler.on(n, \"setvalue\", a.EventHandlers.setValueEvent), void 0 === e.applyMaskHook || e.applyMaskHook(), \n                        l.getBufferTemplate.call(e).join(\"\"), e.undoValue = e._valueGet(!0);\n                        var f = (n.inputmask.shadowRoot || n.ownerDocument).activeElement;\n                        if (\"\" !== n.inputmask._valueGet(!0) || !1 === t.clearMaskOnLostFocus || f === n) {\n                            (0, o.applyInputValue)(n, n.inputmask._valueGet(!0), t);\n                            var p = l.getBuffer.call(e).slice();\n                            !1 === s.isComplete.call(e, p) && t.clearIncomplete && l.resetMaskSet.call(e, !1), \n                            t.clearMaskOnLostFocus && f !== n && (-1 === l.getLastValidPosition.call(e) ? p = [] : o.clearOptionalTail.call(e, p)), \n                            (!1 === t.clearMaskOnLostFocus || t.showMaskOnFocus && f === n || \"\" !== n.inputmask._valueGet(!0)) && (0, \n                            o.writeBuffer)(n, p), f === n && l.caret.call(e, n, l.seekNext.call(e, l.getLastValidPosition.call(e)));\n                        }\n                    }\n                };\n                var i = n(9845), a = n(6030), r = n(9716), o = n(7760), l = n(8711), s = n(7215);\n            },\n            9695: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = function(e, t, n, i) {\n                    this.matches = [], this.openGroup = e || !1, this.alternatorGroup = !1, this.isGroup = e || !1, \n                    this.isOptional = t || !1, this.isQuantifier = n || !1, this.isAlternator = i || !1, \n                    this.quantifier = {\n                        min: 1,\n                        max: 1\n                    };\n                };\n            },\n            3194: function() {\n                Array.prototype.includes || Object.defineProperty(Array.prototype, \"includes\", {\n                    value: function(e, t) {\n                        if (null == this) throw new TypeError('\"this\" is null or not defined');\n                        var n = Object(this), i = n.length >>> 0;\n                        if (0 === i) return !1;\n                        for (var a = 0 | t, r = Math.max(a >= 0 ? a : i - Math.abs(a), 0); r < i; ) {\n                            if (n[r] === e) return !0;\n                            r++;\n                        }\n                        return !1;\n                    }\n                });\n            },\n            9302: function() {\n                var e = Function.bind.call(Function.call, Array.prototype.reduce), t = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable), n = Function.bind.call(Function.call, Array.prototype.concat), i = Object.keys;\n                Object.entries || (Object.entries = function(a) {\n                    return e(i(a), (function(e, i) {\n                        return n(e, \"string\" == typeof i && t(a, i) ? [ [ i, a[i] ] ] : []);\n                    }), []);\n                });\n            },\n            7149: function() {\n                function e(t) {\n                    return e = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    }, e(t);\n                }\n                \"function\" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = \"object\" === e(\"test\".__proto__) ? function(e) {\n                    return e.__proto__;\n                } : function(e) {\n                    return e.constructor.prototype;\n                });\n            },\n            4013: function() {\n                String.prototype.includes || (String.prototype.includes = function(e, t) {\n                    return \"number\" != typeof t && (t = 0), !(t + e.length > this.length) && -1 !== this.indexOf(e, t);\n                });\n            },\n            8711: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.caret = function(e, t, n, i, r) {\n                    var o, l = this, s = this.opts;\n                    if (void 0 === t) return \"selectionStart\" in e && \"selectionEnd\" in e ? (t = e.selectionStart, \n                    n = e.selectionEnd) : a.default.getSelection ? (o = a.default.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e && o.commonAncestorContainer !== e || (t = o.startOffset, \n                    n = o.endOffset) : document.selection && document.selection.createRange && (n = (t = 0 - (o = document.selection.createRange()).duplicate().moveStart(\"character\", -e.inputmask._valueGet().length)) + o.text.length), \n                    {\n                        begin: i ? t : f.call(l, t),\n                        end: i ? n : f.call(l, n)\n                    };\n                    if (Array.isArray(t) && (n = l.isRTL ? t[0] : t[1], t = l.isRTL ? t[1] : t[0]), \n                    void 0 !== t.begin && (n = l.isRTL ? t.begin : t.end, t = l.isRTL ? t.end : t.begin), \n                    \"number\" == typeof t) {\n                        t = i ? t : f.call(l, t), n = \"number\" == typeof (n = i ? n : f.call(l, n)) ? n : t;\n                        var c = parseInt(((e.ownerDocument.defaultView || a.default).getComputedStyle ? (e.ownerDocument.defaultView || a.default).getComputedStyle(e, null) : e.currentStyle).fontSize) * n;\n                        if (e.scrollLeft = c > e.scrollWidth ? c : 0, e.inputmask.caretPos = {\n                            begin: t,\n                            end: n\n                        }, s.insertModeVisual && !1 === s.insertMode && t === n && (r || n++), e === (e.inputmask.shadowRoot || e.ownerDocument).activeElement) {\n                            if (\"setSelectionRange\" in e) e.setSelectionRange(t, n); else if (a.default.getSelection) {\n                                if (o = document.createRange(), void 0 === e.firstChild || null === e.firstChild) {\n                                    var u = document.createTextNode(\"\");\n                                    e.appendChild(u);\n                                }\n                                o.setStart(e.firstChild, t < e.inputmask._valueGet().length ? t : e.inputmask._valueGet().length), \n                                o.setEnd(e.firstChild, n < e.inputmask._valueGet().length ? n : e.inputmask._valueGet().length), \n                                o.collapse(!0);\n                                var p = a.default.getSelection();\n                                p.removeAllRanges(), p.addRange(o);\n                            } else e.createTextRange && ((o = e.createTextRange()).collapse(!0), o.moveEnd(\"character\", n), \n                            o.moveStart(\"character\", t), o.select());\n                            void 0 === e.inputmask.caretHook || e.inputmask.caretHook.call(l, {\n                                begin: t,\n                                end: n\n                            });\n                        }\n                    }\n                }, t.determineLastRequiredPosition = function(e) {\n                    var t, n, i = this, a = i.maskset, l = i.dependencyLib, c = s.call(i), u = {}, f = a.validPositions[c], p = o.getMaskTemplate.call(i, !0, s.call(i), !0, !0), d = p.length, h = void 0 !== f ? f.locator.slice() : void 0;\n                    for (t = c + 1; t < p.length; t++) h = (n = o.getTestTemplate.call(i, t, h, t - 1)).locator.slice(), \n                    u[t] = l.extend(!0, {}, n);\n                    var v = f && void 0 !== f.alternation ? f.locator[f.alternation] : void 0;\n                    for (t = d - 1; t > c && (((n = u[t]).match.optionality || n.match.optionalQuantifier && n.match.newBlockMarker || v && (v !== u[t].locator[f.alternation] && !0 !== n.match.static || !0 === n.match.static && n.locator[f.alternation] && r.checkAlternationMatch.call(i, n.locator[f.alternation].toString().split(\",\"), v.toString().split(\",\")) && \"\" !== o.getTests.call(i, t)[0].def)) && p[t] === o.getPlaceholder.call(i, t, n.match)); t--) d--;\n                    return e ? {\n                        l: d,\n                        def: u[d] ? u[d].match : void 0\n                    } : d;\n                }, t.determineNewCaretPosition = function(e, t, n) {\n                    var i, a, r, f = this, p = f.maskset, d = f.opts;\n                    t && (f.isRTL ? e.end = e.begin : e.begin = e.end);\n                    if (e.begin === e.end) {\n                        switch (n = n || d.positionCaretOnClick) {\n                          case \"none\":\n                            break;\n\n                          case \"select\":\n                            e = {\n                                begin: 0,\n                                end: l.call(f).length\n                            };\n                            break;\n\n                          case \"ignore\":\n                            e.end = e.begin = u.call(f, s.call(f));\n                            break;\n\n                          case \"radixFocus\":\n                            if (f.clicked > 1 && 0 === p.validPositions.length) break;\n                            if (function(e) {\n                                if (\"\" !== d.radixPoint && 0 !== d.digits) {\n                                    var t = p.validPositions;\n                                    if (void 0 === t[e] || void 0 === t[e].input) {\n                                        if (e < u.call(f, -1)) return !0;\n                                        var n = l.call(f).indexOf(d.radixPoint);\n                                        if (-1 !== n) {\n                                            for (var i = 0, a = t.length; i < a; i++) if (t[i] && n < i && t[i].input !== o.getPlaceholder.call(f, i)) return !1;\n                                            return !0;\n                                        }\n                                    }\n                                }\n                                return !1;\n                            }(e.begin)) {\n                                var h = l.call(f).join(\"\").indexOf(d.radixPoint);\n                                e.end = e.begin = d.numericInput ? u.call(f, h) : h;\n                                break;\n                            }\n\n                          default:\n                            if (i = e.begin, a = s.call(f, i, !0), i <= (r = u.call(f, -1 !== a || c.call(f, 0) ? a : -1))) e.end = e.begin = c.call(f, i, !1, !0) ? i : u.call(f, i); else {\n                                var v = p.validPositions[a], m = o.getTestTemplate.call(f, r, v ? v.match.locator : void 0, v), g = o.getPlaceholder.call(f, r, m.match);\n                                if (\"\" !== g && l.call(f)[r] !== g && !0 !== m.match.optionalQuantifier && !0 !== m.match.newBlockMarker || !c.call(f, r, d.keepStatic, !0) && m.match.def === g) {\n                                    var y = u.call(f, r);\n                                    (i >= y || i === r) && (r = y);\n                                }\n                                e.end = e.begin = r;\n                            }\n                        }\n                        return e;\n                    }\n                }, t.getBuffer = l, t.getBufferTemplate = function() {\n                    var e = this.maskset;\n                    void 0 === e._buffer && (e._buffer = o.getMaskTemplate.call(this, !1, 1), void 0 === e.buffer && (e.buffer = e._buffer.slice()));\n                    return e._buffer;\n                }, t.getLastValidPosition = s, t.isMask = c, t.resetMaskSet = function(e) {\n                    var t = this.maskset;\n                    t.buffer = void 0, !0 !== e && (t.validPositions = [], t.p = 0);\n                    !1 === e && (t.tests = {}, t.jitOffset = {});\n                }, t.seekNext = u, t.seekPrevious = function(e, t) {\n                    var n = this, i = e - 1;\n                    if (e <= 0) return 0;\n                    for (;i > 0 && (!0 === t && (!0 !== o.getTest.call(n, i).match.newBlockMarker || !c.call(n, i, void 0, !0)) || !0 !== t && !c.call(n, i, void 0, !0)); ) i--;\n                    return i;\n                }, t.translatePosition = f;\n                var i, a = (i = n(9380)) && i.__esModule ? i : {\n                    default: i\n                }, r = n(7215), o = n(4713);\n                function l(e) {\n                    var t = this, n = t.maskset;\n                    return void 0 !== n.buffer && !0 !== e || (n.buffer = o.getMaskTemplate.call(t, !0, s.call(t), !0), \n                    void 0 === n._buffer && (n._buffer = n.buffer.slice())), n.buffer;\n                }\n                function s(e, t, n) {\n                    var i = this.maskset, a = -1, r = -1, o = n || i.validPositions;\n                    void 0 === e && (e = -1);\n                    for (var l = 0, s = o.length; l < s; l++) o[l] && (t || !0 !== o[l].generatedInput) && (l <= e && (a = l), \n                    l >= e && (r = l));\n                    return -1 === a || a === e ? r : -1 === r || e - a < r - e ? a : r;\n                }\n                function c(e, t, n) {\n                    var i = this, a = this.maskset, r = o.getTestTemplate.call(i, e).match;\n                    if (\"\" === r.def && (r = o.getTest.call(i, e).match), !0 !== r.static) return r.fn;\n                    if (!0 === n && void 0 !== a.validPositions[e] && !0 !== a.validPositions[e].generatedInput) return !0;\n                    if (!0 !== t && e > -1) {\n                        if (n) {\n                            var l = o.getTests.call(i, e);\n                            return l.length > 1 + (\"\" === l[l.length - 1].match.def ? 1 : 0);\n                        }\n                        var s = o.determineTestTemplate.call(i, e, o.getTests.call(i, e)), c = o.getPlaceholder.call(i, e, s.match);\n                        return s.match.def !== c;\n                    }\n                    return !1;\n                }\n                function u(e, t, n) {\n                    var i = this;\n                    void 0 === n && (n = !0);\n                    for (var a = e + 1; \"\" !== o.getTest.call(i, a).match.def && (!0 === t && (!0 !== o.getTest.call(i, a).match.newBlockMarker || !c.call(i, a, void 0, !0)) || !0 !== t && !c.call(i, a, void 0, n)); ) a++;\n                    return a;\n                }\n                function f(e) {\n                    var t = this.opts, n = this.el;\n                    return !this.isRTL || \"number\" != typeof e || t.greedy && \"\" === t.placeholder || !n || (e = this._valueGet().length - e) < 0 && (e = 0), \n                    e;\n                }\n            },\n            4713: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.determineTestTemplate = f, t.getDecisionTaker = s, t.getMaskTemplate = function(e, t, n, i, a) {\n                    var r = this, o = this.opts, l = this.maskset, s = o.greedy;\n                    a && o.greedy && (o.greedy = !1, r.maskset.tests = {});\n                    t = t || 0;\n                    var p, d, v, m, g = [], y = 0;\n                    do {\n                        if (!0 === e && l.validPositions[y]) d = (v = a && l.validPositions[y].match.optionality && void 0 === l.validPositions[y + 1] && (!0 === l.validPositions[y].generatedInput || l.validPositions[y].input == o.skipOptionalPartCharacter && y > 0) ? f.call(r, y, h.call(r, y, p, y - 1)) : l.validPositions[y]).match, \n                        p = v.locator.slice(), g.push(!0 === n ? v.input : !1 === n ? d.nativeDef : c.call(r, y, d)); else {\n                            d = (v = u.call(r, y, p, y - 1)).match, p = v.locator.slice();\n                            var k = !0 !== i && (!1 !== o.jitMasking ? o.jitMasking : d.jit);\n                            (m = (m || l.validPositions[y - 1]) && d.static && d.def !== o.groupSeparator && null === d.fn) || !1 === k || void 0 === k || \"number\" == typeof k && isFinite(k) && k > y ? g.push(!1 === n ? d.nativeDef : c.call(r, g.length, d)) : m = !1;\n                        }\n                        y++;\n                    } while (!0 !== d.static || \"\" !== d.def || t > y);\n                    \"\" === g[g.length - 1] && g.pop();\n                    !1 === n && void 0 !== l.maskLength || (l.maskLength = y - 1);\n                    return o.greedy = s, g;\n                }, t.getPlaceholder = c, t.getTest = p, t.getTestTemplate = u, t.getTests = h, t.isSubsetOf = d;\n                var i, a = (i = n(2394)) && i.__esModule ? i : {\n                    default: i\n                }, r = n(8711);\n                function o(e) {\n                    return o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    }, o(e);\n                }\n                function l(e, t) {\n                    var n = (null != e.alternation ? e.mloc[s(e)] : e.locator).join(\"\");\n                    if (\"\" !== n) for (n = n.split(\":\")[0]; n.length < t; ) n += \"0\";\n                    return n;\n                }\n                function s(e) {\n                    var t = e.locator[e.alternation];\n                    return \"string\" == typeof t && t.length > 0 && (t = t.split(\",\")[0]), void 0 !== t ? t.toString() : \"\";\n                }\n                function c(e, t, n) {\n                    var i = this, a = this.opts, l = this.maskset;\n                    if (void 0 !== (t = t || p.call(i, e).match).placeholder || !0 === n) {\n                        if (\"\" !== t.placeholder && !0 === t.static && !0 !== t.generated) {\n                            var s = r.getLastValidPosition.call(i, e), c = r.seekNext.call(i, s);\n                            return (n ? e <= c : e < c) ? a.staticDefinitionSymbol && t.static ? t.nativeDef : t.def : \"function\" == typeof t.placeholder ? t.placeholder(a) : t.placeholder;\n                        }\n                        return \"function\" == typeof t.placeholder ? t.placeholder(a) : t.placeholder;\n                    }\n                    if (!0 === t.static) {\n                        if (e > -1 && void 0 === l.validPositions[e]) {\n                            var u, f = h.call(i, e), d = [];\n                            if (\"string\" == typeof a.placeholder && f.length > 1 + (\"\" === f[f.length - 1].match.def ? 1 : 0)) for (var v = 0; v < f.length; v++) if (\"\" !== f[v].match.def && !0 !== f[v].match.optionality && !0 !== f[v].match.optionalQuantifier && (!0 === f[v].match.static || void 0 === u || !1 !== f[v].match.fn.test(u.match.def, l, e, !0, a)) && (d.push(f[v]), \n                            !0 === f[v].match.static && (u = f[v]), d.length > 1 && /[0-9a-bA-Z]/.test(d[0].match.def))) return a.placeholder.charAt(e % a.placeholder.length);\n                        }\n                        return t.def;\n                    }\n                    return \"object\" === o(a.placeholder) ? t.def : a.placeholder.charAt(e % a.placeholder.length);\n                }\n                function u(e, t, n) {\n                    return this.maskset.validPositions[e] || f.call(this, e, h.call(this, e, t ? t.slice() : t, n));\n                }\n                function f(e, t) {\n                    var n = this.opts, i = 0, a = function(e, t) {\n                        var n = 0, i = !1;\n                        t.forEach((function(e) {\n                            e.match.optionality && (0 !== n && n !== e.match.optionality && (i = !0), (0 === n || n > e.match.optionality) && (n = e.match.optionality));\n                        })), n && (0 == e || 1 == t.length ? n = 0 : i || (n = 0));\n                        return n;\n                    }(e, t);\n                    e = e > 0 ? e - 1 : 0;\n                    var r, o, s, c = l(p.call(this, e));\n                    n.greedy && t.length > 1 && \"\" === t[t.length - 1].match.def && (i = 1);\n                    for (var u = 0; u < t.length - i; u++) {\n                        var f = t[u];\n                        r = l(f, c.length);\n                        var d = Math.abs(r - c);\n                        (!0 !== f.unMatchedAlternationStopped || t.filter((function(e) {\n                            return !0 !== e.unMatchedAlternationStopped;\n                        })).length <= 1) && (void 0 === o || \"\" !== r && d < o || s && !n.greedy && s.match.optionality && s.match.optionality - a > 0 && \"master\" === s.match.newBlockMarker && (!f.match.optionality || f.match.optionality - a < 1 || !f.match.newBlockMarker) || s && !n.greedy && s.match.optionalQuantifier && !f.match.optionalQuantifier) && (o = d, \n                        s = f);\n                    }\n                    return s;\n                }\n                function p(e, t) {\n                    var n = this.maskset;\n                    return n.validPositions[e] ? n.validPositions[e] : (t || h.call(this, e))[0];\n                }\n                function d(e, t, n) {\n                    function i(e) {\n                        for (var t, n = [], i = -1, a = 0, r = e.length; a < r; a++) if (\"-\" === e.charAt(a)) for (t = e.charCodeAt(a + 1); ++i < t; ) n.push(String.fromCharCode(i)); else i = e.charCodeAt(a), \n                        n.push(e.charAt(a));\n                        return n.join(\"\");\n                    }\n                    return e.match.def === t.match.nativeDef || !(!(n.regex || e.match.fn instanceof RegExp && t.match.fn instanceof RegExp) || !0 === e.match.static || !0 === t.match.static) && (\".\" === t.match.fn.source || -1 !== i(t.match.fn.source.replace(/[[\\]/]/g, \"\")).indexOf(i(e.match.fn.source.replace(/[[\\]/]/g, \"\"))));\n                }\n                function h(e, t, n) {\n                    var i, r, o = this, l = this.dependencyLib, s = this.maskset, c = this.opts, u = this.el, p = s.maskToken, h = t ? n : 0, v = t ? t.slice() : [ 0 ], m = [], g = !1, y = t ? t.join(\"\") : \"\", k = !1;\n                    function b(t, n, r, l) {\n                        function f(r, l, p) {\n                            function v(e, t) {\n                                var n = 0 === t.matches.indexOf(e);\n                                return n || t.matches.every((function(i, a) {\n                                    return !0 === i.isQuantifier ? n = v(e, t.matches[a - 1]) : Object.prototype.hasOwnProperty.call(i, \"matches\") && (n = v(e, i)), \n                                    !n;\n                                })), n;\n                            }\n                            function w(e, t, n) {\n                                var i, a;\n                                if ((s.tests[e] || s.validPositions[e]) && (s.validPositions[e] ? [ s.validPositions[e] ] : s.tests[e]).every((function(e, r) {\n                                    if (e.mloc[t]) return i = e, !1;\n                                    var o = void 0 !== n ? n : e.alternation, l = void 0 !== e.locator[o] ? e.locator[o].toString().indexOf(t) : -1;\n                                    return (void 0 === a || l < a) && -1 !== l && (i = e, a = l), !0;\n                                })), i) {\n                                    var r = i.locator[i.alternation], o = i.mloc[t] || i.mloc[r] || i.locator;\n                                    if (-1 !== o[o.length - 1].toString().indexOf(\":\")) o.pop();\n                                    return o.slice((void 0 !== n ? n : i.alternation) + 1);\n                                }\n                                return void 0 !== n ? w(e, t) : void 0;\n                            }\n                            function P(t, n) {\n                                return !0 === t.match.static && !0 !== n.match.static && n.match.fn.test(t.match.def, s, e, !1, c, !1);\n                            }\n                            function S(e, t) {\n                                var n = e.alternation, i = void 0 === t || n <= t.alternation && -1 === e.locator[n].toString().indexOf(t.locator[n]);\n                                if (!i && n > t.alternation) for (var a = 0; a < n; a++) if (e.locator[a] !== t.locator[a]) {\n                                    n = a, i = !0;\n                                    break;\n                                }\n                                return !!i && function(n) {\n                                    e.mloc = e.mloc || {};\n                                    var i = e.locator[n];\n                                    if (void 0 !== i) {\n                                        if (\"string\" == typeof i && (i = i.split(\",\")[0]), void 0 === e.mloc[i] && (e.mloc[i] = e.locator.slice(), \n                                        e.mloc[i].push(\":\".concat(e.alternation))), void 0 !== t) {\n                                            for (var a in t.mloc) \"string\" == typeof a && (a = parseInt(a.split(\",\")[0])), e.mloc[a + 0] = t.mloc[a];\n                                            e.locator[n] = Object.keys(e.mloc).join(\",\");\n                                        }\n                                        return e.alternation > n && (e.alternation = n), !0;\n                                    }\n                                    return e.alternation = void 0, !1;\n                                }(n);\n                            }\n                            function O(e, t) {\n                                if (e.locator.length !== t.locator.length) return !1;\n                                for (var n = e.alternation + 1; n < e.locator.length; n++) if (e.locator[n] !== t.locator[n]) return !1;\n                                return !0;\n                            }\n                            if (h > e + c._maxTestPos) throw new Error(\"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \".concat(s.mask));\n                            if (h === e && void 0 === r.matches) {\n                                if (m.push({\n                                    match: r,\n                                    locator: l.reverse(),\n                                    cd: y,\n                                    mloc: {}\n                                }), !r.optionality || void 0 !== p || !(c.definitions && c.definitions[r.nativeDef] && c.definitions[r.nativeDef].optional || a.default.prototype.definitions[r.nativeDef] && a.default.prototype.definitions[r.nativeDef].optional)) return !0;\n                                g = !0, h = e;\n                            } else if (void 0 !== r.matches) {\n                                if (r.isGroup && p !== r) return function() {\n                                    if (r = f(t.matches[t.matches.indexOf(r) + 1], l, p)) return !0;\n                                }();\n                                if (r.isOptional) return function() {\n                                    var t = r, a = m.length;\n                                    if (r = b(r, n, l, p), m.length > 0) {\n                                        if (m.forEach((function(e, t) {\n                                            t >= a && (e.match.optionality = e.match.optionality ? e.match.optionality + 1 : 1);\n                                        })), i = m[m.length - 1].match, void 0 !== p || !v(i, t)) return r;\n                                        g = !0, h = e;\n                                    }\n                                }();\n                                if (r.isAlternator) return function() {\n                                    function i(e) {\n                                        for (var t, n = e.matches[0].matches ? e.matches[0].matches.length : 1, i = 0; i < e.matches.length && n === (t = e.matches[i].matches ? e.matches[i].matches.length : 1); i++) ;\n                                        return n !== t;\n                                    }\n                                    o.hasAlternator = !0;\n                                    var a, v = r, y = [], b = m.slice(), x = l.length, _ = n.length > 0 ? n.shift() : -1;\n                                    if (-1 === _ || \"string\" == typeof _) {\n                                        var M, E = h, j = n.slice(), T = [];\n                                        if (\"string\" == typeof _) T = _.split(\",\"); else for (M = 0; M < v.matches.length; M++) T.push(M.toString());\n                                        if (void 0 !== s.excludes[e]) {\n                                            for (var A = T.slice(), D = 0, L = s.excludes[e].length; D < L; D++) {\n                                                var C = s.excludes[e][D].toString().split(\":\");\n                                                l.length == C[1] && T.splice(T.indexOf(C[0]), 1);\n                                            }\n                                            0 === T.length && (delete s.excludes[e], T = A);\n                                        }\n                                        (!0 === c.keepStatic || isFinite(parseInt(c.keepStatic)) && E >= c.keepStatic) && (T = T.slice(0, 1));\n                                        for (var B = 0; B < T.length; B++) {\n                                            M = parseInt(T[B]), m = [], n = \"string\" == typeof _ && w(h, M, x) || j.slice();\n                                            var I = v.matches[M];\n                                            if (I && f(I, [ M ].concat(l), p)) r = !0; else if (0 === B && (k = i(v)), I && I.matches && I.matches.length > v.matches[0].matches.length) break;\n                                            a = m.slice(), h = E, m = [];\n                                            for (var R = 0; R < a.length; R++) {\n                                                var F = a[R], N = !1;\n                                                F.alternation = F.alternation || x, S(F);\n                                                for (var V = 0; V < y.length; V++) {\n                                                    var G = y[V];\n                                                    if (\"string\" != typeof _ || void 0 !== F.alternation && T.includes(F.locator[F.alternation].toString())) {\n                                                        if (F.match.nativeDef === G.match.nativeDef) {\n                                                            N = !0, S(G, F);\n                                                            break;\n                                                        }\n                                                        if (d(F, G, c)) {\n                                                            S(F, G) && (N = !0, y.splice(y.indexOf(G), 0, F));\n                                                            break;\n                                                        }\n                                                        if (d(G, F, c)) {\n                                                            S(G, F);\n                                                            break;\n                                                        }\n                                                        if (P(F, G)) {\n                                                            O(F, G) || void 0 !== u.inputmask.userOptions.keepStatic ? S(F, G) && (N = !0, y.splice(y.indexOf(G), 0, F)) : c.keepStatic = !0;\n                                                            break;\n                                                        }\n                                                        if (P(G, F)) {\n                                                            S(G, F);\n                                                            break;\n                                                        }\n                                                    }\n                                                }\n                                                N || y.push(F);\n                                            }\n                                        }\n                                        m = b.concat(y), h = e, g = m.length > 0 && k, r = y.length > 0 && !k, k && g && !r && m.forEach((function(e, t) {\n                                            e.unMatchedAlternationStopped = !0;\n                                        })), n = j.slice();\n                                    } else r = f(v.matches[_] || t.matches[_], [ _ ].concat(l), p);\n                                    if (r) return !0;\n                                }();\n                                if (r.isQuantifier && p !== t.matches[t.matches.indexOf(r) - 1]) return function() {\n                                    for (var a = r, o = !1, u = n.length > 0 ? n.shift() : 0; u < (isNaN(a.quantifier.max) ? u + 1 : a.quantifier.max) && h <= e; u++) {\n                                        var p = t.matches[t.matches.indexOf(a) - 1];\n                                        if (r = f(p, [ u ].concat(l), p)) {\n                                            if (m.forEach((function(t, n) {\n                                                (i = x(p, t.match) ? t.match : m[m.length - 1].match).optionalQuantifier = u >= a.quantifier.min, \n                                                i.jit = (u + 1) * (p.matches.indexOf(i) + 1) > a.quantifier.jit, i.optionalQuantifier && v(i, p) && (g = !0, \n                                                h = e, c.greedy && null == s.validPositions[e - 1] && u > a.quantifier.min && -1 != [ \"*\", \"+\" ].indexOf(a.quantifier.max) && (m.pop(), \n                                                y = void 0), o = !0, r = !1), !o && i.jit && (s.jitOffset[e] = p.matches.length - p.matches.indexOf(i));\n                                            })), o) break;\n                                            return !0;\n                                        }\n                                    }\n                                }();\n                                if (r = b(r, n, l, p)) return !0;\n                            } else h++;\n                        }\n                        for (var p = n.length > 0 ? n.shift() : 0; p < t.matches.length; p++) if (!0 !== t.matches[p].isQuantifier) {\n                            var v = f(t.matches[p], [ p ].concat(r), l);\n                            if (v && h === e) return v;\n                            if (h > e) break;\n                        }\n                    }\n                    function x(e, t) {\n                        var n = -1 != e.matches.indexOf(t);\n                        return n || e.matches.forEach((function(e, i) {\n                            void 0 === e.matches || n || (n = x(e, t));\n                        })), n;\n                    }\n                    if (e > -1) {\n                        if (void 0 === t) {\n                            for (var w, P = e - 1; void 0 === (w = s.validPositions[P] || s.tests[P]) && P > -1; ) P--;\n                            void 0 !== w && P > -1 && (v = function(e, t) {\n                                var n, i = [];\n                                return Array.isArray(t) || (t = [ t ]), t.length > 0 && (void 0 === t[0].alternation || !0 === c.keepStatic ? 0 === (i = f.call(o, e, t.slice()).locator.slice()).length && (i = t[0].locator.slice()) : t.forEach((function(e) {\n                                    \"\" !== e.def && (0 === i.length ? (n = e.alternation, i = e.locator.slice()) : e.locator[n] && -1 === i[n].toString().indexOf(e.locator[n]) && (i[n] += \",\" + e.locator[n]));\n                                }))), i;\n                            }(P, w), y = v.join(\"\"), h = P);\n                        }\n                        if (s.tests[e] && s.tests[e][0].cd === y) return s.tests[e];\n                        for (var S = v.shift(); S < p.length; S++) {\n                            if (b(p[S], v, [ S ]) && h === e || h > e) break;\n                        }\n                    }\n                    return (0 === m.length || g) && m.push({\n                        match: {\n                            fn: null,\n                            static: !0,\n                            optionality: !1,\n                            casing: null,\n                            def: \"\",\n                            placeholder: \"\"\n                        },\n                        locator: k && 0 === m.filter((function(e) {\n                            return !0 !== e.unMatchedAlternationStopped;\n                        })).length ? [ 0 ] : [],\n                        mloc: {},\n                        cd: y\n                    }), void 0 !== t && s.tests[e] ? r = l.extend(!0, [], m) : (s.tests[e] = l.extend(!0, [], m), \n                    r = s.tests[e]), m.forEach((function(e) {\n                        e.match.optionality = e.match.defOptionality || !1;\n                    })), r;\n                }\n            },\n            7215: function(e, t, n) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.alternate = l, t.checkAlternationMatch = function(e, t, n) {\n                    for (var i, a = this.opts.greedy ? t : t.slice(0, 1), r = !1, o = void 0 !== n ? n.split(\",\") : [], l = 0; l < o.length; l++) -1 !== (i = e.indexOf(o[l])) && e.splice(i, 1);\n                    for (var s = 0; s < e.length; s++) if (a.includes(e[s])) {\n                        r = !0;\n                        break;\n                    }\n                    return r;\n                }, t.handleRemove = function(e, t, n, i, s) {\n                    var c = this, u = this.maskset, f = this.opts;\n                    if ((f.numericInput || c.isRTL) && (t === a.keys.Backspace ? t = a.keys.Delete : t === a.keys.Delete && (t = a.keys.Backspace), \n                    c.isRTL)) {\n                        var p = n.end;\n                        n.end = n.begin, n.begin = p;\n                    }\n                    var d, h = r.getLastValidPosition.call(c, void 0, !0);\n                    n.end >= r.getBuffer.call(c).length && h >= n.end && (n.end = h + 1);\n                    t === a.keys.Backspace ? n.end - n.begin < 1 && (n.begin = r.seekPrevious.call(c, n.begin)) : t === a.keys.Delete && n.begin === n.end && (n.end = r.isMask.call(c, n.end, !0, !0) ? n.end + 1 : r.seekNext.call(c, n.end) + 1);\n                    !1 !== (d = v.call(c, n)) && ((!0 !== i && !1 !== f.keepStatic || null !== f.regex && -1 !== o.getTest.call(c, n.begin).match.def.indexOf(\"|\")) && l.call(c, !0), \n                    !0 !== i && (u.p = t === a.keys.Delete ? n.begin + d : n.begin, u.p = r.determineNewCaretPosition.call(c, {\n                        begin: u.p,\n                        end: u.p\n                    }, !1, !1 === f.insertMode && t === a.keys.Backspace ? \"none\" : void 0).begin));\n                }, t.isComplete = c, t.isSelection = u, t.isValid = f, t.refreshFromBuffer = d, \n                t.revalidateMask = v;\n                var i = n(6030), a = n(2839), r = n(8711), o = n(4713);\n                function l(e, t, n, i, a, s) {\n                    var c = this, u = this.dependencyLib, p = this.opts, d = c.maskset;\n                    if (!c.hasAlternator) return !1;\n                    var h, v, m, g, y, k, b, x, w, P, S, O = u.extend(!0, [], d.validPositions), _ = u.extend(!0, {}, d.tests), M = !1, E = !1, j = void 0 !== a ? a : r.getLastValidPosition.call(c);\n                    if (s && (P = s.begin, S = s.end, s.begin > s.end && (P = s.end, S = s.begin)), \n                    -1 === j && void 0 === a) h = 0, v = (g = o.getTest.call(c, h)).alternation; else for (;j >= 0; j--) if ((m = d.validPositions[j]) && void 0 !== m.alternation) {\n                        if (j <= (e || 0) && g && g.locator[m.alternation] !== m.locator[m.alternation]) break;\n                        h = j, v = d.validPositions[h].alternation, g = m;\n                    }\n                    if (void 0 !== v) {\n                        b = parseInt(h), d.excludes[b] = d.excludes[b] || [], !0 !== e && d.excludes[b].push((0, \n                        o.getDecisionTaker)(g) + \":\" + g.alternation);\n                        var T = [], A = -1;\n                        for (y = b; b < r.getLastValidPosition.call(c, void 0, !0) + 1; y++) -1 === A && e <= y && void 0 !== t && (T.push(t), \n                        A = T.length - 1), (k = d.validPositions[b]) && !0 !== k.generatedInput && (void 0 === s || y < P || y >= S) && T.push(k.input), \n                        d.validPositions.splice(b, 1);\n                        for (-1 === A && void 0 !== t && (T.push(t), A = T.length - 1); void 0 !== d.excludes[b] && d.excludes[b].length < 10; ) {\n                            for (d.tests = {}, r.resetMaskSet.call(c, !0), M = !0, y = 0; y < T.length && (x = M.caret || 0 == p.insertMode && null != x ? r.seekNext.call(c, x) : r.getLastValidPosition.call(c, void 0, !0) + 1, \n                            w = T[y], M = f.call(c, x, w, !1, i, !0)); y++) y === A && (E = M), 1 == e && M && (E = {\n                                caretPos: y\n                            });\n                            if (M) break;\n                            if (r.resetMaskSet.call(c), g = o.getTest.call(c, b), d.validPositions = u.extend(!0, [], O), \n                            d.tests = u.extend(!0, {}, _), !d.excludes[b]) {\n                                E = l.call(c, e, t, n, i, b - 1, s);\n                                break;\n                            }\n                            if (null != g.alternation) {\n                                var D = (0, o.getDecisionTaker)(g);\n                                if (-1 !== d.excludes[b].indexOf(D + \":\" + g.alternation)) {\n                                    E = l.call(c, e, t, n, i, b - 1, s);\n                                    break;\n                                }\n                                for (d.excludes[b].push(D + \":\" + g.alternation), y = b; y < r.getLastValidPosition.call(c, void 0, !0) + 1; y++) d.validPositions.splice(b);\n                            } else delete d.excludes[b];\n                        }\n                    }\n                    return E && !1 === p.keepStatic || delete d.excludes[b], E;\n                }\n                function s(e, t, n) {\n                    var i = this.opts, r = this.maskset;\n                    switch (i.casing || t.casing) {\n                      case \"upper\":\n                        e = e.toUpperCase();\n                        break;\n\n                      case \"lower\":\n                        e = e.toLowerCase();\n                        break;\n\n                      case \"title\":\n                        var o = r.validPositions[n - 1];\n                        e = 0 === n || o && o.input === String.fromCharCode(a.keyCode.Space) ? e.toUpperCase() : e.toLowerCase();\n                        break;\n\n                      default:\n                        if (\"function\" == typeof i.casing) {\n                            var l = Array.prototype.slice.call(arguments);\n                            l.push(r.validPositions), e = i.casing.apply(this, l);\n                        }\n                    }\n                    return e;\n                }\n                function c(e) {\n                    var t = this, n = this.opts, i = this.maskset;\n                    if (\"function\" == typeof n.isComplete) return n.isComplete(e, n);\n                    if (\"*\" !== n.repeat) {\n                        var a = !1, l = r.determineLastRequiredPosition.call(t, !0), s = l.l;\n                        if (void 0 === l.def || l.def.newBlockMarker || l.def.optionality || l.def.optionalQuantifier) {\n                            a = !0;\n                            for (var c = 0; c <= s; c++) {\n                                var u = o.getTestTemplate.call(t, c).match;\n                                if (!0 !== u.static && void 0 === i.validPositions[c] && (!1 === u.optionality || void 0 === u.optionality || u.optionality && 0 == u.newBlockMarker) && (!1 === u.optionalQuantifier || void 0 === u.optionalQuantifier) || !0 === u.static && \"\" != u.def && e[c] !== o.getPlaceholder.call(t, c, u)) {\n                                    a = !1;\n                                    break;\n                                }\n                            }\n                        }\n                        return a;\n                    }\n                }\n                function u(e) {\n                    var t = this.opts.insertMode ? 0 : 1;\n                    return this.isRTL ? e.begin - e.end > t : e.end - e.begin > t;\n                }\n                function f(e, t, n, i, a, p, m) {\n                    var g = this, y = this.dependencyLib, k = this.opts, b = g.maskset;\n                    n = !0 === n;\n                    var x = e;\n                    function w(e) {\n                        if (void 0 !== e) {\n                            if (void 0 !== e.remove && (Array.isArray(e.remove) || (e.remove = [ e.remove ]), \n                            e.remove.sort((function(e, t) {\n                                return g.isRTL ? e.pos - t.pos : t.pos - e.pos;\n                            })).forEach((function(e) {\n                                v.call(g, {\n                                    begin: e,\n                                    end: e + 1\n                                });\n                            })), e.remove = void 0), void 0 !== e.insert && (Array.isArray(e.insert) || (e.insert = [ e.insert ]), \n                            e.insert.sort((function(e, t) {\n                                return g.isRTL ? t.pos - e.pos : e.pos - t.pos;\n                            })).forEach((function(e) {\n                                \"\" !== e.c && f.call(g, e.pos, e.c, void 0 === e.strict || e.strict, void 0 !== e.fromIsValid ? e.fromIsValid : i);\n                            })), e.insert = void 0), e.refreshFromBuffer && e.buffer) {\n                                var t = e.refreshFromBuffer;\n                                d.call(g, !0 === t ? t : t.start, t.end, e.buffer), e.refreshFromBuffer = void 0;\n                            }\n                            void 0 !== e.rewritePosition && (x = e.rewritePosition, e = !0);\n                        }\n                        return e;\n                    }\n                    function P(t, n, a) {\n                        var l = !1;\n                        return o.getTests.call(g, t).every((function(c, f) {\n                            var p = c.match;\n                            if (r.getBuffer.call(g, !0), !1 !== (l = (!p.jit || void 0 !== b.validPositions[r.seekPrevious.call(g, t)]) && (null != p.fn ? p.fn.test(n, b, t, a, k, u.call(g, e)) : (n === p.def || n === k.skipOptionalPartCharacter) && \"\" !== p.def && {\n                                c: o.getPlaceholder.call(g, t, p, !0) || p.def,\n                                pos: t\n                            }))) {\n                                var d = void 0 !== l.c ? l.c : n, h = t;\n                                return d = d === k.skipOptionalPartCharacter && !0 === p.static ? o.getPlaceholder.call(g, t, p, !0) || p.def : d, \n                                !0 !== (l = w(l)) && void 0 !== l.pos && l.pos !== t && (h = l.pos), !0 !== l && void 0 === l.pos && void 0 === l.c ? !1 : (!1 === v.call(g, e, y.extend({}, c, {\n                                    input: s.call(g, d, p, h)\n                                }), i, h) && (l = !1), !1);\n                            }\n                            return !0;\n                        })), l;\n                    }\n                    void 0 !== e.begin && (x = g.isRTL ? e.end : e.begin);\n                    var S = !0, O = y.extend(!0, [], b.validPositions);\n                    if (!1 === k.keepStatic && void 0 !== b.excludes[x] && !0 !== a && !0 !== i) for (var _ = x; _ < (g.isRTL ? e.begin : e.end); _++) void 0 !== b.excludes[_] && (b.excludes[_] = void 0, \n                    delete b.tests[_]);\n                    if (\"function\" == typeof k.preValidation && !0 !== i && !0 !== p && (S = w(S = k.preValidation.call(g, r.getBuffer.call(g), x, t, u.call(g, e), k, b, e, n || a))), \n                    !0 === S) {\n                        if (S = P(x, t, n), (!n || !0 === i) && !1 === S && !0 !== p) {\n                            var M = b.validPositions[x];\n                            if (!M || !0 !== M.match.static || M.match.def !== t && t !== k.skipOptionalPartCharacter) {\n                                if (k.insertMode || void 0 === b.validPositions[r.seekNext.call(g, x)] || e.end > x) {\n                                    var E = !1;\n                                    if (b.jitOffset[x] && void 0 === b.validPositions[r.seekNext.call(g, x)] && !1 !== (S = f.call(g, x + b.jitOffset[x], t, !0, !0)) && (!0 !== a && (S.caret = x), \n                                    E = !0), e.end > x && (b.validPositions[x] = void 0), !E && !r.isMask.call(g, x, k.keepStatic && 0 === x)) for (var j = x + 1, T = r.seekNext.call(g, x, !1, 0 !== x); j <= T; j++) if (!1 !== (S = P(j, t, n))) {\n                                        S = h.call(g, x, void 0 !== S.pos ? S.pos : j) || S, x = j;\n                                        break;\n                                    }\n                                }\n                            } else S = {\n                                caret: r.seekNext.call(g, x)\n                            };\n                        }\n                        g.hasAlternator && !0 !== a && !n && (a = !0, !1 === S && k.keepStatic && (c.call(g, r.getBuffer.call(g)) || 0 === x) ? S = l.call(g, x, t, n, i, void 0, e) : (u.call(g, e) && b.tests[x] && b.tests[x].length > 1 && k.keepStatic || 1 == S && !0 !== k.numericInput && b.tests[x] && b.tests[x].length > 1 && r.getLastValidPosition.call(g, void 0, !0) > x) && (S = l.call(g, !0))), \n                        !0 === S && (S = {\n                            pos: x\n                        });\n                    }\n                    if (\"function\" == typeof k.postValidation && !0 !== i && !0 !== p) {\n                        var A = k.postValidation.call(g, r.getBuffer.call(g, !0), void 0 !== e.begin ? g.isRTL ? e.end : e.begin : e, t, S, k, b, n, m);\n                        void 0 !== A && (S = !0 === A ? S : A);\n                    }\n                    S && void 0 === S.pos && (S.pos = x), !1 === S || !0 === p ? (r.resetMaskSet.call(g, !0), \n                    b.validPositions = y.extend(!0, [], O)) : h.call(g, void 0, x, !0);\n                    var D = w(S);\n                    void 0 !== g.maxLength && (r.getBuffer.call(g).length > g.maxLength && !i && (r.resetMaskSet.call(g, !0), \n                    b.validPositions = y.extend(!0, [], O), D = !1));\n                    return D;\n                }\n                function p(e, t, n) {\n                    for (var i = this.maskset, a = !1, r = o.getTests.call(this, e), l = 0; l < r.length; l++) {\n                        if (r[l].match && (r[l].match.nativeDef === t.match[n.shiftPositions ? \"def\" : \"nativeDef\"] && (!n.shiftPositions || !t.match.static) || r[l].match.nativeDef === t.match.nativeDef || n.regex && !r[l].match.static && r[l].match.fn.test(t.input, i, e, !1, n))) {\n                            a = !0;\n                            break;\n                        }\n                        if (r[l].match && r[l].match.def === t.match.nativeDef) {\n                            a = void 0;\n                            break;\n                        }\n                    }\n                    return !1 === a && void 0 !== i.jitOffset[e] && (a = p.call(this, e + i.jitOffset[e], t, n)), \n                    a;\n                }\n                function d(e, t, n) {\n                    var a, o, l = this, s = this.maskset, c = this.opts, u = this.dependencyLib, f = c.skipOptionalPartCharacter, p = l.isRTL ? n.slice().reverse() : n;\n                    if (c.skipOptionalPartCharacter = \"\", !0 === e) r.resetMaskSet.call(l, !1), e = 0, \n                    t = n.length, o = r.determineNewCaretPosition.call(l, {\n                        begin: 0,\n                        end: 0\n                    }, !1).begin; else {\n                        for (a = e; a < t; a++) s.validPositions.splice(e, 0);\n                        o = e;\n                    }\n                    var d = new u.Event(\"keypress\");\n                    for (a = e; a < t; a++) {\n                        d.key = p[a].toString(), l.ignorable = !1;\n                        var h = i.EventHandlers.keypressEvent.call(l, d, !0, !1, !1, o);\n                        !1 !== h && void 0 !== h && (o = h.forwardPosition);\n                    }\n                    c.skipOptionalPartCharacter = f;\n                }\n                function h(e, t, n) {\n                    var i = this, a = this.maskset, l = this.dependencyLib;\n                    if (void 0 === e) for (e = t - 1; e > 0 && !a.validPositions[e]; e--) ;\n                    for (var s = e; s < t; s++) {\n                        if (void 0 === a.validPositions[s] && !r.isMask.call(i, s, !1)) if (0 == s ? o.getTest.call(i, s) : a.validPositions[s - 1]) {\n                            var c = o.getTests.call(i, s).slice();\n                            \"\" === c[c.length - 1].match.def && c.pop();\n                            var u, p = o.determineTestTemplate.call(i, s, c);\n                            if (p && (!0 !== p.match.jit || \"master\" === p.match.newBlockMarker && (u = a.validPositions[s + 1]) && !0 === u.match.optionalQuantifier) && ((p = l.extend({}, p, {\n                                input: o.getPlaceholder.call(i, s, p.match, !0) || p.match.def\n                            })).generatedInput = !0, v.call(i, s, p, !0), !0 !== n)) {\n                                var d = a.validPositions[t].input;\n                                return a.validPositions[t] = void 0, f.call(i, t, d, !0, !0);\n                            }\n                        }\n                    }\n                }\n                function v(e, t, n, i) {\n                    var a = this, l = this.maskset, s = this.opts, c = this.dependencyLib;\n                    function d(e, t, n) {\n                        var i = t[e];\n                        if (void 0 !== i && !0 === i.match.static && !0 !== i.match.optionality && (void 0 === t[0] || void 0 === t[0].alternation)) {\n                            var a = n.begin <= e - 1 ? t[e - 1] && !0 === t[e - 1].match.static && t[e - 1] : t[e - 1], r = n.end > e + 1 ? t[e + 1] && !0 === t[e + 1].match.static && t[e + 1] : t[e + 1];\n                            return a && r;\n                        }\n                        return !1;\n                    }\n                    var h = 0, v = void 0 !== e.begin ? e.begin : e, m = void 0 !== e.end ? e.end : e, g = !0;\n                    if (e.begin > e.end && (v = e.end, m = e.begin), i = void 0 !== i ? i : v, void 0 === n && (v !== m || s.insertMode && void 0 !== l.validPositions[i] || void 0 === t || t.match.optionalQuantifier || t.match.optionality)) {\n                        var y, k = c.extend(!0, [], l.validPositions), b = r.getLastValidPosition.call(a, void 0, !0);\n                        l.p = v;\n                        var x = u.call(a, e) ? v : i;\n                        for (y = b; y >= x; y--) l.validPositions.splice(y, 1), void 0 === t && delete l.tests[y + 1];\n                        var w, P, S = i, O = S;\n                        for (t && (l.validPositions[i] = c.extend(!0, {}, t), O++, S++), null == k[m] && l.jitOffset[m] && (m += l.jitOffset[m] + 1), \n                        y = t ? m : m - 1; y <= b; y++) {\n                            if (void 0 !== (w = k[y]) && !0 !== w.generatedInput && (y >= m || y >= v && d(y, k, {\n                                begin: v,\n                                end: m\n                            }))) {\n                                for (;\"\" !== o.getTest.call(a, O).match.def; ) {\n                                    if (!1 !== (P = p.call(a, O, w, s)) || \"+\" === w.match.def) {\n                                        \"+\" === w.match.def && r.getBuffer.call(a, !0);\n                                        var _ = f.call(a, O, w.input, \"+\" !== w.match.def, !0);\n                                        if (g = !1 !== _, S = (_.pos || O) + 1, !g && P) break;\n                                    } else g = !1;\n                                    if (g) {\n                                        void 0 === t && w.match.static && y === e.begin && h++;\n                                        break;\n                                    }\n                                    if (!g && r.getBuffer.call(a), O > l.maskLength) break;\n                                    O++;\n                                }\n                                \"\" == o.getTest.call(a, O).match.def && (g = !1), O = S;\n                            }\n                            if (!g) break;\n                        }\n                        if (!g) return l.validPositions = c.extend(!0, [], k), r.resetMaskSet.call(a, !0), \n                        !1;\n                    } else t && o.getTest.call(a, i).match.cd === t.match.cd && (l.validPositions[i] = c.extend(!0, {}, t));\n                    return r.resetMaskSet.call(a, !0), h;\n                }\n            }\n        }, t = {};\n        function n(i) {\n            var a = t[i];\n            if (void 0 !== a) return a.exports;\n            var r = t[i] = {\n                exports: {}\n            };\n            return e[i](r, r.exports, n), r.exports;\n        }\n        var i = {};\n        return function() {\n            var e = i;\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.default = void 0, n(7149), n(3194), n(9302), n(4013), n(3851), n(219), n(207), \n            n(5296);\n            var t, a = (t = n(2394)) && t.__esModule ? t : {\n                default: t\n            };\n            e.default = a.default;\n        }(), i;\n    }();\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW5wdXRtYXNrL2Rpc3QvaW5wdXRtYXNrLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXVELHdCQUF3QixLQUFLO0FBQUEsYUFHdkY7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QywrQ0FBK0M7QUFDL0MsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csT0FBTztBQUN2RztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsR0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsR0FBRztBQUNo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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndWxwLXNjc3Mtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9pbnB1dG1hc2svZGlzdC9pbnB1dG1hc2suanM/MjUyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGRpc3QvaW5wdXRtYXNrXG4gKiBodHRwczovL2dpdGh1Yi5jb20vUm9iaW5IZXJib3RzL0lucHV0bWFza1xuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAyNCBSb2JpbiBIZXJib3RzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIFZlcnNpb246IDUuMC45XG4gKi9cbiFmdW5jdGlvbihlLCB0KSB7XG4gICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IHQoKTsgZWxzZSBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKFtdLCB0KTsgZWxzZSB7XG4gICAgICAgIHZhciBuID0gdCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIG4pIChcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzID8gZXhwb3J0cyA6IGUpW2ldID0gbltpXTtcbiAgICB9XG59KFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgPyBzZWxmIDogdGhpcywgKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgMzk3NjogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHQuZGVmYXVsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgX21heFRlc3RQb3M6IDUwMCxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiX1wiLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbG1hcmtlcjogWyBcIltcIiwgXCJdXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRpZmllcm1hcmtlcjogWyBcIntcIiwgXCJ9XCIgXSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBtYXJrZXI6IFsgXCIoXCIsIFwiKVwiIF0sXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0b3JtYXJrZXI6IFwifFwiLFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDaGFyOiBcIlxcXFxcIixcbiAgICAgICAgICAgICAgICAgICAgbWFzazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVnZXg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG9uY29tcGxldGU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICAgICAgICAgIG9uaW5jb21wbGV0ZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25jbGVhcmVkOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgICAgICAgICByZXBlYXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGdyZWVkeTogITEsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9Vbm1hc2s6ICExLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVNYXNrT25TdWJtaXQ6ICExLFxuICAgICAgICAgICAgICAgICAgICBjbGVhck1hc2tPbkxvc3RGb2N1czogITAsXG4gICAgICAgICAgICAgICAgICAgIGluc2VydE1vZGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRNb2RlVmlzdWFsOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbmNvbXBsZXRlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bjogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVNYXNrOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZVBhc3RlOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0Lm9uQmVmb3JlTWFzayA/IHQub25CZWZvcmVNYXNrLmNhbGwodGhpcywgZSwgdCkgOiBlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZVdyaXRlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvblVuTWFzazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2hvd01hc2tPbkZvY3VzOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgc2hvd01hc2tPbkhvdmVyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgb25LZXlWYWxpZGF0aW9uOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgICAgICAgICBza2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyOiBcIiBcIixcbiAgICAgICAgICAgICAgICAgICAgbnVtZXJpY0lucHV0OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRBbGlnbjogITEsXG4gICAgICAgICAgICAgICAgICAgIHVuZG9PbkVzY2FwZTogITAsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl4UG9pbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIF9yYWRpeERhbmNlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3I6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGtlZXBTdGF0aWM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2FyZXRPblRhYjogITAsXG4gICAgICAgICAgICAgICAgICAgIHRhYlRocm91Z2g6ICExLFxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c0lucHV0VHlwZTogWyBcInRleHRcIiwgXCJ0ZWxcIiwgXCJ1cmxcIiwgXCJwYXNzd29yZFwiLCBcInNlYXJjaFwiIF0sXG4gICAgICAgICAgICAgICAgICAgIGlzQ29tcGxldGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHByZVZhbGlkYXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBvc3RWYWxpZGF0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNEZWZpbml0aW9uU3ltYm9sOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIGppdE1hc2tpbmc6ICExLFxuICAgICAgICAgICAgICAgICAgICBudWxsYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0RXZlbnRPbmx5OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgbm9WYWx1ZVBhdGNoaW5nOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25DYXJldE9uQ2xpY2s6IFwibHZwXCIsXG4gICAgICAgICAgICAgICAgICAgIGNhc2luZzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRtb2RlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0RGF0YUF0dHJpYnV0ZXM6ICEwLFxuICAgICAgICAgICAgICAgICAgICBzaGlmdFBvc2l0aW9uczogITAsXG4gICAgICAgICAgICAgICAgICAgIHVzZVByb3RvdHlwZURlZmluaXRpb25zOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbkV2ZW50VGltZU91dDogM2UzLFxuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlczoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDczOTI6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0LmRlZmF1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIDk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogXCJbMC05XFx1ZmYxMC1cXHVmZjE5XVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvblN5bWJvbDogXCIqXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIltBLVphLXpcXHUwNDEwLVxcdTA0NGZcXHUwNDAxXFx1MDQ1MVxceGMwLVxceGZmXFx4YjVdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uU3ltYm9sOiBcIipcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcIipcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIlswLTlcXHVmZjEwLVxcdWZmMTlBLVphLXpcXHUwNDEwLVxcdTA0NGZcXHUwNDAxXFx1MDQ1MVxceGMwLVxceGZmXFx4YjVdXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMjUzOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IG4pIHJldHVybiBlLl9fZGF0YSA/IGUuX19kYXRhW3RdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZS5fX2RhdGEgPSBlLl9fZGF0YSB8fCB7fSwgZS5fX2RhdGFbdF0gPSBuO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMzc3NjogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5FdmVudCA9IHZvaWQgMCwgdC5vZmYgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuLCBpO1xuICAgICAgICAgICAgICAgICAgICB1KHRoaXNbMF0pICYmIGUgJiYgKG4gPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnksIGkgPSB0aGlzWzBdLCBlLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG8oZS5zcGxpdChcIi5cIiksIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSwgciwgbyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmxlbmd0aCA+IDApIGlmICh2b2lkIDAgPT09IHQpIGZvciAoYSA9IDAsIHIgPSBuW2VdW2ldLmxlbmd0aDsgYSA8IHI7IGErKykgby5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXY6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogaSAmJiBpLmxlbmd0aCA+IDAgPyBpIDogXCJnbG9iYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogbltlXVtpXVthXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBlbHNlIG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2OiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IGkgJiYgaS5sZW5ndGggPiAwID8gaSA6IFwiZ2xvYmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgZWxzZSBpZiAoaS5sZW5ndGggPiAwKSBmb3IgKHZhciBsIGluIG4pIGZvciAodmFyIHMgaW4gbltsXSkgaWYgKHMgPT09IGkpIGlmICh2b2lkIDAgPT09IHQpIGZvciAoYSA9IDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBuW2xdW3NdLmxlbmd0aDsgYSA8IHI7IGErKykgby5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXY6IGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogbltsXVtzXVthXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBlbHNlIG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2OiBsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKGFbMF0sIGFbMV0pLmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuZXYsIGEgPSBlLmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW4gbiA9PSAxKSBpZiAoaS5yZW1vdmVFdmVudExpc3RlbmVyID8gaS5yZW1vdmVFdmVudExpc3RlbmVyKGUsIGEsICExKSA6IGkuZGV0YWNoRXZlbnQgJiYgaS5kZXRhY2hFdmVudChcIm9uXCIuY29uY2F0KGUpLCBhKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2xvYmFsXCIgPT09IHQpIGZvciAodmFyIHIgaW4gbltlXSkgbltlXVtyXS5zcGxpY2UobltlXVtyXS5pbmRleE9mKGEpLCAxKTsgZWxzZSBuW2VdW3RdLnNwbGljZShuW2VdW3RdLmluZGV4T2YoYSksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0odCwgZS5uYW1lc3BhY2UsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LCB0Lm9uID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodSh0aGlzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnksIGkgPSB0aGlzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zcGxpdChcIiBcIikuZm9yRWFjaCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gbyhlLnNwbGl0KFwiLlwiKSwgMiksIHIgPSBhWzBdLCBsID0gYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oZSwgYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLmFkZEV2ZW50TGlzdGVuZXIgPyBpLmFkZEV2ZW50TGlzdGVuZXIoZSwgdCwgITEpIDogaS5hdHRhY2hFdmVudCAmJiBpLmF0dGFjaEV2ZW50KFwib25cIi5jb25jYXQoZSksIHQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbltlXSA9IG5bZV0gfHwge30sIG5bZV1bYV0gPSBuW2VdW2FdIHx8IFtdLCBuW2VdW2FdLnB1c2godCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShyLCB2b2lkIDAgPT09IGwgPyBcImdsb2JhbFwiIDogbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSwgdC50cmlnZ2VyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUodGhpc1swXSkpIGZvciAodmFyIG4gPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnksIGkgPSB0aGlzWzBdLCBvID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IGUuc3BsaXQoXCIgXCIpIDogWyBlLnR5cGUgXSwgbCA9IDA7IGwgPCBvLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG9bbF0uc3BsaXQoXCIuXCIpLCBmID0gc1swXSwgcCA9IHNbMV0gfHwgXCJnbG9iYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGMgJiYgXCJnbG9iYWxcIiA9PT0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkLCBoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2VkOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBhcmd1bWVudHNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJpbnB1dFwiID09PSBmKSBoLmlucHV0VHlwZSA9IFwiaW5zZXJ0VGV4dFwiLCBkID0gbmV3IElucHV0RXZlbnQoZiwgaCk7IGVsc2UgZCA9IG5ldyBDdXN0b21FdmVudChmLCBoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGQgPSBjLmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIikpLmluaXRDdXN0b21FdmVudChmLCBoLmJ1YmJsZXMsIGguY2FuY2VsYWJsZSwgaC5kZXRhaWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudHlwZSAmJiAoMCwgYS5kZWZhdWx0KShkLCBlKSwgaS5kaXNwYXRjaEV2ZW50KGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAoZCA9IGMuY3JlYXRlRXZlbnRPYmplY3QoKSkuZXZlbnRUeXBlID0gZiwgZC5kZXRhaWwgPSBhcmd1bWVudHNbMV0sIGUudHlwZSAmJiAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5kZWZhdWx0KShkLCBlKSwgaS5maXJlRXZlbnQoXCJvblwiICsgZC5ldmVudFR5cGUsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2b2lkIDAgIT09IG5bZl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF0udHlwZSA/IGFyZ3VtZW50c1swXSA6IHIuZGVmYXVsdC5FdmVudChhcmd1bWVudHNbMF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF0uZGV0YWlsID0gYXJndW1lbnRzLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gbltmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJnbG9iYWxcIiA9PT0gcCA/IE9iamVjdC52YWx1ZXModikuZmxhdCgpIDogdltwXSkuZm9yRWFjaCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5hcHBseShpLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHMobig5MzgwKSksIGEgPSBzKG4oNjAwKSksIHIgPSBzKG4oNDk2MykpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG8oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICB9KGUpIHx8IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gbnVsbCA9PSBlID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBlW1N5bWJvbC5pdGVyYXRvcl0gfHwgZVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGEsIHIsIG8sIGwgPSBbXSwgcyA9ICEwLCBjID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSAobiA9IG4uY2FsbChlKSkubmV4dCwgMCA9PT0gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdChuKSAhPT0gbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZm9yICg7IShzID0gKGkgPSByLmNhbGwobikpLmRvbmUpICYmIChsLnB1c2goaS52YWx1ZSksIGwubGVuZ3RoICE9PSB0KTsgcyA9ICEwKSA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gITAsIGEgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXMgJiYgbnVsbCAhPSBuLnJldHVybiAmJiAobyA9IG4ucmV0dXJuKCksIE9iamVjdChvKSAhPT0gbykpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjKSB0aHJvdyBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KGUsIHQpIHx8IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHJldHVybiBsKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJPYmplY3RcIiA9PT0gbiAmJiBlLmNvbnN0cnVjdG9yICYmIChuID0gZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIk1hcFwiID09PSBuIHx8IFwiU2V0XCIgPT09IG4pIHJldHVybiBBcnJheS5mcm9tKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiQXJndW1lbnRzXCIgPT09IG4gfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBsKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICB9KGUsIHQpIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gdCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMCwgaSA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKykgaVtuXSA9IGVbbl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBpLmRlZmF1bHQuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGYgPSB0LkV2ZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaS5kZWZhdWx0LkN1c3RvbUV2ZW50ID8gdC5FdmVudCA9IGYgPSBpLmRlZmF1bHQuQ3VzdG9tRXZlbnQgOiBpLmRlZmF1bHQuRXZlbnQgJiYgYyAmJiBjLmNyZWF0ZUV2ZW50ID8gKHQuRXZlbnQgPSBmID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdCB8fCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zZWQ6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBjLmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuLmluaXRDdXN0b21FdmVudChlLCB0LmJ1YmJsZXMsIHQuY2FuY2VsYWJsZSwgdC5kZXRhaWwpLCBuO1xuICAgICAgICAgICAgICAgIH0sIGYucHJvdG90eXBlID0gaS5kZWZhdWx0LkV2ZW50LnByb3RvdHlwZSkgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBFdmVudCAmJiAodC5FdmVudCA9IGYgPSBFdmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNjAwOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIG4oZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5kZWZhdWx0ID0gZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQsIGksIGEsIHIsIG8sIGwsIHMgPSBhcmd1bWVudHNbMF0gfHwge30sIGMgPSAxLCB1ID0gYXJndW1lbnRzLmxlbmd0aCwgZiA9ICExO1xuICAgICAgICAgICAgICAgICAgICBcImJvb2xlYW5cIiA9PSB0eXBlb2YgcyAmJiAoZiA9IHMsIHMgPSBhcmd1bWVudHNbY10gfHwge30sIGMrKyk7XG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgIT09IG4ocykgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBzICYmIChzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDtjIDwgdTsgYysrKSBpZiAobnVsbCAhPSAodCA9IGFyZ3VtZW50c1tjXSkpIGZvciAoaSBpbiB0KSBhID0gc1tpXSwgcyAhPT0gKHIgPSB0W2ldKSAmJiAoZiAmJiByICYmIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikgfHwgKG8gPSBBcnJheS5pc0FycmF5KHIpKSkgPyAobyA/IChvID0gITEsIFxuICAgICAgICAgICAgICAgICAgICBsID0gYSAmJiBBcnJheS5pc0FycmF5KGEpID8gYSA6IFtdKSA6IGwgPSBhICYmIFwiW29iamVjdCBPYmplY3RdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA/IGEgOiB7fSwgXG4gICAgICAgICAgICAgICAgICAgIHNbaV0gPSBlKGYsIGwsIHIpKSA6IHZvaWQgMCAhPT0gciAmJiAoc1tpXSA9IHIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA0OTYzOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBsKG4oOTM4MCkpLCBhID0gbChuKDI1MykpLCByID0gbigzNzc2KSwgbyA9IGwobig2MDApKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBpLmRlZmF1bHQuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgYyA/IGUgOiB0aGlzIGluc3RhbmNlb2YgYyA/IHZvaWQgKG51bGwgIT0gZSAmJiBlICE9PSBpLmRlZmF1bHQgJiYgKHRoaXNbMF0gPSBlLm5vZGVOYW1lID8gZSA6IHZvaWQgMCAhPT0gZVswXSAmJiBlWzBdLm5vZGVOYW1lID8gZVswXSA6IHMucXVlcnlTZWxlY3RvcihlKSwgXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpc1swXSAmJiBudWxsICE9PSB0aGlzWzBdICYmICh0aGlzWzBdLmV2ZW50UmVnaXN0cnkgPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnkgfHwge30pKSkgOiBuZXcgYyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYy5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiByLm9uLFxuICAgICAgICAgICAgICAgICAgICBvZmY6IHIub2ZmLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiByLnRyaWdnZXJcbiAgICAgICAgICAgICAgICB9LCBjLmV4dGVuZCA9IG8uZGVmYXVsdCwgYy5kYXRhID0gYS5kZWZhdWx0LCBjLkV2ZW50ID0gci5FdmVudDtcbiAgICAgICAgICAgICAgICB0LmRlZmF1bHQgPSBjO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDk4NDU6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQubW9iaWxlID0gdC5pcGhvbmUgPSB0LmllID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBpLCBhID0gKGkgPSBuKDkzODApKSAmJiBpLl9fZXNNb2R1bGUgPyBpIDoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGEuZGVmYXVsdC5uYXZpZ2F0b3IgJiYgYS5kZWZhdWx0Lm5hdmlnYXRvci51c2VyQWdlbnQgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB0LmllID0gci5pbmRleE9mKFwiTVNJRSBcIikgPiAwIHx8IHIuaW5kZXhPZihcIlRyaWRlbnQvXCIpID4gMCwgdC5tb2JpbGUgPSBhLmRlZmF1bHQubmF2aWdhdG9yICYmIGEuZGVmYXVsdC5uYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJiBhLmRlZmF1bHQubmF2aWdhdG9yLnVzZXJBZ2VudERhdGEubW9iaWxlIHx8IGEuZGVmYXVsdC5uYXZpZ2F0b3IgJiYgYS5kZWZhdWx0Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCBcIm9udG91Y2hzdGFydFwiIGluIGEuZGVmYXVsdCwgXG4gICAgICAgICAgICAgICAgdC5pcGhvbmUgPSAvaXBob25lL2kudGVzdChyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA3MTg0OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnJlcGxhY2UobiwgXCJcXFxcJDFcIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IG5ldyBSZWdFeHAoXCIoXFxcXFwiICsgWyBcIi9cIiwgXCIuXCIsIFwiKlwiLCBcIitcIiwgXCI/XCIsIFwifFwiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBcIlxcXFxcIiwgXCIkXCIsIFwiXlwiIF0uam9pbihcInxcXFxcXCIpICsgXCIpXCIsIFwiZ2ltXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDYwMzA6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LkV2ZW50SGFuZGxlcnMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGEsIHIgPSBuKDk4NDUpLCBvID0gKGEgPSBuKDkzODApKSAmJiBhLl9fZXNNb2R1bGUgPyBhIDoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBhXG4gICAgICAgICAgICAgICAgfSwgbCA9IG4oNzc2MCksIHMgPSBuKDI4MzkpLCBjID0gbig4NzExKSwgdSA9IG4oNzIxNSksIGYgPSBuKDQ3MTMpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBlLCB0ID0ge30sIG4gPSBPYmplY3QucHJvdG90eXBlLCBhID0gbi5oYXNPd25Qcm9wZXJ0eSwgciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlW3RdID0gbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgbyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGwgPSBvLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBzID0gby5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIGMgPSBvLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgZVt0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdSh7fSwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVbdF0gPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKGUsIHQsIG4sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gdCAmJiB0LnByb3RvdHlwZSBpbnN0YW5jZW9mIGsgPyB0IDogaywgbyA9IE9iamVjdC5jcmVhdGUoYS5wcm90b3R5cGUpLCBsID0gbmV3IEQoaSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcihvLCBcIl9pbnZva2VcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBFKGUsIG4sIGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnOiBlLmNhbGwodCwgbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnOiBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0LndyYXAgPSBmO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IFwic3VzcGVuZGVkU3RhcnRcIiwgdiA9IFwic3VzcGVuZGVkWWllbGRcIiwgbSA9IFwiZXhlY3V0aW5nXCIsIGcgPSBcImNvbXBsZXRlZFwiLCB5ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGsoKSB7fVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBiKCkge31cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24geCgpIHt9XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHUodywgbCwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIFMgPSBQICYmIFAoUChMKFtdKSkpO1xuICAgICAgICAgICAgICAgICAgICBTICYmIFMgIT09IG4gJiYgYS5jYWxsKFMsIGwpICYmICh3ID0gUyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBPID0geC5wcm90b3R5cGUgPSBrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodyk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF8oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgWyBcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiIF0uZm9yRWFjaCgoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUoZSwgdCwgKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZSh0LCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gTShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBuKHIsIG8sIGwsIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGQoZVtyXSwgZSwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwidGhyb3dcIiAhPT0gYy50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gYy5hcmcsIGYgPSB1LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZiAmJiBcIm9iamVjdFwiID09IGkoZikgJiYgYS5jYWxsKGYsIFwiX19hd2FpdFwiKSA/IHQucmVzb2x2ZShmLl9fYXdhaXQpLnRoZW4oKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4oXCJuZXh0XCIsIGUsIGwsIHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4oXCJ0aHJvd1wiLCBlLCBsLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpIDogdC5yZXNvbHZlKGYpLnRoZW4oKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUudmFsdWUgPSBlLCBsKHUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuKFwidGhyb3dcIiwgZSwgbCwgcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyhjLmFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbztcbiAgICAgICAgICAgICAgICAgICAgICAgIHIodGhpcywgXCJfaW52b2tlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KChmdW5jdGlvbih0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbihlLCBpLCB0LCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbyA9IG8gPyBvLnRoZW4oYSwgYSkgOiBhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gRSh0LCBuLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ociwgbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBtKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInRocm93XCIgPT09IHIpIHRocm93IG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaS5tZXRob2QgPSByLCBpLmFyZyA9IG87IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBpLmRlbGVnYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBqKGwsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0geSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwibmV4dFwiID09PSBpLm1ldGhvZCkgaS5zZW50ID0gaS5fc2VudCA9IGkuYXJnOyBlbHNlIGlmIChcInRocm93XCIgPT09IGkubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PT0gaCkgdGhyb3cgYSA9IGcsIGkuYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5kaXNwYXRjaEV4Y2VwdGlvbihpLmFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBcInJldHVyblwiID09PSBpLm1ldGhvZCAmJiBpLmFicnVwdChcInJldHVyblwiLCBpLmFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGQodCwgbiwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm5vcm1hbFwiID09PSBjLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID0gaS5kb25lID8gZyA6IHYsIGMuYXJnID09PSB5KSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGMuYXJnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGkuZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRocm93XCIgPT09IGMudHlwZSAmJiAoYSA9IGcsIGkubWV0aG9kID0gXCJ0aHJvd1wiLCBpLmFyZyA9IGMuYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGoodCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBuLm1ldGhvZCwgYSA9IHQuaXRlcmF0b3JbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PT0gZSkgcmV0dXJuIG4uZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IGkgJiYgdC5pdGVyYXRvci5yZXR1cm4gJiYgKG4ubWV0aG9kID0gXCJyZXR1cm5cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICBuLmFyZyA9IGUsIGoodCwgbiksIFwidGhyb3dcIiA9PT0gbi5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IGkgJiYgKG4ubWV0aG9kID0gXCJ0aHJvd1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgaSArIFwiJyBtZXRob2RcIikpLCB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBkKGEsIHQuaXRlcmF0b3IsIG4uYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInRocm93XCIgPT09IHIudHlwZSkgcmV0dXJuIG4ubWV0aG9kID0gXCJ0aHJvd1wiLCBuLmFyZyA9IHIuYXJnLCBuLmRlbGVnYXRlID0gbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSByLmFyZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvID8gby5kb25lID8gKG5bdC5yZXN1bHROYW1lXSA9IG8udmFsdWUsIG4ubmV4dCA9IHQubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gbi5tZXRob2QgJiYgKG4ubWV0aG9kID0gXCJuZXh0XCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgbi5hcmcgPSBlKSwgbi5kZWxlZ2F0ZSA9IG51bGwsIHkpIDogbyA6IChuLm1ldGhvZCA9IFwidGhyb3dcIiwgbi5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgbi5kZWxlZ2F0ZSA9IG51bGwsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFQoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5TG9jOiBlWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgMSBpbiBlICYmICh0LmNhdGNoTG9jID0gZVsxXSksIDIgaW4gZSAmJiAodC5maW5hbGx5TG9jID0gZVsyXSwgdC5hZnRlckxvYyA9IGVbM10pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEEoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmNvbXBsZXRpb24gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgdC5hcmcsIGUuY29tcGxldGlvbiA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gRChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVudHJpZXMgPSBbIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlMb2M6IFwicm9vdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9IF0sIGUuZm9yRWFjaChULCB0aGlzKSwgdGhpcy5yZXNldCghMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gTCh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCB8fCBcIlwiID09PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0W2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuKSByZXR1cm4gbi5jYWxsKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQubmV4dCkgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTih0Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAtMSwgbyA9IGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsrK3IgPCB0Lmxlbmd0aDsgKSBpZiAoYS5jYWxsKHQsIHIpKSByZXR1cm4gbi52YWx1ZSA9IHRbcl0sIG4uZG9uZSA9ICExLCBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4udmFsdWUgPSBlLCBuLmRvbmUgPSAhMCwgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8ubmV4dCA9IG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihpKHQpICsgXCIgaXMgbm90IGl0ZXJhYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiLnByb3RvdHlwZSA9IHgsIHIoTywgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgfSksIHIoeCwgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgfSksIGIuZGlzcGxheU5hbWUgPSB1KHgsIGMsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIHQuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlICYmIGUuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF0ICYmICh0ID09PSBiIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKHQuZGlzcGxheU5hbWUgfHwgdC5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHQubWFyayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSwgeCkgOiAoZS5fX3Byb3RvX18gPSB4LCB1KGUsIGMsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPKSwgZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdC5hd3JhcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19hd2FpdDogZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSwgXyhNLnByb3RvdHlwZSksIHUoTS5wcm90b3R5cGUsIHMsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9KSksIHQuQXN5bmNJdGVyYXRvciA9IE0sIHQuYXN5bmMgPSBmdW5jdGlvbihlLCBuLCBpLCBhLCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSBQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gbmV3IE0oZihlLCBuLCBpLCBhKSwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5pc0dlbmVyYXRvckZ1bmN0aW9uKG4pID8gbyA6IG8ubmV4dCgpLnRoZW4oKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5kb25lID8gZS52YWx1ZSA6IG8ubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LCBfKE8pLCB1KE8sIGMsIFwiR2VuZXJhdG9yXCIpLCB1KE8sIGwsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9KSksIHUoTywgXCJ0b1N0cmluZ1wiLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgICAgICAgICAgICAgICAgICAgfSkpLCB0LmtleXMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE9iamVjdChlKSwgbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0KSBuLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5yZXZlcnNlKCksIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7bi5sZW5ndGg7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IG4ucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIGluIHQpIHJldHVybiBlLnZhbHVlID0gaSwgZS5kb25lID0gITEsIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmRvbmUgPSAhMCwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sIHQudmFsdWVzID0gTCwgRC5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSBlLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gZSwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2goQSksICF0KSBmb3IgKHZhciBuIGluIHRoaXMpIFwidFwiID09PSBuLmNoYXJBdCgwKSAmJiBhLmNhbGwodGhpcywgbikgJiYgIWlzTmFOKCtuLnNsaWNlKDEpKSAmJiAodGhpc1tuXSA9IGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gZS50eXBlKSB0aHJvdyBlLmFyZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkgdGhyb3cgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaShpLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsLnR5cGUgPSBcInRocm93XCIsIGwuYXJnID0gdCwgbi5uZXh0ID0gaSwgYSAmJiAobi5tZXRob2QgPSBcIm5leHRcIiwgbi5hcmcgPSBlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEhYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyByID49IDA7IC0tcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHRoaXMudHJ5RW50cmllc1tyXSwgbCA9IG8uY29tcGxldGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwicm9vdFwiID09PSBvLnRyeUxvYykgcmV0dXJuIGkoXCJlbmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gYS5jYWxsKG8sIFwiY2F0Y2hMb2NcIiksIGMgPSBhLmNhbGwobywgXCJmaW5hbGx5TG9jXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgJiYgYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBvLmNhdGNoTG9jKSByZXR1cm4gaShvLmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IG8uZmluYWxseUxvYykgcmV0dXJuIGkoby5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBvLmNhdGNoTG9jKSByZXR1cm4gaShvLmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYykgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IG8uZmluYWxseUxvYykgcmV0dXJuIGkoby5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnJ1cHQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IG4gPj0gMDsgLS1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy50cnlFbnRyaWVzW25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGEuY2FsbChpLCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgaS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByICYmIChcImJyZWFrXCIgPT09IGUgfHwgXCJjb250aW51ZVwiID09PSBlKSAmJiByLnRyeUxvYyA8PSB0ICYmIHQgPD0gci5maW5hbGx5TG9jICYmIChyID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSByID8gci5jb21wbGV0aW9uIDoge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8udHlwZSA9IGUsIG8uYXJnID0gdCwgciA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSByLmZpbmFsbHlMb2MsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkpIDogdGhpcy5jb21wbGV0ZShvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInRocm93XCIgPT09IGUudHlwZSkgdGhyb3cgZS5hcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIiA9PT0gZS50eXBlIHx8IFwiY29udGludWVcIiA9PT0gZS50eXBlID8gdGhpcy5uZXh0ID0gZS5hcmcgOiBcInJldHVyblwiID09PSBlLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSBlLmFyZywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IGUudHlwZSAmJiB0ICYmICh0aGlzLm5leHQgPSB0KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IHQgPj0gMDsgLS10KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy50cnlFbnRyaWVzW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5maW5hbGx5TG9jID09PSBlKSByZXR1cm4gdGhpcy5jb21wbGV0ZShuLmNvbXBsZXRpb24sIG4uYWZ0ZXJMb2MpLCBBKG4pLCB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgdCA+PSAwOyAtLXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLnRyeUVudHJpZXNbdF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnRyeUxvYyA9PT0gZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBuLmNvbXBsZXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJ0aHJvd1wiID09PSBpLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGkuYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEobik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24odCwgbiwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcjogTCh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TmFtZTogbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExvYzogaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSBlKSwgeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGVbU3ltYm9sLml0ZXJhdG9yXSB8fCBlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSB8fCAobiA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgcmV0dXJuIGgoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IG4gJiYgZS5jb25zdHJ1Y3RvciAmJiAobiA9IGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiTWFwXCIgPT09IG4gfHwgXCJTZXRcIiA9PT0gbikgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiQXJndW1lbnRzXCIgPT09IG4gfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBoKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShlKSkgfHwgdCAmJiBlICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiAmJiAoZSA9IG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gMCwgYSA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczogYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA+PSBlLmxlbmd0aCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZVtpKytdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmOiBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgciwgbyA9ICEwLCBsID0gITE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbi5jYWxsKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gbi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8gPSBlLmRvbmUsIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSAhMCwgciA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyB8fCBudWxsID09IG4ucmV0dXJuIHx8IG4ucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwpIHRocm93IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gdCB8fCB0ID4gZS5sZW5ndGgpICYmICh0ID0gZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMCwgaSA9IG5ldyBBcnJheSh0KTsgbiA8IHQ7IG4rKykgaVtuXSA9IGVbbl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB2KGUsIHQsIG4sIGksIGEsIHIsIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gZVtyXShvKSwgcyA9IGwudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIG4oZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbC5kb25lID8gdChzKSA6IFByb21pc2UucmVzb2x2ZShzKS50aGVuKGksIGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbSwgZywgeSA9IHQuRXZlbnRIYW5kbGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5RXZlbnQ6IGZ1bmN0aW9uKGUsIHQsIG4sIGksIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5pbnB1dG1hc2ssIHAgPSBvLm9wdHMsIGQgPSBvLmRlcGVuZGVuY3lMaWIsIGggPSBvLm1hc2tzZXQsIHYgPSB0aGlzLCBtID0gZCh2KSwgZyA9IGUua2V5LCBrID0gYy5jYXJldC5jYWxsKG8sIHYpLCBiID0gcC5vbktleURvd24uY2FsbCh0aGlzLCBlLCBjLmdldEJ1ZmZlci5jYWxsKG8pLCBrLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGIpIHJldHVybiBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGcgPT09IHMua2V5cy5CYWNrc3BhY2UgfHwgZyA9PT0gcy5rZXlzLkRlbGV0ZSB8fCByLmlwaG9uZSAmJiBnID09PSBzLmtleXMuQkFDS1NQQUNFX1NBRkFSSSB8fCBlLmN0cmxLZXkgJiYgZyA9PT0gcy5rZXlzLnggJiYgIShcIm9uY3V0XCIgaW4gdikpIGUucHJldmVudERlZmF1bHQoKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB1LmhhbmRsZVJlbW92ZS5jYWxsKG8sIHYsIGcsIGspLCAoMCwgbC53cml0ZUJ1ZmZlcikodiwgYy5nZXRCdWZmZXIuY2FsbChvLCAhMCksIGgucCwgZSwgdi5pbnB1dG1hc2suX3ZhbHVlR2V0KCkgIT09IGMuZ2V0QnVmZmVyLmNhbGwobykuam9pbihcIlwiKSk7IGVsc2UgaWYgKGcgPT09IHMua2V5cy5FbmQgfHwgZyA9PT0gcy5rZXlzLlBhZ2VEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gYy5zZWVrTmV4dC5jYWxsKG8sIGMuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChvKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jYXJldC5jYWxsKG8sIHYsIGUuc2hpZnRLZXkgPyBrLmJlZ2luIDogeCwgeCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGcgPT09IHMua2V5cy5Ib21lICYmICFlLnNoaWZ0S2V5IHx8IGcgPT09IHMua2V5cy5QYWdlVXAgPyAoZS5wcmV2ZW50RGVmYXVsdCgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FyZXQuY2FsbChvLCB2LCAwLCBlLnNoaWZ0S2V5ID8gay5iZWdpbiA6IDAsICEwKSkgOiBwLnVuZG9PbkVzY2FwZSAmJiBnID09PSBzLmtleXMuRXNjYXBlICYmICEwICE9PSBlLmFsdEtleSA/ICgoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBsLmNoZWNrVmFsKSh2LCAhMCwgITEsIG8udW5kb1ZhbHVlLnNwbGl0KFwiXCIpKSwgbS50cmlnZ2VyKFwiY2xpY2tcIikpIDogZyAhPT0gcy5rZXlzLkluc2VydCB8fCBlLnNoaWZ0S2V5IHx8IGUuY3RybEtleSB8fCB2b2lkIDAgIT09IG8udXNlck9wdGlvbnMuaW5zZXJ0TW9kZSA/ICEwID09PSBwLnRhYlRocm91Z2ggJiYgZyA9PT0gcy5rZXlzLlRhYiA/ICEwID09PSBlLnNoaWZ0S2V5ID8gKGsuZW5kID0gYy5zZWVrUHJldmlvdXMuY2FsbChvLCBrLmVuZCwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICEwID09PSBmLmdldFRlc3QuY2FsbChvLCBrLmVuZCAtIDEpLm1hdGNoLnN0YXRpYyAmJiBrLmVuZC0tLCBrLmJlZ2luID0gYy5zZWVrUHJldmlvdXMuY2FsbChvLCBrLmVuZCwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGsuYmVnaW4gPj0gMCAmJiBrLmVuZCA+IDAgJiYgKGUucHJldmVudERlZmF1bHQoKSwgYy5jYXJldC5jYWxsKG8sIHYsIGsuYmVnaW4sIGsuZW5kKSkpIDogKGsuYmVnaW4gPSBjLnNlZWtOZXh0LmNhbGwobywgay5iZWdpbiwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGsuZW5kID0gYy5zZWVrTmV4dC5jYWxsKG8sIGsuYmVnaW4sICEwKSwgay5lbmQgPCBoLm1hc2tMZW5ndGggJiYgay5lbmQtLSwgay5iZWdpbiA8PSBoLm1hc2tMZW5ndGggJiYgKGUucHJldmVudERlZmF1bHQoKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNhcmV0LmNhbGwobywgdiwgay5iZWdpbiwgay5lbmQpKSkgOiBlLnNoaWZ0S2V5IHx8IChwLmluc2VydE1vZGVWaXN1YWwgJiYgITEgPT09IHAuaW5zZXJ0TW9kZSA/IGcgPT09IHMua2V5cy5BcnJvd1JpZ2h0ID8gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBjLmNhcmV0LmNhbGwobywgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jYXJldC5jYWxsKG8sIHYsIGUuYmVnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApIDogZyA9PT0gcy5rZXlzLkFycm93TGVmdCAmJiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGMudHJhbnNsYXRlUG9zaXRpb24uY2FsbChvLCB2LmlucHV0bWFzay5jYXJldFBvcy5iZWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy50cmFuc2xhdGVQb3NpdGlvbi5jYWxsKG8sIHYuaW5wdXRtYXNrLmNhcmV0UG9zLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5pc1JUTCA/IGMuY2FyZXQuY2FsbChvLCB2LCBlICsgKGUgPT09IGgubWFza0xlbmd0aCA/IDAgOiAxKSkgOiBjLmNhcmV0LmNhbGwobywgdiwgZSAtICgwID09PSBlID8gMCA6IDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKSA6IHZvaWQgMCA9PT0gby5rZXlFdmVudEhvb2sgfHwgby5rZXlFdmVudEhvb2soZSkpIDogdS5pc1NlbGVjdGlvbi5jYWxsKG8sIGspID8gcC5pbnNlcnRNb2RlID0gIXAuaW5zZXJ0TW9kZSA6IChwLmluc2VydE1vZGUgPSAhcC5pbnNlcnRNb2RlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FyZXQuY2FsbChvLCB2LCBrLmJlZ2luLCBrLmJlZ2luKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gby5pc0NvbXBvc2luZyA9IGcgPT0gcy5rZXlzLlByb2Nlc3MgfHwgZyA9PSBzLmtleXMuVW5pZGVudGlmaWVkLCBvLmlnbm9yYWJsZSA9IGcubGVuZ3RoID4gMSAmJiAhKFwidGV4dGFyZWFcIiA9PT0gdi50YWdOYW1lLnRvTG93ZXJDYXNlKCkgJiYgZyA9PSBzLmtleXMuRW50ZXIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHkua2V5cHJlc3NFdmVudC5jYWxsKHRoaXMsIGUsIHQsIG4sIGksIGEpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBrZXlwcmVzc0V2ZW50OiBmdW5jdGlvbihlLCB0LCBuLCBpLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuaW5wdXRtYXNrIHx8IHRoaXMsIG8gPSByLm9wdHMsIGYgPSByLmRlcGVuZGVuY3lMaWIsIHAgPSByLm1hc2tzZXQsIGQgPSByLmVsLCBoID0gZihkKSwgdiA9IGUua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSB0IHx8IGUuY3RybEtleSAmJiBlLmFsdEtleSAmJiAhci5pZ25vcmFibGUgfHwgIShlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IHIuaWdub3JhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtLCBnID0gdCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luOiBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBjLmNhcmV0LmNhbGwociwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgfHwgKHYgPSBvLnN1YnN0aXR1dGVzW3ZdIHx8IHYpLCBwLndyaXRlT3V0QnVmZmVyID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdS5pc1ZhbGlkLmNhbGwociwgZywgdiwgaSwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0geSAmJiAoYy5yZXNldE1hc2tTZXQuY2FsbChyLCAhMCksIG0gPSB2b2lkIDAgIT09IHkuY2FyZXQgPyB5LmNhcmV0IDogYy5zZWVrTmV4dC5jYWxsKHIsIHkucG9zLmJlZ2luID8geS5wb3MuYmVnaW4gOiB5LnBvcyksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnAgPSBtKSwgbSA9IG8ubnVtZXJpY0lucHV0ICYmIHZvaWQgMCA9PT0geS5jYXJldCA/IGMuc2Vla1ByZXZpb3VzLmNhbGwociwgbSkgOiBtLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgITEgIT09IG4gJiYgKHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5vbktleVZhbGlkYXRpb24uY2FsbChkLCB2LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApLCBwLndyaXRlT3V0QnVmZmVyICYmICExICE9PSB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBjLmdldEJ1ZmZlci5jYWxsKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGwud3JpdGVCdWZmZXIpKGQsIGssIG0sIGUsICEwICE9PSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0KSByZXR1cm4gITEgIT09IHkgJiYgKHkuZm9yd2FyZFBvc2l0aW9uID0gbSksIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHYgPT09IHMua2V5cy5FbnRlciAmJiByLnVuZG9WYWx1ZSAhPT0gci5fdmFsdWVHZXQoITApICYmIChyLnVuZG9WYWx1ZSA9IHIuX3ZhbHVlR2V0KCEwKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXN0ZUV2ZW50OiAobSA9IHAoKS5tYXJrKChmdW5jdGlvbiBlKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuLCBpLCBhLCByLCBzLCB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAoKS53cmFwKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykgc3dpdGNoIChlLnByZXYgPSBlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGZ1bmN0aW9uKGUsIG4sIGksIGEsIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gYy5jYXJldC5jYWxsKGUsIG4sIHZvaWQgMCwgdm9pZCAwLCAhMCksIHUgPSBpLnN1YnN0cigwLCBzLmJlZ2luKSwgZiA9IGkuc3Vic3RyKHMuZW5kLCBpLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodSA9PSAoZS5pc1JUTCA/IGMuZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChlKS5zbGljZSgpLnJldmVyc2UoKSA6IGMuZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChlKSkuc2xpY2UoMCwgcy5iZWdpbikuam9pbihcIlwiKSAmJiAodSA9IFwiXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPT0gKGUuaXNSVEwgPyBjLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoZSkuc2xpY2UoKS5yZXZlcnNlKCkgOiBjLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoZSkpLnNsaWNlKHMuZW5kKS5qb2luKFwiXCIpICYmIChmID0gXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHUgKyBhICsgZiwgZS5pc1JUTCAmJiAhMCAhPT0gci5udW1lcmljSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gYS5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCwgaCA9IGQoYy5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGgucygpOyAhKHAgPSBoLm4oKSkuZG9uZTsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhWzBdID09PSB2ICYmIGEuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaC5lKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGguZigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gYS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgPT09IChtID0gby5jYWxsKGUsIG0sIHIpKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gfHwgKG0gPSBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBsLmNoZWNrVmFsKShuLCAhMCwgITEsIG0udG9TdHJpbmcoKS5zcGxpdChcIlwiKSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGkgPSB0aGlzLCBhID0gdGhpcy5pbnB1dG1hc2ssIHIgPSBhLm9wdHMsIHMgPSBhLl92YWx1ZUdldCghMCksIGEuc2tpcElucHV0RXZlbnQgPSAhMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuY2xpcGJvYXJkRGF0YSAmJiB0LmNsaXBib2FyZERhdGEuZ2V0RGF0YSA/IHUgPSB0LmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgOiBvLmRlZmF1bHQuY2xpcGJvYXJkRGF0YSAmJiBvLmRlZmF1bHQuY2xpcGJvYXJkRGF0YS5nZXREYXRhICYmICh1ID0gby5kZWZhdWx0LmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIikpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbihhLCBpLCBzLCB1LCByLm9uQmVmb3JlUGFzdGUpLCB0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMsIHQgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG0uYXBwbHkoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYoYSwgbiwgaSwgciwgbywgXCJuZXh0XCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdihhLCBuLCBpLCByLCBvLCBcInRocm93XCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dEZhbGxCYWNrRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2ssIG4gPSB0Lm9wdHMsIGkgPSB0LmRlcGVuZGVuY3lMaWI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSwgbyA9IHRoaXMsIHUgPSBvLmlucHV0bWFzay5fdmFsdWVHZXQoITApLCBwID0gKHQuaXNSVEwgPyBjLmdldEJ1ZmZlci5jYWxsKHQpLnNsaWNlKCkucmV2ZXJzZSgpIDogYy5nZXRCdWZmZXIuY2FsbCh0KSkuam9pbihcIlwiKSwgZCA9IGMuY2FyZXQuY2FsbCh0LCBvLCB2b2lkIDAsIHZvaWQgMCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgIT09IHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA9IGZ1bmN0aW9uKGUsIGksIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciwgbywgbCwgcyA9IGUuc3Vic3RyKDAsIGEuYmVnaW4pLnNwbGl0KFwiXCIpLCB1ID0gZS5zdWJzdHIoYS5iZWdpbikuc3BsaXQoXCJcIiksIHAgPSBpLnN1YnN0cigwLCBhLmJlZ2luKS5zcGxpdChcIlwiKSwgZCA9IGkuc3Vic3RyKGEuYmVnaW4pLnNwbGl0KFwiXCIpLCBoID0gcy5sZW5ndGggPj0gcC5sZW5ndGggPyBzLmxlbmd0aCA6IHAubGVuZ3RoLCB2ID0gdS5sZW5ndGggPj0gZC5sZW5ndGggPyB1Lmxlbmd0aCA6IGQubGVuZ3RoLCBtID0gXCJcIiwgZyA9IFtdLCB5ID0gXCJ+XCI7IHMubGVuZ3RoIDwgaDsgKSBzLnB1c2goeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO3AubGVuZ3RoIDwgaDsgKSBwLnB1c2goeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO3UubGVuZ3RoIDwgdjsgKSB1LnVuc2hpZnQoeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO2QubGVuZ3RoIDwgdjsgKSBkLnVuc2hpZnQoeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gcy5jb25jYXQodSksIGIgPSBwLmNvbmNhdChkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChvID0gMCwgciA9IGsubGVuZ3RoOyBvIDwgcjsgbysrKSBzd2l0Y2ggKGwgPSBmLmdldFBsYWNlaG9sZGVyLmNhbGwodCwgYy50cmFuc2xhdGVQb3NpdGlvbi5jYWxsKHQsIG8pKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zZXJ0VGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYltvIC0gMV0gPT09IGtbb10gJiYgYS5iZWdpbiA9PSBrLmxlbmd0aCAtIDEgJiYgZy5wdXNoKGtbb10pLCBvID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50QmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtbb10gPT09IHkgPyBhLmVuZCsrIDogbyA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrW29dICE9PSBiW29dICYmIChrW28gKyAxXSAhPT0geSAmJiBrW28gKyAxXSAhPT0gbCAmJiB2b2lkIDAgIT09IGtbbyArIDFdIHx8IChiW29dICE9PSBsIHx8IGJbbyArIDFdICE9PSB5KSAmJiBiW29dICE9PSB5ID8gYltvICsgMV0gPT09IHkgJiYgYltvXSA9PT0ga1tvICsgMV0gPyAobSA9IFwiaW5zZXJ0VGV4dFwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcucHVzaChrW29dKSwgYS5iZWdpbi0tLCBhLmVuZC0tKSA6IGtbb10gIT09IGwgJiYga1tvXSAhPT0geSAmJiAoa1tvICsgMV0gPT09IHkgfHwgYltvXSAhPT0ga1tvXSAmJiBiW28gKyAxXSA9PT0ga1tvICsgMV0pID8gKG0gPSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcucHVzaChrW29dKSwgYS5iZWdpbi0tKSA6IGtbb10gPT09IHkgPyAobSA9IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIsIChjLmlzTWFzay5jYWxsKHQsIGMudHJhbnNsYXRlUG9zaXRpb24uY2FsbCh0LCBvKSwgITApIHx8IGJbb10gPT09IG4ucmFkaXhQb2ludCkgJiYgYS5lbmQrKykgOiBvID0gciA6IChtID0gXCJpbnNlcnRUZXh0XCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZy5wdXNoKGtbb10pLCBhLmJlZ2luLS0sIGEuZW5kLS0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh1LCBwLCBkKSwgKG8uaW5wdXRtYXNrLnNoYWRvd1Jvb3QgfHwgby5vd25lckRvY3VtZW50KS5hY3RpdmVFbGVtZW50ICE9PSBvICYmIG8uZm9jdXMoKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGwud3JpdGVCdWZmZXIpKG8sIGMuZ2V0QnVmZmVyLmNhbGwodCkpLCBjLmNhcmV0LmNhbGwodCwgbywgZC5iZWdpbiwgZC5lbmQsICEwKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXIubW9iaWxlICYmIHQuc2tpcE5leHRJbnNlcnQgJiYgXCJpbnNlcnRUZXh0XCIgPT09IGUuaW5wdXRUeXBlICYmIFwiaW5zZXJ0VGV4dFwiID09PSBhLmFjdGlvbiAmJiB0LmlzQ29tcG9zaW5nKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChcImluc2VydENvbXBvc2l0aW9uVGV4dFwiID09PSBlLmlucHV0VHlwZSAmJiBcImluc2VydFRleHRcIiA9PT0gYS5hY3Rpb24gJiYgdC5pc0NvbXBvc2luZyA/IHQuc2tpcE5leHRJbnNlcnQgPSAhMCA6IHQuc2tpcE5leHRJbnNlcnQgPSAhMSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnNlcnRUZXh0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZGF0YS5mb3JFYWNoKChmdW5jdGlvbihlLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBpLkV2ZW50KFwia2V5cHJlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmtleSA9IGUsIHQuaWdub3JhYmxlID0gITEsIHkua2V5cHJlc3NFdmVudC5jYWxsKG8sIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC4kZWwudHJpZ2dlcihcImtleXVwXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gbmV3IGkuRXZlbnQoXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoLmtleSA9IHMua2V5cy5CYWNrc3BhY2UsIHkua2V5RXZlbnQuY2FsbChvLCBoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBsLmFwcGx5SW5wdXRWYWx1ZSkobywgdSksIGMuY2FyZXQuY2FsbCh0LCBvLCBkLmJlZ2luLCBkLmVuZCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2ssIG4gPSB0LmRlcGVuZGVuY3lMaWIsIGkgPSB0aGlzLCBhID0gZSAmJiBlLmRldGFpbCA/IGUuZGV0YWlsWzBdIDogYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gaS5pbnB1dG1hc2suX3ZhbHVlR2V0KCEwKSksICgwLCBsLmFwcGx5SW5wdXRWYWx1ZSkoaSwgYSwgbmV3IG4uRXZlbnQoXCJpbnB1dFwiKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgKGUuZGV0YWlsICYmIHZvaWQgMCAhPT0gZS5kZXRhaWxbMV0gfHwgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0pICYmIGMuY2FyZXQuY2FsbCh0LCBpLCBlLmRldGFpbCA/IGUuZGV0YWlsWzFdIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmlucHV0bWFzaywgbiA9IHQub3B0cywgaSA9IHQgJiYgdC5fdmFsdWVHZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uc2hvd01hc2tPbkZvY3VzICYmIGkgIT09IGMuZ2V0QnVmZmVyLmNhbGwodCkuam9pbihcIlwiKSAmJiAoMCwgbC53cml0ZUJ1ZmZlcikodGhpcywgYy5nZXRCdWZmZXIuY2FsbCh0KSwgYy5zZWVrTmV4dC5jYWxsKHQsIGMuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbCh0KSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICEwICE9PSBuLnBvc2l0aW9uQ2FyZXRPblRhYiB8fCAhMSAhPT0gdC5tb3VzZUVudGVyIHx8IHUuaXNDb21wbGV0ZS5jYWxsKHQsIGMuZ2V0QnVmZmVyLmNhbGwodCkpICYmIC0xICE9PSBjLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwodCkgfHwgeS5jbGlja0V2ZW50LmFwcGx5KHRoaXMsIFsgZSwgITAgXSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgdC51bmRvVmFsdWUgPSB0ICYmIHQuX3ZhbHVlR2V0KCEwKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0bWFzay52YWxpZGF0aW9uRXZlbnQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbW91c2VsZWF2ZUV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5pbnB1dG1hc2ssIHQgPSBlLm9wdHMsIG4gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tb3VzZUVudGVyID0gITEsIHQuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgJiYgKG4uaW5wdXRtYXNrLnNoYWRvd1Jvb3QgfHwgbi5vd25lckRvY3VtZW50KS5hY3RpdmVFbGVtZW50ICE9PSBuICYmICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGwuSGFuZGxlTmF0aXZlUGxhY2Vob2xkZXIpKG4sIGUub3JpZ2luYWxQbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrRXZlbnQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5pbnB1dG1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLmNsaWNrZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaS5pbnB1dG1hc2suc2hhZG93Um9vdCB8fCBpLm93bmVyRG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGMuZGV0ZXJtaW5lTmV3Q2FyZXRQb3NpdGlvbi5jYWxsKG4sIGMuY2FyZXQuY2FsbChuLCBpKSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBhICYmIGMuY2FyZXQuY2FsbChuLCBpLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY3V0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2ssIG4gPSB0Lm1hc2tzZXQsIGkgPSB0aGlzLCBhID0gYy5jYXJldC5jYWxsKHQsIGkpLCByID0gdC5pc1JUTCA/IGMuZ2V0QnVmZmVyLmNhbGwodCkuc2xpY2UoYS5lbmQsIGEuYmVnaW4pIDogYy5nZXRCdWZmZXIuY2FsbCh0KS5zbGljZShhLmJlZ2luLCBhLmVuZCksIGYgPSB0LmlzUlRMID8gci5yZXZlcnNlKCkuam9pbihcIlwiKSA6IHIuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uZGVmYXVsdC5uYXZpZ2F0b3IgJiYgby5kZWZhdWx0Lm5hdmlnYXRvci5jbGlwYm9hcmQgPyBvLmRlZmF1bHQubmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoZikgOiBvLmRlZmF1bHQuY2xpcGJvYXJkRGF0YSAmJiBvLmRlZmF1bHQuY2xpcGJvYXJkRGF0YS5nZXREYXRhICYmIG8uZGVmYXVsdC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJUZXh0XCIsIGYpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHUuaGFuZGxlUmVtb3ZlLmNhbGwodCwgaSwgcy5rZXlzLkRlbGV0ZSwgYSksICgwLCBsLndyaXRlQnVmZmVyKShpLCBjLmdldEJ1ZmZlci5jYWxsKHQpLCBuLnAsIGUsIHQudW5kb1ZhbHVlICE9PSB0Ll92YWx1ZUdldCghMCkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBibHVyRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2ssIG4gPSB0Lm9wdHMsIGkgPSB0LmRlcGVuZGVuY3lMaWI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LmNsaWNrZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpKHRoaXMpLCByID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmlucHV0bWFzaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBsLkhhbmRsZU5hdGl2ZVBsYWNlaG9sZGVyKShyLCB0Lm9yaWdpbmFsUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gci5pbnB1dG1hc2suX3ZhbHVlR2V0KCksIHMgPSBjLmdldEJ1ZmZlci5jYWxsKHQpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiAhPT0gbyAmJiAobi5jbGVhck1hc2tPbkxvc3RGb2N1cyAmJiAoLTEgPT09IGMuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbCh0KSAmJiBvID09PSBjLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwodCkuam9pbihcIlwiKSA/IHMgPSBbXSA6IGwuY2xlYXJPcHRpb25hbFRhaWwuY2FsbCh0LCBzKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICExID09PSB1LmlzQ29tcGxldGUuY2FsbCh0LCBzKSAmJiAoc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEudHJpZ2dlcihcImluY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApLCBuLmNsZWFySW5jb21wbGV0ZSAmJiAoYy5yZXNldE1hc2tTZXQuY2FsbCh0LCAhMSksIHMgPSBuLmNsZWFyTWFza09uTG9zdEZvY3VzID8gW10gOiBjLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwodCkuc2xpY2UoKSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbC53cml0ZUJ1ZmZlcikociwgcywgdm9pZCAwLCBlKSksIG8gPSB0Ll92YWx1ZUdldCghMCksIHQudW5kb1ZhbHVlICE9PSBvICYmIChcIlwiICE9IG8gfHwgdC51bmRvVmFsdWUgIT0gYy5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHQpLmpvaW4oXCJcIikgfHwgdC51bmRvVmFsdWUgPT0gYy5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHQpLmpvaW4oXCJcIikgJiYgdC5tYXNrc2V0LnZhbGlkUG9zaXRpb25zLmxlbmd0aCA+IDApICYmICh0LnVuZG9WYWx1ZSA9IG8sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEudHJpZ2dlcihcImNoYW5nZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZW50ZXJFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuaW5wdXRtYXNrLCB0ID0gZS5vcHRzLnNob3dNYXNrT25Ib3ZlciwgbiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5tb3VzZUVudGVyID0gITAsIChuLmlucHV0bWFzay5zaGFkb3dSb290IHx8IG4ub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCAhPT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gKGUuaXNSVEwgPyBjLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoZSkuc2xpY2UoKS5yZXZlcnNlKCkgOiBjLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoZSkpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCAmJiAoMCwgbC5IYW5kbGVOYXRpdmVQbGFjZWhvbGRlcikobiwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pdEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5pbnB1dG1hc2ssIHQgPSBlLm9wdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnVuZG9WYWx1ZSAhPT0gZS5fdmFsdWVHZXQoITApICYmIGUuJGVsLnRyaWdnZXIoXCJjaGFuZ2VcIiksIC0xID09PSBjLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoZSkgJiYgZS5fdmFsdWVHZXQgJiYgZS5fdmFsdWVHZXQoKSA9PT0gYy5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGUpLmpvaW4oXCJcIikgJiYgZS5fdmFsdWVTZXQoXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgdC5jbGVhckluY29tcGxldGUgJiYgITEgPT09IHUuaXNDb21wbGV0ZS5jYWxsKGUsIGMuZ2V0QnVmZmVyLmNhbGwoZSkpICYmIGUuX3ZhbHVlU2V0KFwiXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHQucmVtb3ZlTWFza09uU3VibWl0ICYmIChlLl92YWx1ZVNldChlLnVubWFza2VkdmFsdWUoKSwgITApLCBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbC53cml0ZUJ1ZmZlcikoZS5lbCwgYy5nZXRCdWZmZXIuY2FsbChlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXNldEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5pbnB1dG1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnJlZnJlc2hWYWx1ZSA9ICEwLCBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbC5hcHBseUlucHV0VmFsdWUpKGUuZWwsIGUuX3ZhbHVlR2V0KCEwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDk3MTY6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuRXZlbnRSdWxlciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgaSwgYSA9IG4oNzc2MCksIHIgPSAoaSA9IG4oMjM5NCkpICYmIGkuX19lc01vZHVsZSA/IGkgOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGlcbiAgICAgICAgICAgICAgICB9LCBvID0gbigyODM5KSwgbCA9IG4oODcxMSk7XG4gICAgICAgICAgICAgICAgdC5FdmVudFJ1bGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBvbjogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLmlucHV0bWFzay5kZXBlbmRlbmN5TGliLCBzID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQub3JpZ2luYWxFdmVudCAmJiAodCA9IHQub3JpZ2luYWxFdmVudCB8fCB0LCBhcmd1bWVudHNbMF0gPSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcywgYyA9IHRoaXMsIHUgPSBjLmlucHV0bWFzaywgZiA9IHUgPyB1Lm9wdHMgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdSAmJiBcIkZPUk1cIiAhPT0gdGhpcy5ub2RlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGkuZGF0YShjLCBcIl9pbnB1dG1hc2tfb3B0c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaShjKS5vZmYoKSwgcCAmJiBuZXcgci5kZWZhdWx0KHApLm1hc2soYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFsgXCJzdWJtaXRcIiwgXCJyZXNldFwiLCBcInNldHZhbHVlXCIgXS5pbmNsdWRlcyh0LnR5cGUpIHx8IFwiRk9STVwiID09PSB0aGlzLm5vZGVOYW1lIHx8ICEoYy5kaXNhYmxlZCB8fCBjLnJlYWRPbmx5ICYmICEoXCJrZXlkb3duXCIgPT09IHQudHlwZSAmJiB0LmN0cmxLZXkgJiYgdC5rZXkgPT09IG8ua2V5cy5jIHx8ICExID09PSBmLnRhYlRocm91Z2ggJiYgdC5rZXkgPT09IG8ua2V5cy5UYWIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSB1LnNraXBJbnB1dEV2ZW50KSByZXR1cm4gdS5za2lwSW5wdXRFdmVudCA9ICExLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsaWNrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb2N1c1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1LnZhbGlkYXRpb25FdmVudCA/ICh1LnZhbGlkYXRpb25FdmVudCA9ICExLCBlLmJsdXIoKSwgKDAsIGEuSGFuZGxlTmF0aXZlUGxhY2Vob2xkZXIpKGUsICh1LmlzUlRMID8gbC5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHUpLnNsaWNlKCkucmV2ZXJzZSgpIDogbC5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHUpKS5qb2luKFwiXCIpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgZi52YWxpZGF0aW9uRXZlbnRUaW1lT3V0KSwgITEpIDogKHMgPSBhcmd1bWVudHMsIHZvaWQgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrICYmIG4uYXBwbHkoYywgcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gbi5hcHBseShjLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExID09PSBkICYmICh0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCkpLCBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgWyBcInN1Ym1pdFwiLCBcInJlc2V0XCIgXS5pbmNsdWRlcyh0KSA/IChzID0gcy5iaW5kKGUpLCBudWxsICE9PSBlLmZvcm0gJiYgaShlLmZvcm0pLm9uKHQsIHMpKSA6IGkoZSkub24odCwgcyksIFxuICAgICAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2suZXZlbnRzW3RdID0gZS5pbnB1dG1hc2suZXZlbnRzW3RdIHx8IFtdLCBlLmlucHV0bWFzay5ldmVudHNbdF0ucHVzaChzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb2ZmOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5pbnB1dG1hc2sgJiYgZS5pbnB1dG1hc2suZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmlucHV0bWFzay5kZXBlbmRlbmN5TGliLCBpID0gZS5pbnB1dG1hc2suZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgaW4gdCAmJiAoKGkgPSBbXSlbdF0gPSBlLmlucHV0bWFzay5ldmVudHNbdF0pLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSBpW2FdOyByLmxlbmd0aCA+IDA7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSByLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBcInN1Ym1pdFwiLCBcInJlc2V0XCIgXS5pbmNsdWRlcyhhKSA/IG51bGwgIT09IGUuZm9ybSAmJiBuKGUuZm9ybSkub2ZmKGEsIG8pIDogbihlKS5vZmYoYSwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGUuaW5wdXRtYXNrLmV2ZW50c1thXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDIxOTogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgIHZhciBpID0gcChuKDcxODQpKSwgYSA9IHAobigyMzk0KSksIHIgPSBuKDI4MzkpLCBvID0gbig4NzExKSwgbCA9IG4oNDcxMyk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcyhlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgIH0oZSkgfHwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBudWxsID09IGUgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGVbU3ltYm9sLml0ZXJhdG9yXSB8fCBlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgYSwgciwgbywgbCA9IFtdLCBzID0gITAsIGMgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IChuID0gbi5jYWxsKGUpKS5uZXh0LCAwID09PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KG4pICE9PSBuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBmb3IgKDshKHMgPSAoaSA9IHIuY2FsbChuKSkuZG9uZSkgJiYgKGwucHVzaChpLnZhbHVlKSwgbC5sZW5ndGggIT09IHQpOyBzID0gITApIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAhMCwgYSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcyAmJiBudWxsICE9IG4ucmV0dXJuICYmIChvID0gbi5yZXR1cm4oKSwgT2JqZWN0KG8pICE9PSBvKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMpIHRocm93IGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0oZSwgdCkgfHwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgcmV0dXJuIGMoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBuICYmIGUuY29uc3RydWN0b3IgJiYgKG4gPSBlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiTWFwXCIgPT09IG4gfHwgXCJTZXRcIiA9PT0gbikgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJBcmd1bWVudHNcIiA9PT0gbiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGMoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIH0oZSwgdCkgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSB0IHx8IHQgPiBlLmxlbmd0aCkgJiYgKHQgPSBlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gbmV3IEFycmF5KHQpOyBuIDwgdDsgbisrKSBpW25dID0gZVtuXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIGUuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBlICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9LCB1KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRbbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpLmVudW1lcmFibGUgPSBpLmVudW1lcmFibGUgfHwgITEsIGkuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBpICYmIChpLndyaXRhYmxlID0gITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAoYSA9IGkua2V5LCByID0gdm9pZCAwLCByID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB1KGUpIHx8IG51bGwgPT09IGUpIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB1KGkpKSByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHQgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShhLCBcInN0cmluZ1wiKSwgXCJzeW1ib2xcIiA9PT0gdShyKSA/IHIgOiBTdHJpbmcocikpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYSwgcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4oMTMxMyk7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBhLmRlZmF1bHQuZGVwZW5kZW5jeUxpYiwgaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBlKHQsIG4sIGksIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBlKSwgdGhpcy5tYXNrID0gdCwgdGhpcy5mb3JtYXQgPSBuLCB0aGlzLm9wdHMgPSBpLCB0aGlzLmlucHV0bWFzayA9IGEsIHRoaXMuX2RhdGUgPSBuZXcgRGF0ZSgxLCAwLCAxKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXREYXRlT2JqZWN0KHQsIHRoaXMub3B0cywgdGhpcy5pbnB1dG1hc2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0LCBuLCBpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA9IGUsIChuID0gWyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSB0aGlzLl9kYXRlICYmICh0aGlzLl9kYXRlID0gbmV3IERhdGUoMSwgMCwgMSksIHRoaXMuaW5pdERhdGVPYmplY3Qodm9pZCAwLCB0aGlzLm9wdHMsIHRoaXMuaW5wdXRtYXNrKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJpbml0RGF0ZU9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKFAodCkubGFzdEluZGV4ID0gMDsgaSA9IFAodCkuZXhlYyh0aGlzLmZvcm1hdCk7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IC9cXGQrJC8uZXhlYyhpWzBdKSwgciA9IGEgPyBpWzBdWzBdICsgXCJ4XCIgOiBpWzBdLCBvID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gUCh0KS5sYXN0SW5kZXgsIGMgPSBqLmNhbGwobiwgaS5pbmRleCwgdCwgbiAmJiBuLm1hc2tzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAodCkubGFzdEluZGV4ID0gcywgbyA9IGUuc2xpY2UoMCwgZS5pbmRleE9mKGMubmV4dE1hdGNoWzBdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHUgPSBpWzBdWzBdLCBmID0gaS5pbmRleDsgbiAmJiAodC5wbGFjZWhvbGRlcltsLmdldFRlc3QuY2FsbChuLCBmKS5tYXRjaC5wbGFjZWhvbGRlcl0gfHwgbC5nZXRUZXN0LmNhbGwobiwgZikubWF0Y2gucGxhY2Vob2xkZXIpID09PSB1OyApIGYrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGYgLSBpLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBlLnNsaWNlKDAsIHAgfHwgeVtyXSAmJiB5W3JdWzRdIHx8IHIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlLnNsaWNlKG8ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeSwgcikgJiYgdGhpcy5zZXRWYWx1ZSh0aGlzLCBvLCByLCB5W3JdWzJdLCB5W3JdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJzZXRWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGUsIHQsIG4sIGksIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSB0KSBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhbXBtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVbaV0gPSB0LCBlW1wicmF3XCIgKyBpXSA9IHQucmVwbGFjZSgvXFxzL2csIFwiX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtb250aFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJtbW1cIiA9PT0gbiB8fCBcIm1tbW1cIiA9PT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZVtpXSA9IF8oXCJtbW1cIiA9PT0gbiA/IG0ubW9udGhOYW1lcy5zbGljZSgwLCAxMikuZmluZEluZGV4KChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKSA9PT0gZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpICsgMSA6IG0ubW9udGhOYW1lcy5zbGljZSgxMiwgMjQpLmZpbmRJbmRleCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCkgPT09IGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSArIDEsIDIpLCBlW2ldID0gXCIwMFwiID09PSBlW2ldID8gXCJcIiA6IGVbaV0udG9TdHJpbmcoKSwgZVtcInJhd1wiICsgaV0gPSBlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZVtpXSA9IHQucmVwbGFjZSgvW14wLTldL2csIFwiMFwiKSwgZVtcInJhd1wiICsgaV0gPSB0LnJlcGxhY2UoL1xccy9nLCBcIl9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJkYXlcIiA9PT0gaSAmJiAyOSA9PT0gcGFyc2VJbnQocikgfHwgXCJtb250aFwiID09PSBpICYmIDIgPT09IHBhcnNlSW50KHIpKSAmJiAoMjkgIT09IHBhcnNlSW50KGUuZGF5KSB8fCAyICE9PSBwYXJzZUludChlLm1vbnRoKSB8fCBcIlwiICE9PSBlLnllYXIgJiYgdm9pZCAwICE9PSBlLnllYXIgfHwgZS5fZGF0ZS5zZXRGdWxsWWVhcigyMDEyLCAxLCAyOSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXlcIiA9PT0gaSAmJiAoZyA9ICEwLCAwID09PSBwYXJzZUludChyKSAmJiAociA9IDEpKSwgXCJtb250aFwiID09PSBpICYmIChnID0gITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ5ZWFyXCIgPT09IGkgJiYgKGcgPSAhMCwgci5sZW5ndGggPCB5W25dWzRdICYmIChyID0gXyhyLCB5W25dWzRdLCAhMCkpKSwgKFwiXCIgIT09IHIgJiYgIWlzTmFOKHIpIHx8IFwiYW1wbVwiID09PSBpKSAmJiBhLmNhbGwoZS5fZGF0ZSwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwicmVzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRlID0gbmV3IERhdGUoMSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJyZUluaXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRlID0gdm9pZCAwLCB0aGlzLmRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gXSkgJiYgZih0LnByb3RvdHlwZSwgbiksIGkgJiYgZih0LCBpKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMVxuICAgICAgICAgICAgICAgICAgICB9KSwgZTtcbiAgICAgICAgICAgICAgICB9KCksIHYgPSAobmV3IERhdGUpLmdldEZ1bGxZZWFyKCksIG0gPSBhLmRlZmF1bHQucHJvdG90eXBlLmkxOG4sIGcgPSAhMSwgeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZDogWyBcIlsxLTldfFsxMl1bMC05XXwzWzAxXVwiLCBEYXRlLnByb3RvdHlwZS5zZXREYXRlLCBcImRheVwiLCBEYXRlLnByb3RvdHlwZS5nZXREYXRlIF0sXG4gICAgICAgICAgICAgICAgICAgIGRkOiBbIFwiMFsxLTldfFsxMl1bMC05XXwzWzAxXVwiLCBEYXRlLnByb3RvdHlwZS5zZXREYXRlLCBcImRheVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfKERhdGUucHJvdG90eXBlLmdldERhdGUuY2FsbCh0aGlzKSwgMik7XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgZGRkOiBbIFwiXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgZGRkZDogWyBcIlwiIF0sXG4gICAgICAgICAgICAgICAgICAgIG06IFsgXCJbMS05XXwxWzAxMl1cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlID8gcGFyc2VJbnQoZSkgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPiAwICYmIHQtLSwgRGF0ZS5wcm90b3R5cGUuc2V0TW9udGguY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgXCJtb250aFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS5nZXRNb250aC5jYWxsKHRoaXMpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBtbTogWyBcIjBbMS05XXwxWzAxMl1cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlID8gcGFyc2VJbnQoZSkgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPiAwICYmIHQtLSwgRGF0ZS5wcm90b3R5cGUuc2V0TW9udGguY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgXCJtb250aFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfKERhdGUucHJvdG90eXBlLmdldE1vbnRoLmNhbGwodGhpcykgKyAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBtbW06IFsgbS5tb250aE5hbWVzLnNsaWNlKDAsIDEyKS5qb2luKFwifFwiKSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBtLm1vbnRoTmFtZXMuc2xpY2UoMCwgMTIpLmZpbmRJbmRleCgoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnRvTG93ZXJDYXNlKCkgPT09IHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMSAhPT0gdCAmJiBEYXRlLnByb3RvdHlwZS5zZXRNb250aC5jYWxsKHRoaXMsIHQpO1xuICAgICAgICAgICAgICAgICAgICB9LCBcIm1vbnRoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ubW9udGhOYW1lcy5zbGljZSgwLCAxMilbRGF0ZS5wcm90b3R5cGUuZ2V0TW9udGguY2FsbCh0aGlzKV07XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgbW1tbTogWyBtLm1vbnRoTmFtZXMuc2xpY2UoMTIsIDI0KS5qb2luKFwifFwiKSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBtLm1vbnRoTmFtZXMuc2xpY2UoMTIsIDI0KS5maW5kSW5kZXgoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS50b0xvd2VyQ2FzZSgpID09PSB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgIT09IHQgJiYgRGF0ZS5wcm90b3R5cGUuc2V0TW9udGguY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgXCJtb250aFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLm1vbnRoTmFtZXMuc2xpY2UoMTIsIDI0KVtEYXRlLnByb3RvdHlwZS5nZXRNb250aC5jYWxsKHRoaXMpXTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICB5eTogWyBcIlswLTldezJ9XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gKG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkuc2xpY2UoMCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBEYXRlLnByb3RvdHlwZS5zZXRGdWxsWWVhci5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KHQpLmNvbmNhdChlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIFwieWVhclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfKERhdGUucHJvdG90eXBlLmdldEZ1bGxZZWFyLmNhbGwodGhpcyksIDIpO1xuICAgICAgICAgICAgICAgICAgICB9LCAyIF0sXG4gICAgICAgICAgICAgICAgICAgIHl5eXk6IFsgXCJbMC05XXs0fVwiLCBEYXRlLnByb3RvdHlwZS5zZXRGdWxsWWVhciwgXCJ5ZWFyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8oRGF0ZS5wcm90b3R5cGUuZ2V0RnVsbFllYXIuY2FsbCh0aGlzKSwgNCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDQgXSxcbiAgICAgICAgICAgICAgICAgICAgaDogWyBcIlsxLTldfDFbMC0yXVwiLCBEYXRlLnByb3RvdHlwZS5zZXRIb3VycywgXCJob3Vyc1wiLCBEYXRlLnByb3RvdHlwZS5nZXRIb3VycyBdLFxuICAgICAgICAgICAgICAgICAgICBoaDogWyBcIjBbMS05XXwxWzAtMl1cIiwgRGF0ZS5wcm90b3R5cGUuc2V0SG91cnMsIFwiaG91cnNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXyhEYXRlLnByb3RvdHlwZS5nZXRIb3Vycy5jYWxsKHRoaXMpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBoeDogWyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbMC05XXtcIi5jb25jYXQoZSwgXCJ9XCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCBEYXRlLnByb3RvdHlwZS5zZXRIb3VycywgXCJob3Vyc1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUuZ2V0SG91cnM7XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgSDogWyBcIjE/WzAtOV18MlswLTNdXCIsIERhdGUucHJvdG90eXBlLnNldEhvdXJzLCBcImhvdXJzXCIsIERhdGUucHJvdG90eXBlLmdldEhvdXJzIF0sXG4gICAgICAgICAgICAgICAgICAgIEhIOiBbIFwiMFswLTldfDFbMC05XXwyWzAtM11cIiwgRGF0ZS5wcm90b3R5cGUuc2V0SG91cnMsIFwiaG91cnNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXyhEYXRlLnByb3RvdHlwZS5nZXRIb3Vycy5jYWxsKHRoaXMpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBIeDogWyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbMC05XXtcIi5jb25jYXQoZSwgXCJ9XCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCBEYXRlLnByb3RvdHlwZS5zZXRIb3VycywgXCJob3Vyc1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8oRGF0ZS5wcm90b3R5cGUuZ2V0SG91cnMuY2FsbCh0aGlzKSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgIE06IFsgXCJbMS01XT9bMC05XVwiLCBEYXRlLnByb3RvdHlwZS5zZXRNaW51dGVzLCBcIm1pbnV0ZXNcIiwgRGF0ZS5wcm90b3R5cGUuZ2V0TWludXRlcyBdLFxuICAgICAgICAgICAgICAgICAgICBNTTogWyBcIjBbMC05XXwxWzAtOV18MlswLTldfDNbMC05XXw0WzAtOV18NVswLTldXCIsIERhdGUucHJvdG90eXBlLnNldE1pbnV0ZXMsIFwibWludXRlc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfKERhdGUucHJvdG90eXBlLmdldE1pbnV0ZXMuY2FsbCh0aGlzKSwgMik7XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgczogWyBcIlsxLTVdP1swLTldXCIsIERhdGUucHJvdG90eXBlLnNldFNlY29uZHMsIFwic2Vjb25kc1wiLCBEYXRlLnByb3RvdHlwZS5nZXRTZWNvbmRzIF0sXG4gICAgICAgICAgICAgICAgICAgIHNzOiBbIFwiMFswLTldfDFbMC05XXwyWzAtOV18M1swLTldfDRbMC05XXw1WzAtOV1cIiwgRGF0ZS5wcm90b3R5cGUuc2V0U2Vjb25kcywgXCJzZWNvbmRzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8oRGF0ZS5wcm90b3R5cGUuZ2V0U2Vjb25kcy5jYWxsKHRoaXMpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBsOiBbIFwiWzAtOV17M31cIiwgRGF0ZS5wcm90b3R5cGUuc2V0TWlsbGlzZWNvbmRzLCBcIm1pbGxpc2Vjb25kc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfKERhdGUucHJvdG90eXBlLmdldE1pbGxpc2Vjb25kcy5jYWxsKHRoaXMpLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMyBdLFxuICAgICAgICAgICAgICAgICAgICBMOiBbIFwiWzAtOV17Mn1cIiwgRGF0ZS5wcm90b3R5cGUuc2V0TWlsbGlzZWNvbmRzLCBcIm1pbGxpc2Vjb25kc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfKERhdGUucHJvdG90eXBlLmdldE1pbGxpc2Vjb25kcy5jYWxsKHRoaXMpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMiBdLFxuICAgICAgICAgICAgICAgICAgICB0OiBbIFwiW2FwXVwiLCBiLCBcImFtcG1cIiwgeCwgMSBdLFxuICAgICAgICAgICAgICAgICAgICB0dDogWyBcIlthcF1tXCIsIGIsIFwiYW1wbVwiLCB4LCAyIF0sXG4gICAgICAgICAgICAgICAgICAgIFQ6IFsgXCJbQVBdXCIsIGIsIFwiYW1wbVwiLCB4LCAxIF0sXG4gICAgICAgICAgICAgICAgICAgIFRUOiBbIFwiW0FQXU1cIiwgYiwgXCJhbXBtXCIsIHgsIDIgXSxcbiAgICAgICAgICAgICAgICAgICAgWjogWyBcIi4qXCIsIHZvaWQgMCwgXCJaXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnRvU3RyaW5nKCkubWF0Y2goL1xcKCguKylcXCkvKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5jbHVkZXMoXCIgXCIpICYmIChlID0gKGUgPSBlLnJlcGxhY2UoXCItXCIsIFwiIFwiKS50b1VwcGVyQ2FzZSgpKS5zcGxpdChcIiBcIikubWFwKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMoZSwgMSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBvOiBbIFwiXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgUzogWyBcIlwiIF1cbiAgICAgICAgICAgICAgICB9LCBrID0ge1xuICAgICAgICAgICAgICAgICAgICBpc29EYXRlOiBcInl5eXktbW0tZGRcIixcbiAgICAgICAgICAgICAgICAgICAgaXNvVGltZTogXCJISDpNTTpzc1wiLFxuICAgICAgICAgICAgICAgICAgICBpc29EYXRlVGltZTogXCJ5eXl5LW1tLWRkJ1QnSEg6TU06c3NcIixcbiAgICAgICAgICAgICAgICAgICAgaXNvVXRjRGF0ZVRpbWU6IFwiVVRDOnl5eXktbW0tZGQnVCdISDpNTTpzcydaJ1wiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmdldEhvdXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInBcIikgPyB0aGlzLnNldEhvdXJzKHQgKyAxMikgOiBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJhXCIpICYmIHQgPj0gMTIgJiYgdGhpcy5zZXRIb3Vycyh0IC0gMTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB4KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlID0gZSB8fCAxMikgPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHcoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IC9cXGQrJC8uZXhlYyhlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgdm9pZCAwICE9PSB0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHlbZVswXVswXSArIFwieFwiXS5zbGljZShcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuWzBdID0gblswXSh0WzBdKSwgblszXSA9IG5bM10odFswXSksIG47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHlbZVswXV0pIHJldHVybiB5W2VbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBQKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlLnRva2VuaXplcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBbXSwgbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB5KSBpZiAoL1xcLip4JC8udGVzdChpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gaVswXSArIFwiXFxcXGQrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgPT09IG4uaW5kZXhPZihhKSAmJiBuLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLTEgPT09IHQuaW5kZXhPZihpWzBdKSAmJiB0LnB1c2goaVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnRva2VuaXplciA9IFwiKFwiICsgKG4ubGVuZ3RoID4gMCA/IG4uam9pbihcInxcIikgKyBcInxcIiA6IFwiXCIpICsgdC5qb2luKFwiK3xcIikgKyBcIikrP3wuXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZS50b2tlbml6ZXIgPSBuZXcgUmVnRXhwKGUudG9rZW5pemVyLCBcImdcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudG9rZW5pemVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBTKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUucmF3ZGF5IHx8ICFpc0Zpbml0ZShlLnJhd2RheSkgJiYgbmV3IERhdGUoZS5kYXRlLmdldEZ1bGxZZWFyKCksIGlzRmluaXRlKGUucmF3bW9udGgpID8gZS5tb250aCA6IGUuZGF0ZS5nZXRNb250aCgpICsgMSwgMCkuZ2V0RGF0ZSgpID49IGUuZGF5IHx8IFwiMjlcIiA9PSBlLmRheSAmJiAoIWlzRmluaXRlKGUucmF3eWVhcikgfHwgdm9pZCAwID09PSBlLnJhd3llYXIgfHwgXCJcIiA9PT0gZS5yYXd5ZWFyKSB8fCBuZXcgRGF0ZShlLmRhdGUuZ2V0RnVsbFllYXIoKSwgaXNGaW5pdGUoZS5yYXdtb250aCkgPyBlLm1vbnRoIDogZS5kYXRlLmdldE1vbnRoKCkgKyAxLCAwKS5nZXREYXRlKCkgPj0gZS5kYXkpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCIyOVwiID09IGUuZGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGouY2FsbCh0aGlzLCB0LnBvcywgbiwgdGhpcy5tYXNrc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpLnRhcmdldE1hdGNoICYmIFwieXl5eVwiID09PSBpLnRhcmdldE1hdGNoWzBdICYmIHQucG9zIC0gaS50YXJnZXRNYXRjaEluZGV4ID09IDIpIHJldHVybiB0LnJlbW92ZSA9IHQucG9zICsgMSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDIgPT0gZS5kYXRlLmdldE1vbnRoKCkgJiYgXCIzMFwiID09IGUuZGF5ICYmIHZvaWQgMCAhPT0gdC5jKSByZXR1cm4gZS5kYXkgPSBcIjAzXCIsIFxuICAgICAgICAgICAgICAgICAgICBlLmRhdGUuc2V0RGF0ZSgzKSwgZS5kYXRlLnNldE1vbnRoKDEpLCB0Lmluc2VydCA9IFsge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0LnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGM6IFwiMFwiXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdC5wb3MgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYzogdC5jXG4gICAgICAgICAgICAgICAgICAgIH0gXSwgdC5jYXJldCA9IG8uc2Vla05leHQuY2FsbCh0aGlzLCB0LnBvcyArIDEpLCB0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE8oZSwgdCwgbiwgYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciwgbywgbCA9IFwiXCIsIHMgPSAwLCBjID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoUChuKS5sYXN0SW5kZXggPSAwOyByID0gUChuKS5leGVjKGUpOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHQpIGlmIChvID0gdyhyKSkgbCArPSBcIihcIiArIG9bMF0gKyBcIilcIiwgbi5wbGFjZWhvbGRlciAmJiBcIlwiICE9PSBuLnBsYWNlaG9sZGVyID8gKGNbc10gPSBuLnBsYWNlaG9sZGVyW3IuaW5kZXggJSBuLnBsYWNlaG9sZGVyLmxlbmd0aF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgY1tuLnBsYWNlaG9sZGVyW3IuaW5kZXggJSBuLnBsYWNlaG9sZGVyLmxlbmd0aF1dID0gclswXS5jaGFyQXQoMCkpIDogY1tzXSA9IHJbMF0uY2hhckF0KDApOyBlbHNlIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgKz0gXCIoXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIl1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsICs9IFwiKT9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgKz0gKDAsIGkuZGVmYXVsdCkoclswXSksIGNbc10gPSByWzBdLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobyA9IHcocikpIGlmICghMCAhPT0gYSAmJiBvWzNdKSBsICs9IG9bM10uY2FsbCh0LmRhdGUpOyBlbHNlIG9bMl0gPyBsICs9IHRbXCJyYXdcIiArIG9bMl1dIDogbCArPSByWzBdOyBlbHNlIGwgKz0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSB0ICYmIChuLnBsYWNlaG9sZGVyID0gYyksIGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF8oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGUgPSBTdHJpbmcoZSksIHQgPSB0IHx8IDI7IGUubGVuZ3RoIDwgdDsgKSBlID0gbiA/IGUgKyBcIjBcIiA6IFwiMFwiICsgZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE0oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IG5ldyBoKGUsIHQsIG4sIHRoaXMpIDogZSAmJiBcIm9iamVjdFwiID09PSB1KGUpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBcImRhdGVcIikgPyBlIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBFKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE8odC5pbnB1dEZvcm1hdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogZVxuICAgICAgICAgICAgICAgICAgICB9LCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBhLCByID0gdGhpcywgbyA9IG4gJiYgbi50ZXN0c1tlXSA/IHQucGxhY2Vob2xkZXJbbi50ZXN0c1tlXVswXS5tYXRjaC5wbGFjZWhvbGRlcl0gfHwgbi50ZXN0c1tlXVswXS5tYXRjaC5wbGFjZWhvbGRlciA6IFwiXCIsIHMgPSAwLCBjID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChQKHQpLmxhc3RJbmRleCA9IDA7IGEgPSBQKHQpLmV4ZWModC5pbnB1dEZvcm1hdCk7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSAvXFxkKyQvLmV4ZWMoYVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodSkgYyA9IHBhcnNlSW50KHVbMF0pOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmID0gYVswXVswXSwgcCA9IHM7IHIgJiYgKHQucGxhY2Vob2xkZXJbbC5nZXRUZXN0LmNhbGwociwgcCkubWF0Y2gucGxhY2Vob2xkZXJdIHx8IGwuZ2V0VGVzdC5jYWxsKHIsIHApLm1hdGNoLnBsYWNlaG9sZGVyKSA9PT0gZjsgKSBwKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA9PT0gKGMgPSBwIC0gcykgJiYgKGMgPSBhWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyArPSBjLCAtMSAhPSBhWzBdLmluZGV4T2YobykgfHwgcyA+PSBlICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBhLCBhID0gUCh0KS5leGVjKHQuaW5wdXRGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaEluZGV4OiBzIC0gYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRNYXRjaDogYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hdGNoOiBpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEuZGVmYXVsdC5leHRlbmRBbGlhc2VzKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZXRpbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5udW1lcmljSW5wdXQgPSAhMSwgeS5TID0gbS5vcmRpbmFsU3VmZml4LmpvaW4oXCJ8XCIpLCBlLmlucHV0Rm9ybWF0ID0ga1tlLmlucHV0Rm9ybWF0XSB8fCBlLmlucHV0Rm9ybWF0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXlGb3JtYXQgPSBrW2UuZGlzcGxheUZvcm1hdF0gfHwgZS5kaXNwbGF5Rm9ybWF0IHx8IGUuaW5wdXRGb3JtYXQsIGUub3V0cHV0Rm9ybWF0ID0ga1tlLm91dHB1dEZvcm1hdF0gfHwgZS5vdXRwdXRGb3JtYXQgfHwgZS5pbnB1dEZvcm1hdCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5yZWdleCA9IE8oZS5pbnB1dEZvcm1hdCwgdm9pZCAwLCBlKSwgZS5taW4gPSBNKGUubWluLCBlLmlucHV0Rm9ybWF0LCBlKSwgZS5tYXggPSBNKGUubWF4LCBlLmlucHV0Rm9ybWF0LCBlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBcImlzb0RhdGVUaW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Rm9ybWF0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9ybWF0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVZhbGlkYXRpb246IGZ1bmN0aW9uKGUsIHQsIG4sIGksIGEsIHIsIG8sIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihuKSAmJiBlW3RdICE9PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gai5jYWxsKHRoaXMsIHQsIGEsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5uZXh0TWF0Y2ggJiYgcy5uZXh0TWF0Y2hbMF0gPT09IG4gJiYgcy50YXJnZXRNYXRjaFswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHcocy50YXJnZXRNYXRjaClbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChjKS50ZXN0KFwiMFwiICsgZVt0IC0gMV0pKSByZXR1cm4gZVt0XSA9IGVbdCAtIDFdLCBlW3QgLSAxXSA9IFwiMFwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdXp6eTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hGcm9tQnVmZmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0IC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB0ICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0ICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdFZhbGlkYXRpb246IGZ1bmN0aW9uKGUsIHQsIG4sIGksIGEsIHIsIG8sIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYywgdSwgZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8pIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgPT09IGkgJiYgKCgoYyA9IGouY2FsbChmLCB0ICsgMSwgYSwgcikpLnRhcmdldE1hdGNoICYmIGMudGFyZ2V0TWF0Y2hJbmRleCA9PT0gdCAmJiBjLnRhcmdldE1hdGNoWzBdLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSB5W2MudGFyZ2V0TWF0Y2hbMF1dIHx8IChjID0gai5jYWxsKGYsIHQgKyAyLCBhLCByKSkudGFyZ2V0TWF0Y2ggJiYgYy50YXJnZXRNYXRjaEluZGV4ID09PSB0ICsgMSAmJiBjLnRhcmdldE1hdGNoWzBdLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSB5W2MudGFyZ2V0TWF0Y2hbMF1dKSAmJiAodSA9IHcoYy50YXJnZXRNYXRjaClbMF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHUgJiYgKHZvaWQgMCAhPT0gci52YWxpZFBvc2l0aW9uc1t0ICsgMV0gJiYgbmV3IFJlZ0V4cCh1KS50ZXN0KG4gKyBcIjBcIikgPyAoZVt0XSA9IG4sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVbdCArIDFdID0gXCIwXCIsIGkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdCArIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBuZXcgUmVnRXhwKHUpLnRlc3QoXCIwXCIgKyBuKSAmJiAoZVt0XSA9IFwiMFwiLCBlW3QgKyAxXSA9IG4sIGkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdCArIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksICExID09PSBpKSkgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkuZnV6enkgJiYgKGUgPSBpLmJ1ZmZlciwgdCA9IGkucG9zKSwgKGMgPSBqLmNhbGwoZiwgdCwgYSwgcikpLnRhcmdldE1hdGNoICYmIGMudGFyZ2V0TWF0Y2hbMF0gJiYgdm9pZCAwICE9PSB5W2MudGFyZ2V0TWF0Y2hbMF1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gdyhjLnRhcmdldE1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gZS5zbGljZShjLnRhcmdldE1hdGNoSW5kZXgsIGMudGFyZ2V0TWF0Y2hJbmRleCArIGMudGFyZ2V0TWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCExID09PSBuZXcgUmVnRXhwKHUpLnRlc3QoZC5qb2luKFwiXCIpKSAmJiAyID09PSBjLnRhcmdldE1hdGNoWzBdLmxlbmd0aCAmJiByLnZhbGlkUG9zaXRpb25zW2MudGFyZ2V0TWF0Y2hJbmRleF0gJiYgci52YWxpZFBvc2l0aW9uc1tjLnRhcmdldE1hdGNoSW5kZXggKyAxXSAmJiAoci52YWxpZFBvc2l0aW9uc1tjLnRhcmdldE1hdGNoSW5kZXggKyAxXS5pbnB1dCA9IFwiMFwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieWVhclwiID09IHBbMl0pIGZvciAodmFyIGggPSBsLmdldE1hc2tUZW1wbGF0ZS5jYWxsKGYsICExLCAxLCB2b2lkIDAsICEwKSwgbSA9IHQgKyAxOyBtIDwgZS5sZW5ndGg7IG0rKykgZVttXSA9IGhbbV0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnZhbGlkUG9zaXRpb25zLnNwbGljZSh0ICsgMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnID0gaSwgayA9IE0uY2FsbChmLCBlLmpvaW4oXCJcIiksIGEuaW5wdXRGb3JtYXQsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnICYmICFpc05hTihrLmRhdGUuZ2V0VGltZSgpKSAmJiAoYS5wcmVmaWxsWWVhciAmJiAoZyA9IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUueWVhciAhPT0gZS5yYXd5ZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHYudG9TdHJpbmcoKSwgYSA9IGUucmF3eWVhci5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIiksIHIgPSBpLnNsaWNlKDAsIGEubGVuZ3RoKSwgbyA9IGkuc2xpY2UoYS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDIgPT09IGEubGVuZ3RoICYmIGEgPT09IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IG5ldyBEYXRlKHYsIGUubW9udGggLSAxLCBlLmRheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXkgPT0gbC5nZXREYXRlKCkgJiYgKCFuLm1heCB8fCBuLm1heC5kYXRlLmdldFRpbWUoKSA+PSBsLmdldFRpbWUoKSkgJiYgKGUuZGF0ZS5zZXRGdWxsWWVhcih2KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS55ZWFyID0gaSwgdC5pbnNlcnQgPSBbIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0LnBvcyArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IG9bMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdC5wb3MgKyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBvWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGssIGcsIGEpKSwgZyA9IGZ1bmN0aW9uKGUsIHQsIG4sIGksIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0KSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgbi5taW4gJiYgIWlzTmFOKG4ubWluLmRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGUucmVzZXQoKSwgUChuKS5sYXN0SW5kZXggPSAwOyByID0gUChuKS5leGVjKG4uaW5wdXRGb3JtYXQpOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG8gPSB3KHIpKSAmJiBvWzNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSBvWzFdLCBzID0gZVtvWzJdXSwgYyA9IG4ubWluW29bMl1dLCB1ID0gbi5tYXggPyBuLm1heFtvWzJdXSA6IGMgKyAxLCBmID0gW10sIHAgPSAhMSwgZCA9IDA7IGQgPCBjLmxlbmd0aDsgZCsrKSB2b2lkIDAgIT09IGkudmFsaWRQb3NpdGlvbnNbZCArIHIuaW5kZXhdIHx8IHAgPyAoZltkXSA9IHNbZF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcCB8fCBzW2RdID4gY1tkXSkgOiAoZCArIHIuaW5kZXggPT0gMCAmJiBzW2RdIDwgY1tkXSA/IChmW2RdID0gc1tkXSwgcCA9ICEwKSA6IGZbZF0gPSBjW2RdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ5ZWFyXCIgPT09IG9bMl0gJiYgcy5sZW5ndGggLSAxID09IGQgJiYgYyAhPSB1ICYmIChmID0gKHBhcnNlSW50KGYuam9pbihcIlwiKSkgKyAxKS50b1N0cmluZygpLnNwbGl0KFwiXCIpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYW1wbVwiID09PSBvWzJdICYmIGMgIT0gdSAmJiBuLm1pbi5kYXRlLmdldFRpbWUoKSA+IGUuZGF0ZS5nZXRUaW1lKCkgJiYgKGZbZF0gPSB1W2RdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwuY2FsbChlLl9kYXRlLCBmLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBuLm1pbi5kYXRlLmdldFRpbWUoKSA8PSBlLmRhdGUuZ2V0VGltZSgpLCBlLnJlSW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICYmIG4ubWF4ICYmIChpc05hTihuLm1heC5kYXRlLmdldFRpbWUoKSkgfHwgKHQgPSBuLm1heC5kYXRlLmdldFRpbWUoKSA+PSBlLmRhdGUuZ2V0VGltZSgpKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oaywgZyA9IFMuY2FsbChmLCBrLCBnLCBhKSwgYSwgcikpLCB2b2lkIDAgIT09IHQgJiYgZyAmJiBpLnBvcyAhPT0gdCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBPKGEuaW5wdXRGb3JtYXQsIGssIGEpLnNwbGl0KFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoRnJvbUJ1ZmZlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGkucG9zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogaS5jYXJldCB8fCBpLnBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bjogZnVuY3Rpb24oZSwgdCwgbiwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY3RybEtleSAmJiBlLmtleSA9PT0gci5rZXlzLkFycm93UmlnaHQgJiYgKHRoaXMuaW5wdXRtYXNrLl92YWx1ZVNldChFKG5ldyBEYXRlLCBpKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQodGhpcykudHJpZ2dlcihcInNldHZhbHVlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvblVuTWFzazogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ID8gTyhuLm91dHB1dEZvcm1hdCwgTS5jYWxsKHRoaXMsIGUsIG4uaW5wdXRGb3JtYXQsIG4pLCBuLCAhMCkgOiB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2luZzogZnVuY3Rpb24oZSwgdCwgbiwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09IHQubmF0aXZlRGVmLmluZGV4T2YoXCJbYXBdXCIpKSByZXR1cm4gZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09IHQubmF0aXZlRGVmLmluZGV4T2YoXCJbQVBdXCIpKSByZXR1cm4gZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gbC5nZXRUZXN0LmNhbGwodGhpcywgWyBuIC0gMSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCA9PSBhLm1hdGNoLmRlZi5pbmRleE9mKFwiW0FQXVwiKSB8fCAwID09PSBuIHx8IGEgJiYgYS5pbnB1dCA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZShyLmtleUNvZGUuU3BhY2UpIHx8IGEgJiYgYS5tYXRjaC5kZWYgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoci5rZXlDb2RlLlNwYWNlKSA/IGUudG9VcHBlckNhc2UoKSA6IGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZU1hc2s6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IERhdGVdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSAmJiAoZSA9IEUoZSwgdCkpLCBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydE1vZGU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TW9kZVZpc3VhbDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFBvc2l0aW9uczogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwU3RhdGljOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0bW9kZTogXCJudW1lcmljXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaWxsWWVhcjogITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDEzMTM6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgYSA9IChpID0gbigyMzk0KSkgJiYgaS5fX2VzTW9kdWxlID8gaSA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYS5kZWZhdWx0LmRlcGVuZGVuY3lMaWIuZXh0ZW5kKCEwLCBhLmRlZmF1bHQucHJvdG90eXBlLmkxOG4sIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5TmFtZXM6IFsgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiLCBcIlN1bmRheVwiIF0sXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoTmFtZXM6IFsgXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIiwgXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiIF0sXG4gICAgICAgICAgICAgICAgICAgIG9yZGluYWxTdWZmaXg6IFsgXCJzdFwiLCBcIm5kXCIsIFwicmRcIiwgXCJ0aFwiIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAzODUxOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGEgPSAoaSA9IG4oMjM5NCkpICYmIGkuX19lc01vZHVsZSA/IGkgOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGlcbiAgICAgICAgICAgICAgICB9LCByID0gbig4NzExKSwgbyA9IG4oNDcxMyk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkgcmV0dXJuIHMoZSk7XG4gICAgICAgICAgICAgICAgICAgIH0oZSkgfHwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IGVbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IGVbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShlKTtcbiAgICAgICAgICAgICAgICAgICAgfShlKSB8fCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSByZXR1cm4gcyhlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IG4gJiYgZS5jb25zdHJ1Y3RvciAmJiAobiA9IGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJNYXBcIiA9PT0gbiB8fCBcIlNldFwiID09PSBuKSByZXR1cm4gQXJyYXkuZnJvbShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIkFyZ3VtZW50c1wiID09PSBuIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gcyhlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfShlKSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSB0IHx8IHQgPiBlLmxlbmd0aCkgJiYgKHQgPSBlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gbmV3IEFycmF5KHQpOyBuIDwgdDsgbisrKSBpW25dID0gZVtuXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEuZGVmYXVsdC5leHRlbmREZWZpbml0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgIEE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogXCJbQS1aYS16XFx1MDQxMC1cXHUwNDRmXFx1MDQwMVxcdTA0NTFcXHhjMC1cXHhmZlxceGI1XVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBcInVwcGVyXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCImXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogXCJbMC05QS1aYS16XFx1MDQxMC1cXHUwNDRmXFx1MDQwMVxcdTA0NTFcXHhjMC1cXHhmZlxceGI1XVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBcInVwcGVyXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCIjXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogXCJbMC05QS1GYS1mXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBcInVwcGVyXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBjID0gLzI1WzAtNV18MlswLTRdWzAtOV18WzAxXVswLTldWzAtOV0vO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSwgdCwgbiwgaSwgYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobiAtIDEgPiAtMSAmJiBcIi5cIiAhPT0gdC5idWZmZXJbbiAtIDFdID8gKGUgPSB0LmJ1ZmZlcltuIC0gMV0gKyBlLCBlID0gbiAtIDIgPiAtMSAmJiBcIi5cIiAhPT0gdC5idWZmZXJbbiAtIDJdID8gdC5idWZmZXJbbiAtIDJdICsgZSA6IFwiMFwiICsgZSkgOiBlID0gXCIwMFwiICsgZSwgXG4gICAgICAgICAgICAgICAgICAgIGEuZ3JlZWR5ICYmIHBhcnNlSW50KGUpID4gMjU1ICYmIGMudGVzdChcIjAwXCIgKyBlLmNoYXJBdCgyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gW10uY29uY2F0KGwodC5idWZmZXIuc2xpY2UoMCwgbikpLCBbIFwiLlwiLCBlLmNoYXJBdCgyKSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmpvaW4oXCJcIikubWF0Y2goL1xcLi9nKS5sZW5ndGggPCA0KSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hGcm9tQnVmZmVyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQ6IG4gKyAyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnRlc3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEuZGVmYXVsdC5leHRlbmRBbGlhc2VzKHtcbiAgICAgICAgICAgICAgICAgICAgY3NzdW5pdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXg6IFwiWystXT9bMC05XStcXFxcLj8oWzAtOV0rKT8ocHh8ZW18cmVtfGV4fCV8aW58Y218bW18cHR8cGMpXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleDogXCIoaHR0cHM/fGZ0cCk6Ly8uKlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1VubWFzazogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwU3RhdGljOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYlRocm91Z2g6ICEwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBcIml7MSwzfS5qezEsM30ua3sxLDN9Lmx7MSwzfVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgajoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IHVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiB1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvblVuTWFzazogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0bW9kZTogXCJkZWNpbWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFwiOiBcIi5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbWFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5zZXBhcmF0b3IsIG4gPSBlLnF1YW50aWZpZXIsIGkgPSBcIip7MSw2NH1bLip7MSw2NH1dWy4qezEsNjR9XVsuKnsxLDYzfV1ALXsxLDYzfS4tezEsNjN9Wy4tezEsNjN9XVsuLXsxLDYzfV1cIiwgYSA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQpIGZvciAodmFyIHIgPSAwOyByIDwgbjsgcisrKSBhICs9IFwiW1wiLmNvbmNhdCh0KS5jb25jYXQoaSwgXCJdXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZWVkeTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IFwibG93ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aWZpZXI6IDUsXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVQYXN0ZTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZSA9IGUudG9Mb3dlckNhc2UoKSkucmVwbGFjZShcIm1haWx0bzpcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIipcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiWzAtOVxcdWZmMTEtXFx1ZmYxOUEtWmEtelxcdTA0MTAtXFx1MDQ0ZlxcdTA0MDFcXHUwNDUxXFx4YzAtXFx4ZmZcXHhiNSEjJCUmJyorLz0/Xl9ge3x9fi1dXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogXCJbMC05QS1aYS16LV1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvblVuTWFzazogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0bW9kZTogXCJlbWFpbFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1hYzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzazogXCIjIzojIzojIzojIzojIzojI1wiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzazogXCJWezEzfTl7NH1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiW0EtSEotTlBSLVphLWhqLW5wci16XFxcXGRdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2luZzogXCJ1cHBlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW5jb21wbGV0ZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvVW5tYXNrOiAhMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzc246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2s6IFwiOTk5LTk5LTk5OTlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RWYWxpZGF0aW9uOiBmdW5jdGlvbihlLCB0LCBuLCBpLCBhLCBsLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBvLmdldE1hc2tUZW1wbGF0ZS5jYWxsKHRoaXMsICEwLCByLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwodGhpcyksICEwLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9eKD8hMjE5LTA5LTk5OTl8MDc4LTA1LTExMjApKD8hNjY2fDAwMHw5LnsyfSkuezN9LSg/ITAwKS57Mn0tKD8hMHs0fSkuezR9JC8udGVzdChjLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMjA3OiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBsKG4oNzE4NCkpLCBhID0gbChuKDIzOTQpKSwgciA9IG4oMjgzOSksIG8gPSBuKDg3MTEpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcyA9IGEuZGVmYXVsdC5kZXBlbmRlbmN5TGliO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gXCJcIiwgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSBhLmRlZmF1bHQucHJvdG90eXBlLmRlZmluaXRpb25zW2UuY2hhckF0KGkpXSB8fCB0LmRlZmluaXRpb25zW2UuY2hhckF0KGkpXSB8fCB0Lm9wdGlvbmFsbWFya2VyWzBdID09PSBlLmNoYXJBdChpKSB8fCB0Lm9wdGlvbmFsbWFya2VyWzFdID09PSBlLmNoYXJBdChpKSB8fCB0LnF1YW50aWZpZXJtYXJrZXJbMF0gPT09IGUuY2hhckF0KGkpIHx8IHQucXVhbnRpZmllcm1hcmtlclsxXSA9PT0gZS5jaGFyQXQoaSkgfHwgdC5ncm91cG1hcmtlclswXSA9PT0gZS5jaGFyQXQoaSkgfHwgdC5ncm91cG1hcmtlclsxXSA9PT0gZS5jaGFyQXQoaSkgfHwgdC5hbHRlcm5hdG9ybWFya2VyID09PSBlLmNoYXJBdChpKSA/IG4gKz0gXCJcXFxcXCIgKyBlLmNoYXJBdChpKSA6IG4gKz0gZS5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUsIHQsIG4sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubGVuZ3RoID4gMCAmJiB0ID4gMCAmJiAoIW4uZGlnaXRzT3B0aW9uYWwgfHwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZS5pbmRleE9mKG4ucmFkaXhQb2ludCksIHIgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4ubmVnYXRpb25TeW1ib2wuYmFjayA9PT0gZVtlLmxlbmd0aCAtIDFdICYmIChyID0gITAsIGUubGVuZ3RoLS0pLCAtMSA9PT0gYSAmJiAoZS5wdXNoKG4ucmFkaXhQb2ludCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMTsgbyA8PSB0OyBvKyspIGlzRmluaXRlKGVbYSArIG9dKSB8fCAoZVthICsgb10gPSBcIjBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgJiYgZS5wdXNoKG4ubmVnYXRpb25TeW1ib2wuYmFjayksIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gXCIrXCIgPT09IGUgJiYgKG4gPSBvLnNlZWtOZXh0LmNhbGwodGhpcywgdC52YWxpZFBvc2l0aW9ucy5sZW5ndGggLSAxKSksIFxuICAgICAgICAgICAgICAgICAgICB0LnRlc3RzKSBpZiAoKGkgPSBwYXJzZUludChpKSkgPj0gbikgZm9yICh2YXIgYSA9IDAsIHIgPSB0LnRlc3RzW2ldLmxlbmd0aDsgYSA8IHI7IGErKykgaWYgKCh2b2lkIDAgPT09IHQudmFsaWRQb3NpdGlvbnNbaV0gfHwgXCItXCIgPT09IGUpICYmIHQudGVzdHNbaV1bYV0ubWF0Y2guZGVmID09PSBlKSByZXR1cm4gaSArICh2b2lkIDAgIT09IHQudmFsaWRQb3NpdGlvbnNbaV0gJiYgXCItXCIgIT09IGUgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IC0xLCBpID0gMCwgYSA9IHQudmFsaWRQb3NpdGlvbnMubGVuZ3RoOyBpIDwgYTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHQudmFsaWRQb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociAmJiByLm1hdGNoLmRlZiA9PT0gZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkKGUsIHQsIG4sIGksIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0LmJ1ZmZlciA/IHQuYnVmZmVyLmluZGV4T2YoYS5yYWRpeFBvaW50KSA6IC0xLCBvID0gKC0xICE9PSByIHx8IGkgJiYgYS5qaXRNYXNraW5nKSAmJiBuZXcgUmVnRXhwKGEuZGVmaW5pdGlvbnNbOV0udmFsaWRhdG9yKS50ZXN0KGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWkgJiYgYS5fcmFkaXhEYW5jZSAmJiAtMSAhPT0gciAmJiBvICYmIG51bGwgPT0gdC52YWxpZFBvc2l0aW9uc1tyXSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogciA9PT0gbiA/IHIgKyAxIDogcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBhLnJhZGl4UG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IG5cbiAgICAgICAgICAgICAgICAgICAgfSA6IG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEuZGVmYXVsdC5leHRlbmRBbGlhc2VzKHtcbiAgICAgICAgICAgICAgICAgICAgbnVtZXJpYzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucmVwZWF0ID0gMCwgZS5ncm91cFNlcGFyYXRvciA9PT0gZS5yYWRpeFBvaW50ICYmIGUuZGlnaXRzICYmIFwiMFwiICE9PSBlLmRpZ2l0cyAmJiAoXCIuXCIgPT09IGUucmFkaXhQb2ludCA/IGUuZ3JvdXBTZXBhcmF0b3IgPSBcIixcIiA6IFwiLFwiID09PSBlLnJhZGl4UG9pbnQgPyBlLmdyb3VwU2VwYXJhdG9yID0gXCIuXCIgOiBlLmdyb3VwU2VwYXJhdG9yID0gXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiID09PSBlLmdyb3VwU2VwYXJhdG9yICYmIChlLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIgPSB2b2lkIDApLCBlLnBsYWNlaG9sZGVyLmxlbmd0aCA+IDEgJiYgKGUucGxhY2Vob2xkZXIgPSBlLnBsYWNlaG9sZGVyLmNoYXJBdCgwKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmFkaXhGb2N1c1wiID09PSBlLnBvc2l0aW9uQ2FyZXRPbkNsaWNrICYmIFwiXCIgPT09IGUucGxhY2Vob2xkZXIgJiYgKGUucG9zaXRpb25DYXJldE9uQ2xpY2sgPSBcImx2cFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IFwiMFwiLCBuID0gZS5yYWRpeFBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEwID09PSBlLm51bWVyaWNJbnB1dCAmJiB2b2lkIDAgPT09IGUuX19maW5hbmNlSW5wdXQgPyAodCA9IFwiMVwiLCBlLnBvc2l0aW9uQ2FyZXRPbkNsaWNrID0gXCJyYWRpeEZvY3VzXCIgPT09IGUucG9zaXRpb25DYXJldE9uQ2xpY2sgPyBcImx2cFwiIDogZS5wb3NpdGlvbkNhcmV0T25DbGljaywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kaWdpdHNPcHRpb25hbCA9ICExLCBpc05hTihlLmRpZ2l0cykgJiYgKGUuZGlnaXRzID0gMiksIGUuX3JhZGl4RGFuY2UgPSAhMSwgbiA9IFwiLFwiID09PSBlLnJhZGl4UG9pbnQgPyBcIj9cIiA6IFwiIVwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiICE9PSBlLnJhZGl4UG9pbnQgJiYgdm9pZCAwID09PSBlLmRlZmluaXRpb25zW25dICYmIChlLmRlZmluaXRpb25zW25dID0ge30sIGUuZGVmaW5pdGlvbnNbbl0udmFsaWRhdG9yID0gXCJbXCIgKyBlLnJhZGl4UG9pbnQgKyBcIl1cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kZWZpbml0aW9uc1tuXS5wbGFjZWhvbGRlciA9IGUucmFkaXhQb2ludCwgZS5kZWZpbml0aW9uc1tuXS5zdGF0aWMgPSAhMCwgZS5kZWZpbml0aW9uc1tuXS5nZW5lcmF0ZWQgPSAhMCkpIDogKGUuX19maW5hbmNlSW5wdXQgPSAhMSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5udW1lcmljSW5wdXQgPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEsIHIgPSBcIlsrXVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyICs9IGMoZS5wcmVmaXgsIGUpLCBcIlwiICE9PSBlLmdyb3VwU2VwYXJhdG9yID8gKHZvaWQgMCA9PT0gZS5kZWZpbml0aW9uc1tlLmdyb3VwU2VwYXJhdG9yXSAmJiAoZS5kZWZpbml0aW9uc1tlLmdyb3VwU2VwYXJhdG9yXSA9IHt9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRlZmluaXRpb25zW2UuZ3JvdXBTZXBhcmF0b3JdLnZhbGlkYXRvciA9IFwiW1wiICsgZS5ncm91cFNlcGFyYXRvciArIFwiXVwiLCBlLmRlZmluaXRpb25zW2UuZ3JvdXBTZXBhcmF0b3JdLnBsYWNlaG9sZGVyID0gZS5ncm91cFNlcGFyYXRvciwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kZWZpbml0aW9uc1tlLmdyb3VwU2VwYXJhdG9yXS5zdGF0aWMgPSAhMCwgZS5kZWZpbml0aW9uc1tlLmdyb3VwU2VwYXJhdG9yXS5nZW5lcmF0ZWQgPSAhMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gZS5fbWFzayhlKSkgOiByICs9IFwiOXsrfVwiLCB2b2lkIDAgIT09IGUuZGlnaXRzICYmIDAgIT09IGUuZGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZS5kaWdpdHMudG9TdHJpbmcoKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmluaXRlKG9bMF0pICYmIG9bMV0gJiYgaXNGaW5pdGUob1sxXSkgPyByICs9IG4gKyB0ICsgXCJ7XCIgKyBlLmRpZ2l0cyArIFwifVwiIDogKGlzTmFOKGUuZGlnaXRzKSB8fCBwYXJzZUludChlLmRpZ2l0cykgPiAwKSAmJiAoZS5kaWdpdHNPcHRpb25hbCB8fCBlLmppdE1hc2tpbmcgPyAoYSA9IHIgKyBuICsgdCArIFwiezAsXCIgKyBlLmRpZ2l0cyArIFwifVwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5rZWVwU3RhdGljID0gITApIDogciArPSBuICsgdCArIFwie1wiICsgZS5kaWdpdHMgKyBcIn1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGUuaW5wdXRtb2RlID0gXCJudW1lcmljXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgKz0gYyhlLnN1ZmZpeCwgZSksIHIgKz0gXCJbLV1cIiwgYSAmJiAociA9IFsgYSArIGMoZS5zdWZmaXgsIGUpICsgXCJbLV1cIiwgciBdKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5ncmVlZHkgPSAhMSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGUucGFyc2VNaW5NYXhPcHRpb25zICYmIChudWxsICE9PSBlLm1pbiAmJiAoZS5taW4gPSBlLm1pbi50b1N0cmluZygpLnJlcGxhY2UobmV3IFJlZ0V4cCgoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuZGVmYXVsdCkoZS5ncm91cFNlcGFyYXRvciksIFwiZ1wiKSwgXCJcIiksIFwiLFwiID09PSBlLnJhZGl4UG9pbnQgJiYgKGUubWluID0gZS5taW4ucmVwbGFjZShlLnJhZGl4UG9pbnQsIFwiLlwiKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm1pbiA9IGlzRmluaXRlKGUubWluKSA/IHBhcnNlRmxvYXQoZS5taW4pIDogTmFOLCBpc05hTihlLm1pbikgJiYgKGUubWluID0gTnVtYmVyLk1JTl9WQUxVRSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZS5tYXggJiYgKGUubWF4ID0gZS5tYXgudG9TdHJpbmcoKS5yZXBsYWNlKG5ldyBSZWdFeHAoKDAsIGkuZGVmYXVsdCkoZS5ncm91cFNlcGFyYXRvciksIFwiZ1wiKSwgXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcIiA9PT0gZS5yYWRpeFBvaW50ICYmIChlLm1heCA9IGUubWF4LnJlcGxhY2UoZS5yYWRpeFBvaW50LCBcIi5cIikpLCBlLm1heCA9IGlzRmluaXRlKGUubWF4KSA/IHBhcnNlRmxvYXQoZS5tYXgpIDogTmFOLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOYU4oZS5tYXgpICYmIChlLm1heCA9IE51bWJlci5NQVhfVkFMVUUpKSwgZS5wYXJzZU1pbk1heE9wdGlvbnMgPSBcImRvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlKSwgXCJcIiAhPT0gZS5yYWRpeFBvaW50ICYmIGUuc3Vic3RpdHV0ZVJhZGl4UG9pbnQgJiYgKGUuc3Vic3RpdHV0ZXNbXCIuXCIgPT0gZS5yYWRpeFBvaW50ID8gXCIsXCIgOiBcIi5cIl0gPSBlLnJhZGl4UG9pbnQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tYXNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKFwiICsgZS5ncm91cFNlcGFyYXRvciArIFwiOTk5KXsrfDF9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzOiBcIipcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0c09wdGlvbmFsOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZm9yY2VEaWdpdHNPbkJsdXI6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXhQb2ludDogXCIuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkNhcmV0T25DbGljazogXCJyYWRpeEZvY3VzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBfcmFkaXhEYW5jZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cFNlcGFyYXRvcjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93TWludXM6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmVnYXRpb25TeW1ib2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9udDogXCItXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFjazogXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFNldE1heE9uT3ZlcmZsb3c6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bm1hc2tBc051bWJlcjogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZGluZ0ZOOiBNYXRoLnJvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRtb2RlOiBcImRlY2ltYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IFwiMTAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG06IFwiMTAwMDAwMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JlZWR5OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0QWxpZ246ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TW9kZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvVW5tYXNrOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VQcm90b3R5cGVEZWZpbml0aW9uczogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpcExlYWRpbmdaZXJvZXM6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVJhZGl4UG9pbnQ6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25TeW1ib2w6IFwiOVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogXCJbMC05XFx1ZmYxMC1cXHVmZjE5XFx1MDY2MC1cXHUwNjY5XFx1MDZmMC1cXHUwNmY5XVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uU3ltYm9sOiBcIipcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIrXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbihlLCB0LCBuLCBpLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5hbGxvd01pbnVzICYmIChcIi1cIiA9PT0gZSB8fCBlID09PSBhLm5lZ2F0aW9uU3ltYm9sLmZyb250KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCItXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbihlLCB0LCBuLCBpLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5hbGxvd01pbnVzICYmIGUgPT09IGEubmVnYXRpb25TeW1ib2wuYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVWYWxpZGF0aW9uOiBmdW5jdGlvbihlLCB0LCBuLCBpLCBhLCByLCBvLCBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0gYS5fX2ZpbmFuY2VJbnB1dCAmJiBuID09PSBhLnJhZGl4UG9pbnQpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGUuaW5kZXhPZihhLnJhZGl4UG9pbnQpLCB1ID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA9IGZ1bmN0aW9uKGUsIHQsIG4sIGksIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuX3JhZGl4RGFuY2UgJiYgYS5udW1lcmljSW5wdXQgJiYgdCAhPT0gYS5uZWdhdGlvblN5bWJvbC5iYWNrICYmIGUgPD0gbiAmJiAobiA+IDAgfHwgdCA9PSBhLnJhZGl4UG9pbnQpICYmICh2b2lkIDAgPT09IGkudmFsaWRQb3NpdGlvbnNbZSAtIDFdIHx8IGkudmFsaWRQb3NpdGlvbnNbZSAtIDFdLmlucHV0ICE9PSBhLm5lZ2F0aW9uU3ltYm9sLmJhY2spICYmIChlIC09IDEpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHQsIG4sIGMsIHIsIGEpLCBcIi1cIiA9PT0gbiB8fCBuID09PSBhLm5lZ2F0aW9uU3ltYm9sLmZyb250KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMCAhPT0gYS5hbGxvd01pbnVzKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gITEsIGggPSBwKFwiK1wiLCByKSwgdiA9IHAoXCItXCIsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgIT09IGggJiYgKGQgPSBbIGggXSwgLTEgIT09IHYgJiYgZC5wdXNoKHYpKSwgITEgIT09IGQgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmU6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldDogdSAtIGEubmVnYXRpb25TeW1ib2wuYmFjay5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydDogWyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBmLmNhbGwocywgXCIrXCIsIHIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IGEubmVnYXRpb25TeW1ib2wuZnJvbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUlzVmFsaWQ6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBmLmNhbGwocywgXCItXCIsIHIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IGEubmVnYXRpb25TeW1ib2wuYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tSXNWYWxpZDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldDogdSArIGEubmVnYXRpb25TeW1ib2wuYmFjay5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IGEuZ3JvdXBTZXBhcmF0b3IpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiB1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gYyAmJiAhMCA9PT0gYS5fcmFkaXhEYW5jZSAmJiAhMSA9PT0gaSAmJiBuID09PSBhLnJhZGl4UG9pbnQgJiYgdm9pZCAwICE9PSBhLmRpZ2l0cyAmJiAoaXNOYU4oYS5kaWdpdHMpIHx8IHBhcnNlSW50KGEuZGlnaXRzKSA+IDApICYmIGMgIT09IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBmLmNhbGwocywgYS5yYWRpeFBvaW50LCByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIudmFsaWRQb3NpdGlvbnNbbV0gJiYgKHIudmFsaWRQb3NpdGlvbnNbbV0uZ2VuZXJhdGVkSW5wdXQgPSByLnZhbGlkUG9zaXRpb25zW21dLmdlbmVyYXRlZCB8fCAhMSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldDogYS5fcmFkaXhEYW5jZSAmJiB0ID09PSBjIC0gMSA/IGMgKyAxIDogY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgPT09IGEuX19maW5hbmNlSW5wdXQpIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmRpZ2l0c09wdGlvbmFsKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZVBvc2l0aW9uOiBvLmVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEuZGlnaXRzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmJlZ2luID4gYyAmJiBvLmVuZCA8PSBjKSByZXR1cm4gbiA9PT0gYS5yYWRpeFBvaW50ID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGMgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUlzVmFsaWQ6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlUG9zaXRpb246IGNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZVBvc2l0aW9uOiBjICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmJlZ2luIDwgYykgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlUG9zaXRpb246IG8uYmVnaW4gLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghYS5zaG93TWFza09uSG92ZXIgJiYgIWEuc2hvd01hc2tPbkZvY3VzICYmICFhLmRpZ2l0c09wdGlvbmFsICYmIGEuZGlnaXRzID4gMCAmJiBcIlwiID09PSB0aGlzLl9fdmFsdWVHZXQuY2FsbCh0aGlzLmVsKSkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZVBvc2l0aW9uOiBjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlUG9zaXRpb246IHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RWYWxpZGF0aW9uOiBmdW5jdGlvbihlLCB0LCBuLCBpLCBhLCByLCBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCExID09PSBpKSByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBhLm1pbiB8fCBudWxsICE9PSBhLm1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGEub25Vbk1hc2soZS5zbGljZSgpLnJldmVyc2UoKS5qb2luKFwiXCIpLCB2b2lkIDAsIHMuZXh0ZW5kKHt9LCBhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hc2tBc051bWJlcjogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gYS5taW4gJiYgbCA8IGEubWluICYmIChsLnRvU3RyaW5nKCkubGVuZ3RoID4gYS5taW4udG9TdHJpbmcoKS5sZW5ndGggfHwgbCA8IDApKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBhLm1heCAmJiBsID4gYS5tYXgpIHJldHVybiAhIWEuU2V0TWF4T25PdmVyZmxvdyAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoRnJvbUJ1ZmZlcjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHUoYS5tYXgudG9TdHJpbmcoKS5yZXBsYWNlKFwiLlwiLCBhLnJhZGl4UG9pbnQpLnNwbGl0KFwiXCIpLCBhLmRpZ2l0cywgYSkucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVW5NYXNrOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgPT09IHQgJiYgITAgPT09IG4ubnVsbGFibGUpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZS5yZXBsYWNlKG4ucHJlZml4LCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9IChhID0gYS5yZXBsYWNlKG4uc3VmZml4LCBcIlwiKSkucmVwbGFjZShuZXcgUmVnRXhwKCgwLCBpLmRlZmF1bHQpKG4uZ3JvdXBTZXBhcmF0b3IpLCBcImdcIiksIFwiXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiICE9PSBuLnBsYWNlaG9sZGVyLmNoYXJBdCgwKSAmJiAoYSA9IGEucmVwbGFjZShuZXcgUmVnRXhwKG4ucGxhY2Vob2xkZXIuY2hhckF0KDApLCBcImdcIiksIFwiMFwiKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4udW5tYXNrQXNOdW1iZXIgPyAoXCJcIiAhPT0gbi5yYWRpeFBvaW50ICYmIC0xICE9PSBhLmluZGV4T2Yobi5yYWRpeFBvaW50KSAmJiAoYSA9IGEucmVwbGFjZShpLmRlZmF1bHQuY2FsbCh0aGlzLCBuLnJhZGl4UG9pbnQpLCBcIi5cIikpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gKGEgPSBhLnJlcGxhY2UobmV3IFJlZ0V4cChcIl5cIiArICgwLCBpLmRlZmF1bHQpKG4ubmVnYXRpb25TeW1ib2wuZnJvbnQpKSwgXCItXCIpKS5yZXBsYWNlKG5ldyBSZWdFeHAoKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuZGVmYXVsdCkobi5uZWdhdGlvblN5bWJvbC5iYWNrKSArIFwiJFwiKSwgXCJcIiksIE51bWJlcihhKSkgOiBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGxldGU6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9ICh0Lm51bWVyaWNJbnB1dCA/IGUuc2xpY2UoKS5yZXZlcnNlKCkgOiBlKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuID0gKG4gPSAobiA9IChuID0gKG4gPSBuLnJlcGxhY2UobmV3IFJlZ0V4cChcIl5cIiArICgwLCBpLmRlZmF1bHQpKHQubmVnYXRpb25TeW1ib2wuZnJvbnQpKSwgXCItXCIpKS5yZXBsYWNlKG5ldyBSZWdFeHAoKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuZGVmYXVsdCkodC5uZWdhdGlvblN5bWJvbC5iYWNrKSArIFwiJFwiKSwgXCJcIikpLnJlcGxhY2UodC5wcmVmaXgsIFwiXCIpKS5yZXBsYWNlKHQuc3VmZml4LCBcIlwiKSkucmVwbGFjZShuZXcgUmVnRXhwKCgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLmRlZmF1bHQpKHQuZ3JvdXBTZXBhcmF0b3IpICsgXCIoWzAtOV17M30pXCIsIFwiZ1wiKSwgXCIkMVwiKSwgXCIsXCIgPT09IHQucmFkaXhQb2ludCAmJiAobiA9IG4ucmVwbGFjZSgoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5kZWZhdWx0KSh0LnJhZGl4UG9pbnQpLCBcIi5cIikpLCBpc0Zpbml0ZShuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZU1hc2s6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbnVsbCAhPT0gKG4gPSBlKSAmJiB2b2lkIDAgIT09IG4gPyBuIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHQucmFkaXhQb2ludCB8fCBcIixcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Zpbml0ZSh0LmRpZ2l0cykgJiYgKHQuZGlnaXRzID0gcGFyc2VJbnQodC5kaWdpdHMpKSwgXCJudW1iZXJcIiAhPSB0eXBlb2YgZSAmJiBcIm51bWJlclwiICE9PSB0LmlucHV0VHlwZSB8fCBcIlwiID09PSBhIHx8IChlID0gZS50b1N0cmluZygpLnJlcGxhY2UoXCIuXCIsIGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IFwiLVwiID09PSBlLmNoYXJBdCgwKSB8fCBlLmNoYXJBdCgwKSA9PT0gdC5uZWdhdGlvblN5bWJvbC5mcm9udCwgbyA9IGUuc3BsaXQoYSksIGwgPSBvWzBdLnJlcGxhY2UoL1teXFwtMC05XS9nLCBcIlwiKSwgcyA9IG8ubGVuZ3RoID4gMSA/IG9bMV0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpIDogXCJcIiwgYyA9IG8ubGVuZ3RoID4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbCArIChcIlwiICE9PSBzID8gYSArIHMgOiBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgIT09IGEgJiYgKGYgPSB0LmRpZ2l0c09wdGlvbmFsID8gdC5kaWdpdHMgPCBzLmxlbmd0aCA/IHQuZGlnaXRzIDogcy5sZW5ndGggOiB0LmRpZ2l0cywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiAhPT0gcyB8fCAhdC5kaWdpdHNPcHRpb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBNYXRoLnBvdygxMCwgZiB8fCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGUucmVwbGFjZSgoMCwgaS5kZWZhdWx0KShhKSwgXCIuXCIpLCBpc05hTihwYXJzZUZsb2F0KGUpKSB8fCAoZSA9ICh0LnJvdW5kaW5nRk4ocGFyc2VGbG9hdChlKSAqIHApIC8gcCkudG9GaXhlZChmKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gZS50b1N0cmluZygpLnJlcGxhY2UoXCIuXCIsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gdC5kaWdpdHMgJiYgLTEgIT09IGUuaW5kZXhPZihhKSAmJiAoZSA9IGUuc3Vic3RyaW5nKDAsIGUuaW5kZXhPZihhKSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSB0Lm1pbiB8fCBudWxsICE9PSB0Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGUudG9TdHJpbmcoKS5yZXBsYWNlKGEsIFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gdC5taW4gJiYgZCA8IHQubWluID8gZSA9IHQubWluLnRvU3RyaW5nKCkucmVwbGFjZShcIi5cIiwgYSkgOiBudWxsICE9PSB0Lm1heCAmJiBkID4gdC5tYXggJiYgKGUgPSB0Lm1heC50b1N0cmluZygpLnJlcGxhY2UoXCIuXCIsIGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgJiYgXCItXCIgIT09IGUuY2hhckF0KDApICYmIChlID0gXCItXCIgKyBlKSwgdShlLnRvU3RyaW5nKCkuc3BsaXQoXCJcIiksIGYsIHQsIGMpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVXcml0ZTogZnVuY3Rpb24oZSwgdCwgbiwgYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHIoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgIT09IGEuX19maW5hbmNlSW5wdXQgfHwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmluZGV4T2YoYS5yYWRpeFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xICE9PSBuICYmIGUuc3BsaWNlKG4sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIlwiICE9PSBhLmdyb3VwU2VwYXJhdG9yKSBmb3IgKDstMSAhPT0gKG4gPSBlLmluZGV4T2YoYS5ncm91cFNlcGFyYXRvcikpOyApIGUuc3BsaWNlKG4sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8sIGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEuc3RyaXBMZWFkaW5nWmVyb2VzICYmIChsID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG5ldyBSZWdFeHAoXCIoXlwiICsgKFwiXCIgIT09IHQubmVnYXRpb25TeW1ib2wuZnJvbnQgPyAoMCwgaS5kZWZhdWx0KSh0Lm5lZ2F0aW9uU3ltYm9sLmZyb250KSArIFwiP1wiIDogXCJcIikgKyAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuZGVmYXVsdCkodC5wcmVmaXgpICsgXCIpKC4qKShcIiArICgwLCBpLmRlZmF1bHQpKHQuc3VmZml4KSArIChcIlwiICE9IHQubmVnYXRpb25TeW1ib2wuYmFjayA/ICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5kZWZhdWx0KSh0Lm5lZ2F0aW9uU3ltYm9sLmJhY2spICsgXCI/XCIgOiBcIlwiKSArIFwiJClcIikuZXhlYyhlLnNsaWNlKCkucmV2ZXJzZSgpLmpvaW4oXCJcIikpLCBhID0gbiA/IG5bMl0gOiBcIlwiLCByID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhICYmIChhID0gYS5zcGxpdCh0LnJhZGl4UG9pbnQuY2hhckF0KDApKVswXSwgciA9IG5ldyBSZWdFeHAoXCJeWzBcIiArIHQuZ3JvdXBTZXBhcmF0b3IgKyBcIl0qXCIpLmV4ZWMoYSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgISghciB8fCAhKHJbMF0ubGVuZ3RoID4gMSB8fCByWzBdLmxlbmd0aCA+IDAgJiYgclswXS5sZW5ndGggPCBhLmxlbmd0aCkpICYmIHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh0LCBhKSkpIGZvciAodmFyIGMgPSB0LmpvaW4oXCJcIikubGFzdEluZGV4T2YobFswXS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKSkgLSAobFswXSA9PSBsLmlucHV0ID8gMCA6IDEpLCBmID0gbFswXSA9PSBsLmlucHV0ID8gMSA6IDAsIHAgPSBsWzBdLmxlbmd0aCAtIGY7IHAgPiAwOyBwLS0pIHRoaXMubWFza3NldC52YWxpZFBvc2l0aW9ucy5zcGxpY2UoYyArIHAsIDEpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdFtjICsgcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNoZWNrdmFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBhLm1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBhLm9uVW5NYXNrKHQuc2xpY2UoKS5yZXZlcnNlKCkuam9pbihcIlwiKSwgdm9pZCAwLCBzLmV4dGVuZCh7fSwgYSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWFza0FzTnVtYmVyOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGEubWluICYmIGQgPCBhLm1pbikgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoRnJvbUJ1ZmZlcjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB1KGEubWluLnRvU3RyaW5nKCkucmVwbGFjZShcIi5cIiwgYS5yYWRpeFBvaW50KS5zcGxpdChcIlwiKSwgYS5kaWdpdHMsIGEpLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodFt0Lmxlbmd0aCAtIDFdID09PSBhLm5lZ2F0aW9uU3ltYm9sLmZyb250KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IG5ldyBSZWdFeHAoXCIoXlwiICsgKFwiXCIgIT0gYS5uZWdhdGlvblN5bWJvbC5mcm9udCA/ICgwLCBpLmRlZmF1bHQpKGEubmVnYXRpb25TeW1ib2wuZnJvbnQpICsgXCI/XCIgOiBcIlwiKSArICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuZGVmYXVsdCkoYS5wcmVmaXgpICsgXCIpKC4qKShcIiArICgwLCBpLmRlZmF1bHQpKGEuc3VmZml4KSArIChcIlwiICE9IGEubmVnYXRpb25TeW1ib2wuYmFjayA/ICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuZGVmYXVsdCkoYS5uZWdhdGlvblN5bWJvbC5iYWNrKSArIFwiP1wiIDogXCJcIikgKyBcIiQpXCIpLmV4ZWMocih0LnNsaWNlKCksICEwKS5yZXZlcnNlKCkuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwID09IChoID8gaFsyXSA6IFwiXCIpICYmIChvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hGcm9tQnVmZmVyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IFsgMCBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIlwiICE9PSBhLnJhZGl4UG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuaW5kZXhPZihhLnJhZGl4UG9pbnQpID09PSBhLnN1ZmZpeC5sZW5ndGggJiYgKG8gJiYgby5idWZmZXIgPyBvLmJ1ZmZlci5zcGxpY2UoMCwgMSArIGEuc3VmZml4Lmxlbmd0aCkgOiAodC5zcGxpY2UoMCwgMSArIGEuc3VmZml4Lmxlbmd0aCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoRnJvbUJ1ZmZlcjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiByKHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEuZW5mb3JjZURpZ2l0c09uQmx1cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSAobyA9IG8gfHwge30pICYmIG8uYnVmZmVyIHx8IHQuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnJlZnJlc2hGcm9tQnVmZmVyID0gITAsIG8uYnVmZmVyID0gdSh2LCBhLmRpZ2l0cywgYSwgITApLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleURvd246IGZ1bmN0aW9uKGUsIHQsIG4sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSwgbyA9IHModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDMgIT0gZS5sb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCwgYyA9IGUua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGwgPSBpLnNob3J0Y3V0cyAmJiBpLnNob3J0Y3V0c1tjXSkgJiYgbC5sZW5ndGggPiAxKSByZXR1cm4gdGhpcy5pbnB1dG1hc2suX192YWx1ZVNldC5jYWxsKHRoaXMsIHBhcnNlRmxvYXQodGhpcy5pbnB1dG1hc2sudW5tYXNrZWR2YWx1ZSgpKSAqIHBhcnNlSW50KGwpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8udHJpZ2dlcihcInNldHZhbHVlXCIpLCAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSkgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSByLmtleXMuQXJyb3dVcDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRtYXNrLl9fdmFsdWVTZXQuY2FsbCh0aGlzLCBwYXJzZUZsb2F0KHRoaXMuaW5wdXRtYXNrLnVubWFza2VkdmFsdWUoKSkgKyBwYXJzZUludChpLnN0ZXApKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8udHJpZ2dlcihcInNldHZhbHVlXCIpLCAhMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSByLmtleXMuQXJyb3dEb3duOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dG1hc2suX192YWx1ZVNldC5jYWxsKHRoaXMsIHBhcnNlRmxvYXQodGhpcy5pbnB1dG1hc2sudW5tYXNrZWR2YWx1ZSgpKSAtIHBhcnNlSW50KGkuc3RlcCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby50cmlnZ2VyKFwic2V0dmFsdWVcIiksICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUuc2hpZnRLZXkgJiYgKGUua2V5ID09PSByLmtleXMuRGVsZXRlIHx8IGUua2V5ID09PSByLmtleXMuQmFja3NwYWNlIHx8IGUua2V5ID09PSByLmtleXMuQkFDS1NQQUNFX1NBRkFSSSkgJiYgbi5iZWdpbiAhPT0gdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbZS5rZXkgPT09IHIua2V5cy5EZWxldGUgPyBuLmJlZ2luIC0gMSA6IG4uZW5kXSA9PT0gaS5uZWdhdGlvblN5bWJvbC5mcm9udCkgcmV0dXJuIGEgPSB0LnNsaWNlKCkucmV2ZXJzZSgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiAhPT0gaS5uZWdhdGlvblN5bWJvbC5mcm9udCAmJiBhLnNoaWZ0KCksIFwiXCIgIT09IGkubmVnYXRpb25TeW1ib2wuYmFjayAmJiBhLnBvcCgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby50cmlnZ2VyKFwic2V0dmFsdWVcIiwgWyBhLmpvaW4oXCJcIiksIG4uYmVnaW4gXSksICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IGkuX3JhZGl4RGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmLCBwID0gdC5pbmRleE9mKGkucmFkaXhQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaS5kaWdpdHNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBwKSByZXR1cm4gKGEgPSB0LnNsaWNlKCkucmV2ZXJzZSgpKS5wb3AoKSwgby50cmlnZ2VyKFwic2V0dmFsdWVcIiwgWyBhLmpvaW4oXCJcIiksIG4uYmVnaW4gPj0gYS5sZW5ndGggPyBhLmxlbmd0aCA6IG4uYmVnaW4gXSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgtMSAhPT0gcCAmJiAobi5iZWdpbiA8IHAgfHwgbi5lbmQgPCBwIHx8IGUua2V5ID09PSByLmtleXMuRGVsZXRlICYmIChuLmJlZ2luID09PSBwIHx8IG4uYmVnaW4gLSAxID09PSBwKSkpIHJldHVybiBuLmJlZ2luID09PSBuLmVuZCAmJiAoZS5rZXkgPT09IHIua2V5cy5CYWNrc3BhY2UgfHwgZS5rZXkgPT09IHIua2V5cy5CQUNLU1BBQ0VfU0FGQVJJID8gbi5iZWdpbisrIDogZS5rZXkgPT09IHIua2V5cy5EZWxldGUgJiYgbi5iZWdpbiAtIDEgPT09IHAgJiYgKGYgPSBzLmV4dGVuZCh7fSwgbiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5iZWdpbi0tLCBuLmVuZC0tKSksIChhID0gdC5zbGljZSgpLnJldmVyc2UoKSkuc3BsaWNlKGEubGVuZ3RoIC0gbi5iZWdpbiwgbi5iZWdpbiAtIG4uZW5kICsgMSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHUoYSwgaS5kaWdpdHMsIGkpLmpvaW4oXCJcIiksIGYgJiYgKG4gPSBmKSwgby50cmlnZ2VyKFwic2V0dmFsdWVcIiwgWyBhLCBuLmJlZ2luID49IGEubGVuZ3RoID8gcCArIDEgOiBuLmJlZ2luIF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3I6IFwiLFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzT3B0aW9uYWw6ICExXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBcIm51bWVyaWNcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnRlZ2VyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlhczogXCJudW1lcmljXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dG1vZGU6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzOiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4OiBcIiAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd01pbnVzOiAhMVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbmRpYW5uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgX21hc2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoXCIgKyBlLmdyb3VwU2VwYXJhdG9yICsgXCI5OSl7KnwxfShcIiArIGUuZ3JvdXBTZXBhcmF0b3IgKyBcIjk5OSl7MXwxfVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yOiBcIixcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl4UG9pbnQ6IFwiLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzT3B0aW9uYWw6ICExXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA5MzgwOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSAhKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIHdpbmRvdyB8fCAhd2luZG93LmRvY3VtZW50IHx8ICF3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdC5kZWZhdWx0ID0gbiA/IHdpbmRvdyA6IHt9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDc3NjA6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuSGFuZGxlTmF0aXZlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZSA/IGUuaW5wdXRtYXNrIDogdGhpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkuaWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmlucHV0bWFzay5fdmFsdWVHZXQoKSAhPT0gdCAmJiAoZS5wbGFjZWhvbGRlciAhPT0gdCB8fCBcIlwiID09PSBlLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gby5nZXRCdWZmZXIuY2FsbChuKS5zbGljZSgpLCByID0gZS5pbnB1dG1hc2suX3ZhbHVlR2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgIT09IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBvLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwobik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xID09PSBsICYmIHIgPT09IG8uZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChuKS5qb2luKFwiXCIpID8gYSA9IFtdIDogLTEgIT09IGwgJiYgdS5jYWxsKG4sIGEpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcChlLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBlLnBsYWNlaG9sZGVyICE9PSB0ICYmIChlLnBsYWNlaG9sZGVyID0gdCwgXCJcIiA9PT0gZS5wbGFjZWhvbGRlciAmJiBlLnJlbW92ZUF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpKTtcbiAgICAgICAgICAgICAgICB9LCB0LmFwcGx5SW5wdXRWYWx1ZSA9IGMsIHQuY2hlY2tWYWwgPSBmLCB0LmNsZWFyT3B0aW9uYWxUYWlsID0gdSwgdC51bm1hc2tlZHZhbHVlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUgPyBlLmlucHV0bWFzayA6IHRoaXMsIG4gPSB0Lm9wdHMsIGkgPSB0Lm1hc2tzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBlLmlucHV0bWFzaykgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmlucHV0bWFzayAmJiBlLmlucHV0bWFzay5yZWZyZXNoVmFsdWUgJiYgYyhlLCBlLmlucHV0bWFzay5fdmFsdWVHZXQoITApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gW10sIHIgPSBpLnZhbGlkUG9zaXRpb25zLCBsID0gMCwgcyA9IHIubGVuZ3RoOyBsIDwgczsgbCsrKSByW2xdICYmIHJbbF0ubWF0Y2ggJiYgKDEgIT0gcltsXS5tYXRjaC5zdGF0aWMgfHwgQXJyYXkuaXNBcnJheShpLm1ldGFkYXRhKSAmJiAhMCAhPT0gcltsXS5nZW5lcmF0ZWRJbnB1dCkgJiYgYS5wdXNoKHJbbF0uaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IDAgPT09IGEubGVuZ3RoID8gXCJcIiA6ICh0LmlzUlRMID8gYS5yZXZlcnNlKCkgOiBhKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBuLm9uVW5NYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9ICh0LmlzUlRMID8gby5nZXRCdWZmZXIuY2FsbCh0KS5zbGljZSgpLnJldmVyc2UoKSA6IG8uZ2V0QnVmZmVyLmNhbGwodCkpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB1ID0gbi5vblVuTWFzay5jYWxsKHQsIGYsIHUsIG4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICAgICAgICAgIH0sIHQud3JpdGVCdWZmZXIgPSBwO1xuICAgICAgICAgICAgICAgIHZhciBpID0gbig5ODQ1KSwgYSA9IG4oNjAzMCksIHIgPSBuKDI4MzkpLCBvID0gbig4NzExKSwgbCA9IG4oNzIxNSksIHMgPSBuKDQ3MTMpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUgPyBlLmlucHV0bWFzayA6IHRoaXMsIGEgPSBpLm9wdHM7XG4gICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrLnJlZnJlc2hWYWx1ZSA9ICExLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEub25CZWZvcmVNYXNrICYmICh0ID0gYS5vbkJlZm9yZU1hc2suY2FsbChpLCB0LCBhKSB8fCB0KSwgXG4gICAgICAgICAgICAgICAgICAgIGYoZSwgITAsICExLCB0ID0gKHQgfHwgXCJcIikudG9TdHJpbmcoKS5zcGxpdChcIlwiKSwgbiksIGkudW5kb1ZhbHVlID0gaS5fdmFsdWVHZXQoITApLCBcbiAgICAgICAgICAgICAgICAgICAgKGEuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgfHwgYS5jbGVhckluY29tcGxldGUpICYmIGUuaW5wdXRtYXNrLl92YWx1ZUdldCgpID09PSBvLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoaSkuam9pbihcIlwiKSAmJiAtMSA9PT0gby5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGkpICYmIGUuaW5wdXRtYXNrLl92YWx1ZVNldChcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdShlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCwgbiA9IHMuZ2V0TWFza1RlbXBsYXRlLmNhbGwodGhpcywgITAsIDAsICEwLCB2b2lkIDAsICEwKTsgdm9pZCAwICE9PSAodCA9IG4uc2hpZnQoKSk7ICkgZS5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZihlLCB0LCBuLCBpLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjLCB1ID0gZSA/IGUuaW5wdXRtYXNrIDogdGhpcywgZiA9IHUubWFza3NldCwgZCA9IHUub3B0cywgaCA9IHUuZGVwZW5kZW5jeUxpYiwgdiA9IGkuc2xpY2UoKSwgbSA9IFwiXCIsIGcgPSAtMSwgeSA9IGQuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICAgICAgZC5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyID0gXCJcIiwgby5yZXNldE1hc2tTZXQuY2FsbCh1LCAhMSksIHUuY2xpY2tlZCA9IDAsIGcgPSBkLnJhZGl4UG9pbnQgPyBvLmRldGVybWluZU5ld0NhcmV0UG9zaXRpb24uY2FsbCh1LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogMFxuICAgICAgICAgICAgICAgICAgICB9LCAhMSwgITEgPT09IGQuX19maW5hbmNlSW5wdXQgPyBcInJhZGl4Rm9jdXNcIiA6IHZvaWQgMCkuYmVnaW4gOiAwLCBmLnAgPSBnLCB1LmNhcmV0UG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IGdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBbXSwgYiA9IHUuY2FyZXRQb3M7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2LmZvckVhY2goKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IG5ldyBoLkV2ZW50KFwiX2NoZWNrdmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkua2V5ID0gZSwgbSArPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gby5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHUsIHZvaWQgMCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBzLmdldE1hc2tUZW1wbGF0ZS5jYWxsKHUsICEwLCAwKS5zbGljZShlLCBvLnNlZWtOZXh0LmNhbGwodSwgZSwgITEsICExKSkuam9pbihcIlwiKS5yZXBsYWNlKC8nL2csIFwiXCIpLCBpID0gbi5pbmRleE9mKHQpOyBpID4gMCAmJiBcIiBcIiA9PT0gbltpIC0gMV07ICkgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IDAgPT09IGkgJiYgIW8uaXNNYXNrLmNhbGwodSwgZSkgJiYgKHMuZ2V0VGVzdC5jYWxsKHUsIGUpLm1hdGNoLm5hdGl2ZURlZiA9PT0gdC5jaGFyQXQoMCkgfHwgITAgPT09IHMuZ2V0VGVzdC5jYWxsKHUsIGUpLm1hdGNoLnN0YXRpYyAmJiBzLmdldFRlc3QuY2FsbCh1LCBlKS5tYXRjaC5uYXRpdmVEZWYgPT09IFwiJ1wiICsgdC5jaGFyQXQoMCkgfHwgXCIgXCIgPT09IHMuZ2V0VGVzdC5jYWxsKHUsIGUpLm1hdGNoLm5hdGl2ZURlZiAmJiAocy5nZXRUZXN0LmNhbGwodSwgZSArIDEpLm1hdGNoLm5hdGl2ZURlZiA9PT0gdC5jaGFyQXQoMCkgfHwgITAgPT09IHMuZ2V0VGVzdC5jYWxsKHUsIGUgKyAxKS5tYXRjaC5zdGF0aWMgJiYgcy5nZXRUZXN0LmNhbGwodSwgZSArIDEpLm1hdGNoLm5hdGl2ZURlZiA9PT0gXCInXCIgKyB0LmNoYXJBdCgwKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEgJiYgaSA+IDAgJiYgIW8uaXNNYXNrLmNhbGwodSwgZSwgITEsICEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBvLnNlZWtOZXh0LmNhbGwodSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1LmNhcmV0UG9zLmJlZ2luIDwgciAmJiAodS5jYXJldFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShnLCBtKSA/IChjID0gYS5FdmVudEhhbmRsZXJzLmtleXByZXNzRXZlbnQuY2FsbCh1LCBpLCAhMCwgITEsIG4sIHUuY2FyZXRQb3MuYmVnaW4pKSAmJiAoZyA9IHUuY2FyZXRQb3MuYmVnaW4gKyAxLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gXCJcIikgOiBjID0gYS5FdmVudEhhbmRsZXJzLmtleXByZXNzRXZlbnQuY2FsbCh1LCBpLCAhMCwgITEsIG4sIHIgKyAxKSwgYyA/ICh2b2lkIDAgIT09IGMucG9zICYmIGYudmFsaWRQb3NpdGlvbnNbYy5wb3NdICYmICEwID09PSBmLnZhbGlkUG9zaXRpb25zW2MucG9zXS5tYXRjaC5zdGF0aWMgJiYgdm9pZCAwID09PSBmLnZhbGlkUG9zaXRpb25zW2MucG9zXS5hbHRlcm5hdGlvbiAmJiAoay5wdXNoKGMucG9zKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdS5pc1JUTCB8fCAoYy5mb3J3YXJkUG9zaXRpb24gPSBjLnBvcyArIDEpKSwgcC5jYWxsKHUsIHZvaWQgMCwgby5nZXRCdWZmZXIuY2FsbCh1KSwgYy5mb3J3YXJkUG9zaXRpb24sIGksICExKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdS5jYXJldFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IGMuZm9yd2FyZFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGMuZm9yd2FyZFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgYiA9IHUuY2FyZXRQb3MpIDogdm9pZCAwID09PSBmLnZhbGlkUG9zaXRpb25zW3RdICYmIHZbdF0gPT09IHMuZ2V0UGxhY2Vob2xkZXIuY2FsbCh1LCB0KSAmJiBvLmlzTWFzay5jYWxsKHUsIHQsICEwKSA/IHUuY2FyZXRQb3MuYmVnaW4rKyA6IHUuY2FyZXRQb3MgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSksIGsubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHgsIHcsIFAgPSBvLnNlZWtOZXh0LmNhbGwodSwgLTEsIHZvaWQgMCwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsLmlzQ29tcGxldGUuY2FsbCh1LCBvLmdldEJ1ZmZlci5jYWxsKHUpKSAmJiBrLmxlbmd0aCA8PSBQIHx8IGwuaXNDb21wbGV0ZS5jYWxsKHUsIG8uZ2V0QnVmZmVyLmNhbGwodSkpICYmIGsubGVuZ3RoID4gMCAmJiBrLmxlbmd0aCAhPT0gUCAmJiAwID09PSBrWzBdKSBmb3IgKHZhciBTID0gUDsgdm9pZCAwICE9PSAoeCA9IGsuc2hpZnQoKSk7ICkgaWYgKHggPCBTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE8gPSBuZXcgaC5FdmVudChcIl9jaGVja3ZhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHcgPSBmLnZhbGlkUG9zaXRpb25zW3hdKS5nZW5lcmF0ZWRJbnB1dCA9ICEwLCBPLmtleSA9IHcuaW5wdXQsIChjID0gYS5FdmVudEhhbmRsZXJzLmtleXByZXNzRXZlbnQuY2FsbCh1LCBPLCAhMCwgITEsIG4sIFMpKSAmJiB2b2lkIDAgIT09IGMucG9zICYmIGMucG9zICE9PSB4ICYmIGYudmFsaWRQb3NpdGlvbnNbYy5wb3NdICYmICEwID09PSBmLnZhbGlkUG9zaXRpb25zW2MucG9zXS5tYXRjaC5zdGF0aWMpIGsucHVzaChjLnBvcyk7IGVsc2UgaWYgKCFjKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdCAmJiBwLmNhbGwodSwgZSwgby5nZXRCdWZmZXIuY2FsbCh1KSwgYyA/IGMuZm9yd2FyZFBvc2l0aW9uIDogdS5jYXJldFBvcy5iZWdpbiwgciB8fCBuZXcgaC5FdmVudChcImNoZWNrdmFsXCIpLCByICYmIChcImlucHV0XCIgPT09IHIudHlwZSAmJiB1LnVuZG9WYWx1ZSAhPT0gby5nZXRCdWZmZXIuY2FsbCh1KS5qb2luKFwiXCIpIHx8IFwicGFzdGVcIiA9PT0gci50eXBlKSksIFxuICAgICAgICAgICAgICAgICAgICBkLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIgPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwKGUsIHQsIG4sIGksIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBlID8gZS5pbnB1dG1hc2sgOiB0aGlzLCBjID0gcy5vcHRzLCB1ID0gcy5kZXBlbmRlbmN5TGliO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGMub25CZWZvcmVXcml0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBjLm9uQmVmb3JlV3JpdGUuY2FsbChzLCBpLCB0LCBuLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYucmVmcmVzaEZyb21CdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBmLnJlZnJlc2hGcm9tQnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLnJlZnJlc2hGcm9tQnVmZmVyLmNhbGwocywgITAgPT09IHAgPyBwIDogcC5zdGFydCwgcC5lbmQsIGYuYnVmZmVyIHx8IHQpLCB0ID0gby5nZXRCdWZmZXIuY2FsbChzLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gbiAmJiAobiA9IHZvaWQgMCAhPT0gZi5jYXJldCA/IGYuY2FyZXQgOiBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBlICYmIChlLmlucHV0bWFzay5fdmFsdWVTZXQodC5qb2luKFwiXCIpKSwgdm9pZCAwID09PSBuIHx8IHZvaWQgMCAhPT0gaSAmJiBcImJsdXJcIiA9PT0gaS50eXBlIHx8IG8uY2FyZXQuY2FsbChzLCBlLCBuLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwICE9PSBpICYmIFwia2V5ZG93blwiID09PSBpLnR5cGUgJiYgKGkua2V5ID09PSByLmtleXMuRGVsZXRlIHx8IGkua2V5ID09PSByLmtleXMuQmFja3NwYWNlKSksIFxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGUuaW5wdXRtYXNrLndyaXRlQnVmZmVySG9vayB8fCBlLmlucHV0bWFzay53cml0ZUJ1ZmZlckhvb2sobiksICEwID09PSBhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB1KGUpLCBoID0gZS5pbnB1dG1hc2suX3ZhbHVlR2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmlucHV0bWFzay5za2lwSW5wdXRFdmVudCA9ICEwLCBkLnRyaWdnZXIoXCJpbnB1dFwiKSwgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9PT0gby5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHMpLmpvaW4oXCJcIikgPyBkLnRyaWdnZXIoXCJjbGVhcmVkXCIpIDogITAgPT09IGwuaXNDb21wbGV0ZS5jYWxsKHMsIHQpICYmIGQudHJpZ2dlcihcImNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDIzOTQ6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHYobigzOTc2KSksIGEgPSB2KG4oNzM5MikpLCByID0gdihuKDQ5NjMpKSwgbyA9IG4oOTcxNiksIGwgPSB2KG4oOTM4MCkpLCBzID0gbig3NzYwKSwgYyA9IG4oMTU3KSwgdSA9IG4oMjM5MSksIGYgPSBuKDg3MTEpLCBwID0gbig3MjE1KSwgZCA9IG4oNDcxMyk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIGgoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHYoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbSA9IGwuZGVmYXVsdC5kb2N1bWVudCwgZyA9IFwiX2lucHV0bWFza19vcHRzXCI7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24geShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB5KSkgcmV0dXJuIG5ldyB5KGUsIHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lMaWIgPSByLmRlZmF1bHQsIHRoaXMuZWwgPSB2b2lkIDAsIHRoaXMuZXZlbnRzID0ge30sIHRoaXMubWFza3NldCA9IHZvaWQgMCwgXG4gICAgICAgICAgICAgICAgICAgICEwICE9PSBuICYmIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkgPyB0ID0gZSA6ICh0ID0gdCB8fCB7fSwgXG4gICAgICAgICAgICAgICAgICAgIGUgJiYgKHQuYWxpYXMgPSBlKSksIHRoaXMub3B0cyA9IHIuZGVmYXVsdC5leHRlbmQoITAsIHt9LCB0aGlzLmRlZmF1bHRzLCB0KSwgdGhpcy5ub01hc2tzQ2FjaGUgPSB0ICYmIHZvaWQgMCAhPT0gdC5kZWZpbml0aW9ucywgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlck9wdGlvbnMgPSB0IHx8IHt9LCBrKHRoaXMub3B0cy5hbGlhcywgdCwgdGhpcy5vcHRzKSksIHRoaXMucmVmcmVzaFZhbHVlID0gITEsIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuZG9WYWx1ZSA9IHZvaWQgMCwgdGhpcy4kZWwgPSB2b2lkIDAsIHRoaXMuc2tpcElucHV0RXZlbnQgPSAhMSwgdGhpcy52YWxpZGF0aW9uRXZlbnQgPSAhMSwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWdub3JhYmxlID0gITEsIHRoaXMubWF4TGVuZ3RoLCB0aGlzLm1vdXNlRW50ZXIgPSAhMSwgdGhpcy5jbGlja2VkID0gMCwgdGhpcy5vcmlnaW5hbFBsYWNlaG9sZGVyID0gdm9pZCAwLCBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NvbXBvc2luZyA9ICExLCB0aGlzLmhhc0FsdGVybmF0b3IgPSAhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gayhlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0geS5wcm90b3R5cGUuYWxpYXNlc1tlXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPyAoaS5hbGlhcyAmJiBrKGkuYWxpYXMsIHZvaWQgMCwgbiksIHIuZGVmYXVsdC5leHRlbmQoITAsIG4sIGkpLCByLmRlZmF1bHQuZXh0ZW5kKCEwLCBuLCB0KSwgXG4gICAgICAgICAgICAgICAgICAgICEwKSA6IChudWxsID09PSBuLm1hc2sgJiYgKG4ubWFzayA9IGUpLCAhMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhQXR0cmlidXRlOiBcImRhdGEtaW5wdXRtYXNrXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBpLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiBhLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzZXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBtYXNrc0NhY2hlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgaTE4bjoge30sXG4gICAgICAgICAgICAgICAgICAgIGdldCBpc1JUTCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdHMuaXNSVEwgfHwgdGhpcy5vcHRzLm51bWVyaWNJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWFzazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgKGUgPSBtLmdldEVsZW1lbnRCeUlkKGUpIHx8IG0ucXVlcnlTZWxlY3RvckFsbChlKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgKGUgPSBlLm5vZGVOYW1lID8gWyBlIF0gOiBBcnJheS5pc0FycmF5KGUpID8gZSA6IFtdLnNsaWNlLmNhbGwoZSkpLmZvckVhY2goKGZ1bmN0aW9uKGUsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHIuZGVmYXVsdC5leHRlbmQoITAsIHt9LCB0Lm9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbihlLCB0LCBuLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGEodCwgYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBcIlwiID09PSBpID8gdCA6IGkgKyBcIi1cIiArIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSAoYSA9IHZvaWQgMCAhPT0gYSA/IGEgOiBlLmdldEF0dHJpYnV0ZShyKSkgJiYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGEgJiYgKDAgPT09IHQuaW5kZXhPZihcIm9uXCIpID8gYSA9IGwuZGVmYXVsdFthXSA6IFwiZmFsc2VcIiA9PT0gYSA/IGEgPSAhMSA6IFwidHJ1ZVwiID09PSBhICYmIChhID0gITApKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuW3RdID0gYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSB0LmltcG9ydERhdGFBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbywgcywgYywgdSwgZiA9IGUuZ2V0QXR0cmlidXRlKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYgJiYgXCJcIiAhPT0gZiAmJiAoZiA9IGYucmVwbGFjZSgvJy9nLCAnXCInKSwgcyA9IEpTT04ucGFyc2UoXCJ7XCIgKyBmICsgXCJ9XCIpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzKSBmb3IgKHUgaW4gYyA9IHZvaWQgMCwgcykgaWYgKFwiYWxpYXNcIiA9PT0gdS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHNbdV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG8gaW4gYShcImFsaWFzXCIsIGMpLCBuLmFsaWFzICYmIGsobi5hbGlhcywgbiwgdCksIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocykgZm9yICh1IGluIGMgPSB2b2lkIDAsIHMpIGlmICh1LnRvTG93ZXJDYXNlKCkgPT09IG8udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gc1t1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEobywgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5kZWZhdWx0LmV4dGVuZCghMCwgdCwgbiksIChcInJ0bFwiID09PSBlLmRpciB8fCB0LnJpZ2h0QWxpZ24pICYmIChlLnN0eWxlLnRleHRBbGlnbiA9IFwicmlnaHRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInJ0bFwiID09PSBlLmRpciB8fCB0Lm51bWVyaWNJbnB1dCkgJiYgKGUuZGlyID0gXCJsdHJcIiwgZS5yZW1vdmVBdHRyaWJ1dGUoXCJkaXJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmlzUlRMID0gITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobikubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oZSwgaSwgci5kZWZhdWx0LmV4dGVuZCghMCwge30sIHQudXNlck9wdGlvbnMpLCB0LmRhdGFBdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gKDAsIHUuZ2VuZXJhdGVNYXNrU2V0KShpLCB0Lm5vTWFza3NDYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gYSAmJiAodm9pZCAwICE9PSBlLmlucHV0bWFzayAmJiAoZS5pbnB1dG1hc2sub3B0cy5hdXRvVW5tYXNrID0gITAsIGUuaW5wdXRtYXNrLnJlbW92ZSgpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrID0gbmV3IHkodm9pZCAwLCB2b2lkIDAsICEwKSwgZS5pbnB1dG1hc2sub3B0cyA9IGksIGUuaW5wdXRtYXNrLm5vTWFza3NDYWNoZSA9IHQubm9NYXNrc0NhY2hlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2sudXNlck9wdGlvbnMgPSByLmRlZmF1bHQuZXh0ZW5kKCEwLCB7fSwgdC51c2VyT3B0aW9ucyksIGUuaW5wdXRtYXNrLmVsID0gZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrLiRlbCA9ICgwLCByLmRlZmF1bHQpKGUpLCBlLmlucHV0bWFzay5tYXNrc2V0ID0gYSwgci5kZWZhdWx0LmRhdGEoZSwgZywgdC51c2VyT3B0aW9ucyksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLm1hc2suY2FsbChlLmlucHV0bWFzaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgZSAmJiBlWzBdICYmIGVbMF0uaW5wdXRtYXNrIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbjogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyB0aGlzLm9wdHNbZV0gOiBcIm9iamVjdFwiID09PSBoKGUpID8gKHIuZGVmYXVsdC5leHRlbmQodGhpcy51c2VyT3B0aW9ucywgZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbCAmJiAhMCAhPT0gdCAmJiB0aGlzLm1hc2sodGhpcy5lbCksIHRoaXMpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1bm1hc2tlZHZhbHVlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXNrc2V0ID0gdGhpcy5tYXNrc2V0IHx8ICgwLCB1LmdlbmVyYXRlTWFza1NldCkodGhpcy5vcHRzLCB0aGlzLm5vTWFza3NDYWNoZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB0aGlzLmVsIHx8IHZvaWQgMCAhPT0gZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdGhpcy5vcHRzLm9uQmVmb3JlTWFzayAmJiB0aGlzLm9wdHMub25CZWZvcmVNYXNrLmNhbGwodGhpcywgZSwgdGhpcy5vcHRzKSB8fCBlKS5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmNoZWNrVmFsLmNhbGwodGhpcywgdm9pZCAwLCAhMSwgITEsIHQpLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRoaXMub3B0cy5vbkJlZm9yZVdyaXRlICYmIHRoaXMub3B0cy5vbkJlZm9yZVdyaXRlLmNhbGwodGhpcywgdm9pZCAwLCBmLmdldEJ1ZmZlci5jYWxsKHRoaXMpLCAwLCB0aGlzLm9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMudW5tYXNrZWR2YWx1ZS5jYWxsKHRoaXMsIHRoaXMuZWwpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmRlZmF1bHQuZGF0YSh0aGlzLmVsLCBnLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMub3B0cy5hdXRvVW5tYXNrID8gKDAsIHMudW5tYXNrZWR2YWx1ZSkodGhpcy5lbCkgOiB0aGlzLl92YWx1ZUdldCh0aGlzLm9wdHMuYXV0b1VubWFzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSAhPT0gZi5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHRoaXMpLmpvaW4oXCJcIikgPyB0aGlzLl92YWx1ZVNldChlLCB0aGlzLm9wdHMuYXV0b1VubWFzaykgOiB0aGlzLl92YWx1ZVNldChcIlwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5FdmVudFJ1bGVyLm9mZih0aGlzLmVsKSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLmVsKSwgXCJ2YWx1ZVwiKSAmJiB0aGlzLl9fdmFsdWVHZXQgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZWwsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IHRoaXMuX192YWx1ZUdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiB0aGlzLl9fdmFsdWVTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6IG0uX19sb29rdXBHZXR0ZXJfXyAmJiB0aGlzLmVsLl9fbG9va3VwR2V0dGVyX18oXCJ2YWx1ZVwiKSAmJiB0aGlzLl9fdmFsdWVHZXQgJiYgKHRoaXMuZWwuX19kZWZpbmVHZXR0ZXJfXyhcInZhbHVlXCIsIHRoaXMuX192YWx1ZUdldCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuX19kZWZpbmVTZXR0ZXJfXyhcInZhbHVlXCIsIHRoaXMuX192YWx1ZVNldCkpLCB0aGlzLmVsLmlucHV0bWFzayA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRlbXB0eW1hc2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFza3NldCA9IHRoaXMubWFza3NldCB8fCAoMCwgdS5nZW5lcmF0ZU1hc2tTZXQpKHRoaXMub3B0cywgdGhpcy5ub01hc2tzQ2FjaGUpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmlzUlRMID8gZi5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHRoaXMpLnJldmVyc2UoKSA6IGYuZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbCh0aGlzKSkuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTWFza2VkVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLm9wdHMuYXV0b1VubWFzaztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaXNDb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrc2V0ID0gdGhpcy5tYXNrc2V0IHx8ICgwLCB1LmdlbmVyYXRlTWFza1NldCkodGhpcy5vcHRzLCB0aGlzLm5vTWFza3NDYWNoZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgcC5pc0NvbXBsZXRlLmNhbGwodGhpcywgZi5nZXRCdWZmZXIuY2FsbCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldG1ldGFkYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hc2tzZXQgPSB0aGlzLm1hc2tzZXQgfHwgKDAsIHUuZ2VuZXJhdGVNYXNrU2V0KSh0aGlzLm9wdHMsIHRoaXMubm9NYXNrc0NhY2hlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMubWFza3NldC5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGQuZ2V0TWFza1RlbXBsYXRlLmNhbGwodGhpcywgITAsIDAsICExKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hc2tzZXQubWV0YWRhdGEuZm9yRWFjaCgoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5tYXNrICE9PSBlIHx8IChlID0gdCwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hc2tzZXQubWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hc2tzZXQgPSB0aGlzLm1hc2tzZXQgfHwgKDAsIHUuZ2VuZXJhdGVNYXNrU2V0KSh0aGlzLm9wdHMsIHRoaXMubm9NYXNrc0NhY2hlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0aGlzLm9wdHMub25CZWZvcmVNYXNrICYmIHRoaXMub3B0cy5vbkJlZm9yZU1hc2suY2FsbCh0aGlzLCBlLCB0aGlzLm9wdHMpIHx8IGUpLnNwbGl0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuY2hlY2tWYWwuY2FsbCh0aGlzLCB2b2lkIDAsICEwLCAhMSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZSA9IHRoaXMuaXNSVEwgPyBmLmdldEJ1ZmZlci5jYWxsKHRoaXMpLnNsaWNlKCkucmV2ZXJzZSgpLmpvaW4oXCJcIikgOiBmLmdldEJ1ZmZlci5jYWxsKHRoaXMpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gZi5nZXRCdWZmZXIuY2FsbCh0aGlzKSwgaSA9IGYuZGV0ZXJtaW5lTGFzdFJlcXVpcmVkUG9zaXRpb24uY2FsbCh0aGlzKSwgYSA9IG4ubGVuZ3RoIC0gMTsgYSA+IGkgJiYgIWYuaXNNYXNrLmNhbGwodGhpcywgYSk7IGEtLSkgO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uc3BsaWNlKGksIGEgKyAxIC0gaSksIHAuaXNDb21wbGV0ZS5jYWxsKHRoaXMsIG4pICYmIGUgPT09ICh0aGlzLmlzUlRMID8gZi5nZXRCdWZmZXIuY2FsbCh0aGlzKS5zbGljZSgpLnJldmVyc2UoKS5qb2luKFwiXCIpIDogZi5nZXRCdWZmZXIuY2FsbCh0aGlzKS5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hc2tzZXQgPSB0aGlzLm1hc2tzZXQgfHwgKDAsIHUuZ2VuZXJhdGVNYXNrU2V0KSh0aGlzLm9wdHMsIHRoaXMubm9NYXNrc0NhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdGhpcy5vcHRzLm9uQmVmb3JlTWFzayAmJiB0aGlzLm9wdHMub25CZWZvcmVNYXNrLmNhbGwodGhpcywgZSwgdGhpcy5vcHRzKSB8fCBlKS5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuY2hlY2tWYWwuY2FsbCh0aGlzLCB2b2lkIDAsICEwLCAhMSwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMuaXNSVEwgPyBmLmdldEJ1ZmZlci5jYWxsKHRoaXMpLnNsaWNlKCkucmV2ZXJzZSgpLmpvaW4oXCJcIikgOiBmLmdldEJ1ZmZlci5jYWxsKHRoaXMpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5nZXRtZXRhZGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogaTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwgJiYgKDAsIHIuZGVmYXVsdCkodGhpcy5lbCkudHJpZ2dlcihcInNldHZhbHVlXCIsIFsgZSBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYW5hbHlzZU1hc2s6IHUuYW5hbHlzZU1hc2tcbiAgICAgICAgICAgICAgICB9LCB5LmV4dGVuZERlZmF1bHRzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByLmRlZmF1bHQuZXh0ZW5kKCEwLCB5LnByb3RvdHlwZS5kZWZhdWx0cywgZSk7XG4gICAgICAgICAgICAgICAgfSwgeS5leHRlbmREZWZpbml0aW9ucyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgci5kZWZhdWx0LmV4dGVuZCghMCwgeS5wcm90b3R5cGUuZGVmaW5pdGlvbnMsIGUpO1xuICAgICAgICAgICAgICAgIH0sIHkuZXh0ZW5kQWxpYXNlcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgci5kZWZhdWx0LmV4dGVuZCghMCwgeS5wcm90b3R5cGUuYWxpYXNlcywgZSk7XG4gICAgICAgICAgICAgICAgfSwgeS5mb3JtYXQgPSBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KHQpLmZvcm1hdChlLCBuKTtcbiAgICAgICAgICAgICAgICB9LCB5LnVubWFzayA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkodCkudW5tYXNrZWR2YWx1ZShlKTtcbiAgICAgICAgICAgICAgICB9LCB5LmlzVmFsaWQgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KHQpLmlzVmFsaWQoZSk7XG4gICAgICAgICAgICAgICAgfSwgeS5yZW1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgKGUgPSBtLmdldEVsZW1lbnRCeUlkKGUpIHx8IG0ucXVlcnlTZWxlY3RvckFsbChlKSksIChlID0gZS5ub2RlTmFtZSA/IFsgZSBdIDogZSkuZm9yRWFjaCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2sgJiYgZS5pbnB1dG1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB5LnNldFZhbHVlID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIChlID0gbS5nZXRFbGVtZW50QnlJZChlKSB8fCBtLnF1ZXJ5U2VsZWN0b3JBbGwoZSkpLCAoZSA9IGUubm9kZU5hbWUgPyBbIGUgXSA6IGUpLmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrID8gZS5pbnB1dG1hc2suc2V0VmFsdWUodCkgOiAoMCwgci5kZWZhdWx0KShlKS50cmlnZ2VyKFwic2V0dmFsdWVcIiwgWyB0IF0pO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSwgeS5kZXBlbmRlbmN5TGliID0gci5kZWZhdWx0LCBsLmRlZmF1bHQuSW5wdXRtYXNrID0geTtcbiAgICAgICAgICAgICAgICB0LmRlZmF1bHQgPSB5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDUyOTY6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBkKG4oOTM4MCkpLCByID0gZChuKDIzOTQpKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHRbbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmVudW1lcmFibGUgPSBhLmVudW1lcmFibGUgfHwgITEsIGEuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBhICYmIChhLndyaXRhYmxlID0gITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAociA9IGEua2V5LCBvID0gdm9pZCAwLCBvID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSBpKGUpIHx8IG51bGwgPT09IGUpIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBuLmNhbGwoZSwgdCB8fCBcImRlZmF1bHRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSBpKGEpKSByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHQgPyBTdHJpbmcgOiBOdW1iZXIpKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShyLCBcInN0cmluZ1wiKSwgXCJzeW1ib2xcIiA9PT0gaShvKSA/IG8gOiBTdHJpbmcobykpLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgciwgbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiwgYSA9IHAoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gcCh0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gUmVmbGVjdC5jb25zdHJ1Y3QoYSwgYXJndW1lbnRzLCByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBuID0gYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiAoXCJvYmplY3RcIiA9PT0gaSh0KSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQpKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBNYXAgPyBuZXcgTWFwIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBlIHx8ICFmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xICE9PSBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGUpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KGUpKSByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5oYXMoZSkpIHJldHVybiB0LmdldChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnNldChlLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMoZSwgYXJndW1lbnRzLCBwKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBmKG4sIGUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBzKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgPSB1KCkgPyBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCkgOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IFsgbnVsbCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS5wdXNoLmFwcGx5KGksIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgKEZ1bmN0aW9uLmJpbmQuYXBwbHkoZSwgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gJiYgZihhLCBuLnByb3RvdHlwZSksIGE7XG4gICAgICAgICAgICAgICAgICAgIH0sIGMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFByb3h5KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCAoZnVuY3Rpb24oKSB7fSkpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAhMDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5fX3Byb3RvX18gPSB0LCBlO1xuICAgICAgICAgICAgICAgICAgICB9LCBmKGUsIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBoID0gYS5kZWZhdWx0LmRvY3VtZW50O1xuICAgICAgICAgICAgICAgIGlmIChoICYmIGguaGVhZCAmJiBoLmhlYWQuYXR0YWNoU2hhZG93ICYmIGEuZGVmYXVsdC5jdXN0b21FbGVtZW50cyAmJiB2b2lkIDAgPT09IGEuZGVmYXVsdC5jdXN0b21FbGVtZW50cy5nZXQoXCJpbnB1dC1tYXNrXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ICYmIG51bGwgIT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICExXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHQgJiYgZihlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0ocywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCwgbiwgaSwgYSA9IGwocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gKGUgPSBhLmNhbGwodGhpcykpLmdldEF0dHJpYnV0ZU5hbWVzKCksIG4gPSBlLmF0dGFjaFNoYWRvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiY2xvc2VkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGUuaW5wdXQgPSBoLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSwgZS5pbnB1dC50eXBlID0gXCJ0ZXh0XCIsIG4uYXBwZW5kQ2hpbGQoZS5pbnB1dCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBpKSAmJiBlLmlucHV0LnNldEF0dHJpYnV0ZSh0W2ldLCBlLmdldEF0dHJpYnV0ZSh0W2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBuZXcgci5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvLmRhdGFBdHRyaWJ1dGUgPSBcIlwiLCBvLm1hc2soZS5pbnB1dCksIGUuaW5wdXQuaW5wdXRtYXNrLnNoYWRvd1Jvb3QgPSBuLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPSBzLCAobiA9IFsge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShlLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBdKSAmJiBvKHQucHJvdG90eXBlLCBuKSwgaSAmJiBvKHQsIGkpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIHM7XG4gICAgICAgICAgICAgICAgICAgIH0ocyhIVE1MRWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICBhLmRlZmF1bHQuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwiaW5wdXQtbWFza1wiLCB2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMjgzOTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIGUuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBlICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9LCBuKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgfShlKSB8fCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG51bGwgPT0gZSA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgZVtTeW1ib2wuaXRlcmF0b3JdIHx8IGVbXCJAQGl0ZXJhdG9yXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBhLCByLCBvLCBsID0gW10sIHMgPSAhMCwgYyA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID0gKG4gPSBuLmNhbGwoZSkpLm5leHQsIDAgPT09IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QobikgIT09IG4pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGZvciAoOyEocyA9IChpID0gci5jYWxsKG4pKS5kb25lKSAmJiAobC5wdXNoKGkudmFsdWUpLCBsLmxlbmd0aCAhPT0gdCk7IHMgPSAhMCkgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICEwLCBhID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzICYmIG51bGwgIT0gbi5yZXR1cm4gJiYgKG8gPSBuLnJldHVybigpLCBPYmplY3QobykgIT09IG8pKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYykgdGhyb3cgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfShlLCB0KSB8fCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSByZXR1cm4gYShlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IG4gJiYgZS5jb25zdHJ1Y3RvciAmJiAobiA9IGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJNYXBcIiA9PT0gbiB8fCBcIlNldFwiID09PSBuKSByZXR1cm4gQXJyYXkuZnJvbShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIkFyZ3VtZW50c1wiID09PSBuIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYShlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfShlLCB0KSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIChudWxsID09IHQgfHwgdCA+IGUubGVuZ3RoKSAmJiAodCA9IGUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSBuZXcgQXJyYXkodCk7IG4gPCB0OyBuKyspIGlbbl0gPSBlW25dO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gT2JqZWN0LmtleXMoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ICYmIChpID0gaS5maWx0ZXIoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB0KS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSwgbi5wdXNoLmFwcGx5KG4sIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvKGUsIHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IG4oZSkgfHwgbnVsbCA9PT0gZSkgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGkuY2FsbChlLCB0IHx8IFwiZGVmYXVsdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IG4oYSkpIHJldHVybiBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gdCA/IFN0cmluZyA6IE51bWJlcikoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KGUsIFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3ltYm9sXCIgPT09IG4odCkgPyB0IDogU3RyaW5nKHQpO1xuICAgICAgICAgICAgICAgICAgICB9KHQpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgICAgICAgICAgIH0pIDogZVt0XSA9IGksIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5rZXlzID0gdC5rZXlDb2RlID0gdm9pZCAwLCB0LnRvS2V5ID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc1tlXSB8fCAodCA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZSkgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0sIHQudG9LZXlDb2RlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbFtlXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBsID0gdC5rZXlDb2RlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBudWxsICE9IGFyZ3VtZW50c1t0XSA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdCAlIDIgPyByKE9iamVjdChuKSwgITApLmZvckVhY2goKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvKGUsIHQsIG5bdF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSkgOiByKE9iamVjdChuKSkuZm9yRWFjaCgoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICB9KHtcbiAgICAgICAgICAgICAgICAgICAgYzogNjcsXG4gICAgICAgICAgICAgICAgICAgIHg6IDg4LFxuICAgICAgICAgICAgICAgICAgICB6OiA5MCxcbiAgICAgICAgICAgICAgICAgICAgQkFDS1NQQUNFX1NBRkFSSTogMTI3LFxuICAgICAgICAgICAgICAgICAgICBFbnRlcjogMTMsXG4gICAgICAgICAgICAgICAgICAgIE1ldGFfTEVGVDogOTEsXG4gICAgICAgICAgICAgICAgICAgIE1ldGFfUklHSFQ6IDkyLFxuICAgICAgICAgICAgICAgICAgICBTcGFjZTogMzJcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIEFsdDogMTgsXG4gICAgICAgICAgICAgICAgICAgIEFsdEdyYXBoOiAxOCxcbiAgICAgICAgICAgICAgICAgICAgQXJyb3dEb3duOiA0MCxcbiAgICAgICAgICAgICAgICAgICAgQXJyb3dMZWZ0OiAzNyxcbiAgICAgICAgICAgICAgICAgICAgQXJyb3dSaWdodDogMzksXG4gICAgICAgICAgICAgICAgICAgIEFycm93VXA6IDM4LFxuICAgICAgICAgICAgICAgICAgICBCYWNrc3BhY2U6IDgsXG4gICAgICAgICAgICAgICAgICAgIENhcHNMb2NrOiAyMCxcbiAgICAgICAgICAgICAgICAgICAgQ29udHJvbDogMTcsXG4gICAgICAgICAgICAgICAgICAgIENvbnRleHRNZW51OiA5MyxcbiAgICAgICAgICAgICAgICAgICAgRGVhZDogMjIxLFxuICAgICAgICAgICAgICAgICAgICBEZWxldGU6IDQ2LFxuICAgICAgICAgICAgICAgICAgICBFbmQ6IDM1LFxuICAgICAgICAgICAgICAgICAgICBFc2NhcGU6IDI3LFxuICAgICAgICAgICAgICAgICAgICBGMTogMTEyLFxuICAgICAgICAgICAgICAgICAgICBGMjogMTEzLFxuICAgICAgICAgICAgICAgICAgICBGMzogMTE0LFxuICAgICAgICAgICAgICAgICAgICBGNDogMTE1LFxuICAgICAgICAgICAgICAgICAgICBGNTogMTE2LFxuICAgICAgICAgICAgICAgICAgICBGNjogMTE3LFxuICAgICAgICAgICAgICAgICAgICBGNzogMTE4LFxuICAgICAgICAgICAgICAgICAgICBGODogMTE5LFxuICAgICAgICAgICAgICAgICAgICBGOTogMTIwLFxuICAgICAgICAgICAgICAgICAgICBGMTA6IDEyMSxcbiAgICAgICAgICAgICAgICAgICAgRjExOiAxMjIsXG4gICAgICAgICAgICAgICAgICAgIEYxMjogMTIzLFxuICAgICAgICAgICAgICAgICAgICBIb21lOiAzNixcbiAgICAgICAgICAgICAgICAgICAgSW5zZXJ0OiA0NSxcbiAgICAgICAgICAgICAgICAgICAgTnVtTG9jazogMTQ0LFxuICAgICAgICAgICAgICAgICAgICBQYWdlRG93bjogMzQsXG4gICAgICAgICAgICAgICAgICAgIFBhZ2VVcDogMzMsXG4gICAgICAgICAgICAgICAgICAgIFBhdXNlOiAxOSxcbiAgICAgICAgICAgICAgICAgICAgUHJpbnRTY3JlZW46IDQ0LFxuICAgICAgICAgICAgICAgICAgICBQcm9jZXNzOiAyMjksXG4gICAgICAgICAgICAgICAgICAgIFNoaWZ0OiAxNixcbiAgICAgICAgICAgICAgICAgICAgU2Nyb2xsTG9jazogMTQ1LFxuICAgICAgICAgICAgICAgICAgICBUYWI6IDksXG4gICAgICAgICAgICAgICAgICAgIFVuaWRlbnRpZmllZDogMjI5XG4gICAgICAgICAgICAgICAgfSksIHMgPSBPYmplY3QuZW50cmllcyhsKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBpKHQsIDIpLCBhID0gblswXSwgciA9IG5bMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlW3JdID0gdm9pZCAwID09PSBlW3JdID8gYSA6IGVbcl0sIGU7XG4gICAgICAgICAgICAgICAgfSksIHt9KTtcbiAgICAgICAgICAgICAgICB0LmtleXMgPSBPYmplY3QuZW50cmllcyhsKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBpKHQsIDIpLCBhID0gblswXTtcbiAgICAgICAgICAgICAgICAgICAgblsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVbYV0gPSBcIlNwYWNlXCIgPT09IGEgPyBcIiBcIiA6IGEsIGU7XG4gICAgICAgICAgICAgICAgfSksIHt9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAyMzkxOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmFuYWx5c2VNYXNrID0gZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgYSwgcywgYywgdSwgZiwgcCA9IC8oPzpbPyorXXxcXHtbMC05KypdKyg/OixbMC05KypdKik/KD86XFx8WzAtOSsqXSopP1xcfSl8W14uPyorXiR7W10oKXxcXFxcXSt8Li9nLCBkID0gL1xcW1xcXj9dPyg/OlteXFxcXFxcXV0rfFxcXFxbXFxTXFxzXT8pKl0/fFxcXFwoPzowKD86WzAtM11bMC03XXswLDJ9fFs0LTddWzAtN10/KT98WzEtOV1bMC05XSp8eFswLTlBLUZhLWZdezJ9fHVbMC05QS1GYS1mXXs0fXxjW0EtWmEtel18W1xcU1xcc10/KXxcXCgoPzpcXD9bOj0hXT8pP3woPzpbPyorXXxcXHtbMC05XSsoPzosWzAtOV0qKT9cXH0pXFw/P3xbXi4/KiteJHtbKCl8XFxcXF0rfC4vZywgaCA9ICExLCB2ID0gbmV3IG8uZGVmYXVsdCwgbSA9IFtdLCBnID0gW10sIHkgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gayhlLCBpLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gdm9pZCAwICE9PSBhID8gYSA6IGUubWF0Y2hlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGUubWF0Y2hlc1thIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBpLmluZGV4T2YoXCJbXCIpIHx8IGggJiYgL1xcXFxkfFxcXFxzfFxcXFx3fFxcXFxwL2kudGVzdChpKSB8fCBcIi5cIiA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG4uY2FzaW5nID8gXCJpXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXFxcXHBcXHsuKn0vaS50ZXN0KGkpICYmIChzICs9IFwidVwiKSwgZS5tYXRjaGVzLnNwbGljZShhKyssIDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuOiBuZXcgUmVnRXhwKGksIHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsaXR5OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrTWFya2VyOiB2b2lkIDAgPT09IG8gPyBcIm1hc3RlclwiIDogby5kZWYgIT09IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJvYmplY3RcIiA9PT0gbChuLnBsYWNlaG9sZGVyKSA/IG4ucGxhY2Vob2xkZXJbdi5tYXRjaGVzLmxlbmd0aF0gOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVEZWY6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGggJiYgKGkgPSBpW2kubGVuZ3RoIC0gMV0pLCBpLnNwbGl0KFwiXCIpLmZvckVhY2goKGZ1bmN0aW9uKHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGUubWF0Y2hlc1thIC0gMV0sIGUubWF0Y2hlcy5zcGxpY2UoYSsrLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogL1thLXpdL2kudGVzdChuLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgfHwgdCkgPyBuZXcgUmVnRXhwKFwiW1wiICsgKG4uc3RhdGljRGVmaW5pdGlvblN5bWJvbCB8fCB0KSArIFwiXVwiLCBuLmNhc2luZyA/IFwiaVwiIDogXCJcIikgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsaXR5OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrTWFya2VyOiB2b2lkIDAgPT09IG8gPyBcIm1hc3RlclwiIDogby5kZWYgIT09IHQgJiYgITAgIT09IG8uc3RhdGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBuLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgfHwgdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB2b2lkIDAgIT09IG4uc3RhdGljRGVmaW5pdGlvblN5bWJvbCA/IHQgOiBcIm9iamVjdFwiID09PSBsKG4ucGxhY2Vob2xkZXIpID8gbi5wbGFjZWhvbGRlclt2Lm1hdGNoZXMubGVuZ3RoXSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZURlZjogKGggPyBcIidcIiA6IFwiXCIpICsgdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG4uZGVmaW5pdGlvbnMgJiYgbi5kZWZpbml0aW9uc1tpXSB8fCBuLnVzZVByb3RvdHlwZURlZmluaXRpb25zICYmIHIuZGVmYXVsdC5wcm90b3R5cGUuZGVmaW5pdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyAmJiAhaCA/IGUubWF0Y2hlcy5zcGxpY2UoYSsrLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuOiBjLnZhbGlkYXRvciA/IFwic3RyaW5nXCIgPT0gdHlwZW9mIGMudmFsaWRhdG9yID8gbmV3IFJlZ0V4cChjLnZhbGlkYXRvciwgbi5jYXNpbmcgPyBcImlcIiA6IFwiXCIpIDogbmV3IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXN0ID0gYy52YWxpZGF0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiAvLi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpYzogYy5zdGF0aWMgfHwgITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsaXR5OiBjLm9wdGlvbmFsIHx8ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZPcHRpb25hbGl0eTogYy5vcHRpb25hbCB8fCAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QmxvY2tNYXJrZXI6IHZvaWQgMCA9PT0gbyB8fCBjLm9wdGlvbmFsID8gXCJtYXN0ZXJcIiA6IG8uZGVmICE9PSAoYy5kZWZpbml0aW9uU3ltYm9sIHx8IGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IGMuY2FzaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGMuZGVmaW5pdGlvblN5bWJvbCB8fCBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogYy5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlRGVmOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IGMuZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiAoZS5tYXRjaGVzLnNwbGljZShhKyssIDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm46IC9bYS16XS9pLnRlc3Qobi5zdGF0aWNEZWZpbml0aW9uU3ltYm9sIHx8IGkpID8gbmV3IFJlZ0V4cChcIltcIiArIChuLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgfHwgaSkgKyBcIl1cIiwgbi5jYXNpbmcgPyBcImlcIiA6IFwiXCIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxpdHk6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9ja01hcmtlcjogdm9pZCAwID09PSBvID8gXCJtYXN0ZXJcIiA6IG8uZGVmICE9PSBpICYmICEwICE9PSBvLnN0YXRpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWY6IG4uc3RhdGljRGVmaW5pdGlvblN5bWJvbCB8fCBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogdm9pZCAwICE9PSBuLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgPyBpIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVEZWY6IChoID8gXCInXCIgOiBcIlwiKSArIGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgaCA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBiKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrKGMgPSBtW20ubGVuZ3RoIC0gMV0sIGEpLCBjLmlzQWx0ZXJuYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gbS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB1Lm1hdGNoZXMubGVuZ3RoOyBlKyspIHUubWF0Y2hlc1tlXS5pc0dyb3VwICYmICh1Lm1hdGNoZXNbZV0uaXNHcm91cCA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5sZW5ndGggPiAwID8gKGMgPSBtW20ubGVuZ3RoIC0gMV0pLm1hdGNoZXMucHVzaCh1KSA6IHYubWF0Y2hlcy5wdXNoKHUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBrKHYsIGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHgoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgby5kZWZhdWx0KCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0Lm9wZW5Hcm91cCA9ICExLCB0Lm1hdGNoZXMgPSBlLCB0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHcoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHMgPSBtLnBvcCgpKS5vcGVuR3JvdXAgPSAhMSwgdm9pZCAwICE9PSBzKSBpZiAobS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjID0gbVttLmxlbmd0aCAtIDFdKS5tYXRjaGVzLnB1c2gocyksIGMuaXNBbHRlcm5hdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBtLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHUubWF0Y2hlcy5sZW5ndGg7IGUrKykgdS5tYXRjaGVzW2VdLmlzR3JvdXAgPSAhMSwgdS5tYXRjaGVzW2VdLmFsdGVybmF0b3JHcm91cCA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmxlbmd0aCA+IDAgPyAoYyA9IG1bbS5sZW5ndGggLSAxXSkubWF0Y2hlcy5wdXNoKHUpIDogdi5tYXRjaGVzLnB1c2godSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHYubWF0Y2hlcy5wdXNoKHMpOyBlbHNlIGIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBQKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlzUXVhbnRpZmllciAmJiAodCA9IHgoWyBlLnBvcCgpLCB0IF0pKSwgdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ICYmIChuLm9wdGlvbmFsbWFya2VyWzBdID0gdm9pZCAwLCBuLm9wdGlvbmFsbWFya2VyWzFdID0gdm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7aSA9IHQgPyBkLmV4ZWMoZSkgOiBwLmV4ZWMoZSk7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPSBpWzBdLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IFwiezAsMX1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gXCJ7XCIgKyBhICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBTID0geCh2Lm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUy5vcGVuR3JvdXAgPSAhMCwgbS5wdXNoKFMpLCB2Lm1hdGNoZXMgPSBbXSwgeSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBcIlswLTldXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxcXHBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBkLmV4ZWMoZSlbMF0sIGEgKz0gZC5leGVjKGUpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoKSBiKCk7IGVsc2Ugc3dpdGNoIChhLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgfHwgYigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugbi5lc2NhcGVDaGFyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSAhMCwgdCAmJiBiKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBuLm9wdGlvbmFsbWFya2VyWzFdOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG4uZ3JvdXBtYXJrZXJbMV06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugbi5vcHRpb25hbG1hcmtlclswXTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnB1c2gobmV3IG8uZGVmYXVsdCghMSwgITApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG4uZ3JvdXBtYXJrZXJbMF06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5wdXNoKG5ldyBvLmRlZmF1bHQoITApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG4ucXVhbnRpZmllcm1hcmtlclswXTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTyA9IG5ldyBvLmRlZmF1bHQoITEsICExLCAhMCksIF8gPSAoYSA9IGEucmVwbGFjZSgvW3t9P10vZywgXCJcIikpLnNwbGl0KFwifFwiKSwgTSA9IF9bMF0uc3BsaXQoXCIsXCIpLCBFID0gaXNOYU4oTVswXSkgPyBNWzBdIDogcGFyc2VJbnQoTVswXSksIGogPSAxID09PSBNLmxlbmd0aCA/IEUgOiBpc05hTihNWzFdKSA/IE1bMV0gOiBwYXJzZUludChNWzFdKSwgVCA9IGlzTmFOKF9bMV0pID8gX1sxXSA6IHBhcnNlSW50KF9bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKlwiICE9PSBFICYmIFwiK1wiICE9PSBFIHx8IChFID0gXCIqXCIgPT09IGogPyAwIDogMSksIE8ucXVhbnRpZmllciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiBFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGppdDogVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEEgPSBtLmxlbmd0aCA+IDAgPyBtW20ubGVuZ3RoIC0gMV0ubWF0Y2hlcyA6IHYubWF0Y2hlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaSA9IEEucG9wKCkpLmlzR3JvdXAgfHwgKGkgPSB4KFsgaSBdKSksIEEucHVzaChpKSwgQS5wdXNoKE8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugbi5hbHRlcm5hdG9ybWFya2VyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEQgPSAoYyA9IG1bbS5sZW5ndGggLSAxXSkubWF0Y2hlc1tjLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBjLm9wZW5Hcm91cCAmJiAodm9pZCAwID09PSBELm1hdGNoZXMgfHwgITEgPT09IEQuaXNHcm91cCAmJiAhMSA9PT0gRC5pc0FsdGVybmF0b3IpID8gbS5wb3AoKSA6IFAoYy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZiA9IFAodi5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi5pc0FsdGVybmF0b3IpIG0ucHVzaChmKTsgZWxzZSBpZiAoZi5hbHRlcm5hdG9yR3JvdXAgPyAodSA9IG0ucG9wKCksIGYuYWx0ZXJuYXRvckdyb3VwID0gITEpIDogdSA9IG5ldyBvLmRlZmF1bHQoITEsICExLCAhMSwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1Lm1hdGNoZXMucHVzaChmKSwgbS5wdXNoKHUpLCBmLm9wZW5Hcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLm9wZW5Hcm91cCA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTCA9IG5ldyBvLmRlZmF1bHQoITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMLmFsdGVybmF0b3JHcm91cCA9ICEwLCBtLnB1c2goTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkgJiYgdygpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDttLmxlbmd0aCA+IDA7ICkgcyA9IG0ucG9wKCksIHYubWF0Y2hlcy5wdXNoKHMpO1xuICAgICAgICAgICAgICAgICAgICB2Lm1hdGNoZXMubGVuZ3RoID4gMCAmJiAoIWZ1bmN0aW9uIGUoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSAmJiBpLm1hdGNoZXMgJiYgaS5tYXRjaGVzLmZvckVhY2goKGZ1bmN0aW9uKGEsIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGkubWF0Y2hlc1tyICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZvaWQgMCA9PT0gbyB8fCB2b2lkIDAgPT09IG8ubWF0Y2hlcyB8fCAhMSA9PT0gby5pc1F1YW50aWZpZXIpICYmIGEgJiYgYS5pc0dyb3VwICYmIChhLmlzR3JvdXAgPSAhMSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCB8fCAoayhhLCBuLmdyb3VwbWFya2VyWzBdLCAwKSwgITAgIT09IGEub3Blbkdyb3VwICYmIGsoYSwgbi5ncm91cG1hcmtlclsxXSkpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZShhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSh2KSwgZy5wdXNoKHYpKTtcbiAgICAgICAgICAgICAgICAgICAgKG4ubnVtZXJpY0lucHV0IHx8IG4uaXNSVEwpICYmIGZ1bmN0aW9uIGUodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0Lm1hdGNoZXMgPSB0Lm1hdGNoZXMucmV2ZXJzZSgpLCB0Lm1hdGNoZXMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodC5tYXRjaGVzLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gcGFyc2VJbnQoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQubWF0Y2hlc1tpXS5pc1F1YW50aWZpZXIgJiYgdC5tYXRjaGVzW2EgKyAxXSAmJiB0Lm1hdGNoZXNbYSArIDFdLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0Lm1hdGNoZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQubWF0Y2hlcy5zcGxpY2UoaSwgMSksIHQubWF0Y2hlcy5zcGxpY2UoYSArIDEsIDAsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHQubWF0Y2hlc1tpXS5tYXRjaGVzID8gdC5tYXRjaGVzW2ldID0gZSh0Lm1hdGNoZXNbaV0pIDogdC5tYXRjaGVzW2ldID0gKChvID0gdC5tYXRjaGVzW2ldKSA9PT0gbi5vcHRpb25hbG1hcmtlclswXSA/IG8gPSBuLm9wdGlvbmFsbWFya2VyWzFdIDogbyA9PT0gbi5vcHRpb25hbG1hcmtlclsxXSA/IG8gPSBuLm9wdGlvbmFsbWFya2VyWzBdIDogbyA9PT0gbi5ncm91cG1hcmtlclswXSA/IG8gPSBuLmdyb3VwbWFya2VyWzFdIDogbyA9PT0gbi5ncm91cG1hcmtlclsxXSAmJiAobyA9IG4uZ3JvdXBtYXJrZXJbMF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgIH0oZ1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgICAgIH0sIHQuZ2VuZXJhdGVNYXNrU2V0ID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbyhlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHQucmVwZWF0LCBpID0gdC5ncm91cG1hcmtlciwgciA9IHQucXVhbnRpZmllcm1hcmtlciwgbyA9IHQua2VlcFN0YXRpYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID4gMCB8fCBcIipcIiA9PT0gbiB8fCBcIitcIiA9PT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gXCIqXCIgPT09IG4gPyAwIDogXCIrXCIgPT09IG4gPyAxIDogbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobCAhPSBuKSBlID0gaVswXSArIGUgKyBpWzFdICsgclswXSArIGwgKyBcIixcIiArIG4gKyByWzFdOyBlbHNlIGZvciAodmFyIGMgPSBlLCB1ID0gMTsgdSA8IGw7IHUrKykgZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBlLm1hdGNoKG5ldyBSZWdFeHAoXCIoLilcXFxcWyhbXlxcXFxdXSopXFxcXF1cIiwgXCJnXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmICYmIGYuZm9yRWFjaCgoZnVuY3Rpb24odCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlKSB8fCBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBudWxsID09IGUgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGVbU3ltYm9sLml0ZXJhdG9yXSB8fCBlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBhLCByLCBvLCBsID0gW10sIHMgPSAhMCwgYyA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSAobiA9IG4uY2FsbChlKSkubmV4dCwgMCA9PT0gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QobikgIT09IG4pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZm9yICg7IShzID0gKGkgPSByLmNhbGwobikpLmRvbmUpICYmIChsLnB1c2goaS52YWx1ZSksIGwubGVuZ3RoICE9PSB0KTsgcyA9ICEwKSA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAhMCwgYSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcyAmJiBudWxsICE9IG4ucmV0dXJuICYmIChvID0gbi5yZXR1cm4oKSwgT2JqZWN0KG8pICE9PSBvKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYykgdGhyb3cgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGUsIHQpIHx8IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgcmV0dXJuIHMoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IG4gJiYgZS5jb25zdHJ1Y3RvciAmJiAobiA9IGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiTWFwXCIgPT09IG4gfHwgXCJTZXRcIiA9PT0gbikgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiQXJndW1lbnRzXCIgPT09IG4gfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBzKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlLCB0KSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHQuc3BsaXQoXCJbXCIpLCAyKSwgciA9IGlbMF0sIG8gPSBpWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gby5yZXBsYWNlKFwiXVwiLCBcIlwiKSwgZSA9IGUucmVwbGFjZShuZXcgUmVnRXhwKFwiXCIuY29uY2F0KCgwLCBhLmRlZmF1bHQpKHIpLCBcIlxcXFxbXCIpLmNvbmNhdCgoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZGVmYXVsdCkobyksIFwiXFxcXF1cIikpLCByLmNoYXJBdCgwKSA9PT0gby5jaGFyQXQoMCkgPyBcIihcIi5jb25jYXQociwgXCJ8XCIpLmNvbmNhdChyKS5jb25jYXQobywgXCIpXCIpIDogXCJcIi5jb25jYXQociwgXCJbXCIpLmNvbmNhdChvLCBcIl1cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSwgbiwgYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMsIGMsIHUgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsICE9PSBlICYmIFwiXCIgIT09IGUgfHwgKCh1ID0gbnVsbCAhPT0gYS5yZWdleCkgPyBlID0gKGUgPSBhLnJlZ2V4KS5yZXBsYWNlKC9eKFxcXikoLiopKFxcJCkkLywgXCIkMlwiKSA6ICh1ID0gITAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFwiLipcIikpLCAxID09PSBlLmxlbmd0aCAmJiAhMSA9PT0gYS5ncmVlZHkgJiYgMCAhPT0gYS5yZXBlYXQgJiYgKGEucGxhY2Vob2xkZXIgPSBcIlwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gbyhlLCBhKSwgYyA9IHUgPyBcInJlZ2V4X1wiICsgYS5yZWdleCA6IGEubnVtZXJpY0lucHV0ID8gZS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKSA6IGUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gYS5rZWVwU3RhdGljICYmIChjID0gXCJrc19cIiArIGEua2VlcFN0YXRpYyArIGMpLCBcIm9iamVjdFwiID09PSBsKGEucGxhY2Vob2xkZXIpICYmIChjID0gXCJwaF9cIiArIEpTT04uc3RyaW5naWZ5KGEucGxhY2Vob2xkZXIpICsgYyksIFxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSByLmRlZmF1bHQucHJvdG90eXBlLm1hc2tzQ2FjaGVbY10gfHwgITAgPT09IHQgPyAocyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tUb2tlbjogci5kZWZhdWx0LnByb3RvdHlwZS5hbmFseXNlTWFzayhlLCB1LCBhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZFBvc2l0aW9uczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2J1ZmZlcjogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNsdWRlczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0xlbmd0aDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGppdE9mZnNldDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICEwICE9PSB0ICYmIChyLmRlZmF1bHQucHJvdG90eXBlLm1hc2tzQ2FjaGVbY10gPSBzLCBzID0gaS5kZWZhdWx0LmV4dGVuZCghMCwge30sIHIuZGVmYXVsdC5wcm90b3R5cGUubWFza3NDYWNoZVtjXSkpKSA6IHMgPSBpLmRlZmF1bHQuZXh0ZW5kKCEwLCB7fSwgci5kZWZhdWx0LnByb3RvdHlwZS5tYXNrc0NhY2hlW2NdKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5tYXNrICYmIChlLm1hc2sgPSBlLm1hc2soZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlLm1hc2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5tYXNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsID09PSBlLmtlZXBTdGF0aWMgJiYgKGUua2VlcFN0YXRpYyA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGUuZ3JvdXBtYXJrZXJbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmlzUlRMID8gZS5tYXNrLnJldmVyc2UoKSA6IGUubWFzaykuZm9yRWFjaCgoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1Lmxlbmd0aCA+IDEgJiYgKHUgKz0gZS5hbHRlcm5hdG9ybWFya2VyKSwgdm9pZCAwICE9PSB0Lm1hc2sgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0Lm1hc2sgPyB1ICs9IHQubWFzayA6IHUgKz0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksIGModSArPSBlLmdyb3VwbWFya2VyWzFdLCBlLm1hc2ssIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5tYXNrID0gZS5tYXNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG4gPSBlLm1hc2sgJiYgdm9pZCAwICE9PSBlLm1hc2subWFzayAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUubWFzay5tYXNrID8gYyhlLm1hc2subWFzaywgZS5tYXNrLCBlKSA6IGMoZS5tYXNrLCBlLm1hc2ssIGUpO1xuICAgICAgICAgICAgICAgICAgICBudWxsID09PSBlLmtlZXBTdGF0aWMgJiYgKGUua2VlcFN0YXRpYyA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGMobig0OTYzKSksIGEgPSBjKG4oNzE4NCkpLCByID0gYyhuKDIzOTQpKSwgbyA9IGMobig5Njk1KSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIGwoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSB0IHx8IHQgPiBlLmxlbmd0aCkgJiYgKHQgPSBlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gbmV3IEFycmF5KHQpOyBuIDwgdDsgbisrKSBpW25dID0gZVtuXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxNTc6IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQubWFzayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMsIHQgPSB0aGlzLm9wdHMsIG4gPSB0aGlzLmVsLCBjID0gdGhpcy5kZXBlbmRlbmN5TGliO1xuICAgICAgICAgICAgICAgICAgICByLkV2ZW50UnVsZXIub2ZmKG4pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpLCBhID0gXCJpbnB1dFwiID09PSB0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAmJiBuLnN1cHBvcnRzSW5wdXRUeXBlLmluY2x1ZGVzKGkpIHx8IHQuaXNDb250ZW50RWRpdGFibGUgfHwgXCJ0ZXh0YXJlYVwiID09PSB0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYSkgaWYgKFwiaW5wdXRcIiA9PT0gdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgaSksIGEgPSBcInRleHRcIiA9PT0gcy50eXBlLCBzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBhID0gXCJwYXJ0aWFsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITEgIT09IGEgPyBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRtYXNrID8gdGhpcy5pbnB1dG1hc2sub3B0cy5hdXRvVW5tYXNrID8gdGhpcy5pbnB1dG1hc2sudW5tYXNrZWR2YWx1ZSgpIDogLTEgIT09IGwuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChlKSB8fCAhMCAhPT0gbi5udWxsYWJsZSA/ICh0aGlzLmlucHV0bWFzay5zaGFkb3dSb290IHx8IHRoaXMub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCA9PT0gdGhpcyAmJiBuLmNsZWFyTWFza09uTG9zdEZvY3VzID8gKGUuaXNSVEwgPyBvLmNsZWFyT3B0aW9uYWxUYWlsLmNhbGwoZSwgbC5nZXRCdWZmZXIuY2FsbChlKS5zbGljZSgpKS5yZXZlcnNlKCkgOiBvLmNsZWFyT3B0aW9uYWxUYWlsLmNhbGwoZSwgbC5nZXRCdWZmZXIuY2FsbChlKS5zbGljZSgpKSkuam9pbihcIlwiKSA6IGkuY2FsbCh0aGlzKSA6IFwiXCIgOiBpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmNhbGwodGhpcywgZSksIHRoaXMuaW5wdXRtYXNrICYmICgwLCBvLmFwcGx5SW5wdXRWYWx1ZSkodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdC5pbnB1dG1hc2suX192YWx1ZUdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgIT09IG4ubm9WYWx1ZVBhdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gT2JqZWN0LmdldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YodCksIFwidmFsdWVcIikgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiAmJiBmLmdldCAmJiBmLnNldCA/IChpID0gZi5nZXQsIGEgPSBmLnNldCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogdSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSA6IFwiaW5wdXRcIiAhPT0gdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgJiYgKGkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgYSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0Q29udGVudCA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogdSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBkb2N1bWVudC5fX2xvb2t1cEdldHRlcl9fICYmIHQuX19sb29rdXBHZXR0ZXJfXyhcInZhbHVlXCIpICYmIChpID0gdC5fX2xvb2t1cEdldHRlcl9fKFwidmFsdWVcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHQuX19sb29rdXBTZXR0ZXJfXyhcInZhbHVlXCIpLCB0Ll9fZGVmaW5lR2V0dGVyX18oXCJ2YWx1ZVwiLCBzKSwgdC5fX2RlZmluZVNldHRlcl9fKFwidmFsdWVcIiwgdSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5pbnB1dG1hc2suX192YWx1ZUdldCA9IGksIHQuaW5wdXRtYXNrLl9fdmFsdWVTZXQgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuaW5wdXRtYXNrLl92YWx1ZUdldCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmlzUlRMICYmICEwICE9PSB0ID8gaS5jYWxsKHRoaXMuZWwpLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpIDogaS5jYWxsKHRoaXMuZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0LmlucHV0bWFzay5fdmFsdWVTZXQgPSBmdW5jdGlvbih0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmNhbGwodGhpcy5lbCwgbnVsbCA9PSB0ID8gXCJcIiA6ICEwICE9PSBuICYmIGUuaXNSVEwgPyB0LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpIDogdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZvaWQgMCA9PT0gaSAmJiAoaSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGEgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMudmFsSG9va3MgJiYgKHZvaWQgMCA9PT0gYy52YWxIb29rc1t0XSB8fCAhMCAhPT0gYy52YWxIb29rc1t0XS5pbnB1dG1hc2twYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGMudmFsSG9va3NbdF0gJiYgYy52YWxIb29rc1t0XS5nZXQgPyBjLnZhbEhvb2tzW3RdLmdldCA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgYSA9IGMudmFsSG9va3NbdF0gJiYgYy52YWxIb29rc1t0XS5zZXQgPyBjLnZhbEhvb2tzW3RdLnNldCA6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWUgPSB0LCBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy52YWxIb29rc1t0XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5pbnB1dG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5pbnB1dG1hc2sub3B0cy5hdXRvVW5tYXNrKSByZXR1cm4gdC5pbnB1dG1hc2sudW5tYXNrZWR2YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gaSh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgIT09IGwuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChlLCB2b2lkIDAsIHZvaWQgMCwgdC5pbnB1dG1hc2subWFza3NldC52YWxpZFBvc2l0aW9ucykgfHwgITAgIT09IG4ubnVsbGFibGUgPyBhIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gYShlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmlucHV0bWFzayAmJiAoMCwgby5hcHBseUlucHV0VmFsdWUpKGUsIHQpLCBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dG1hc2twYXRjaDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHQudHlwZSksIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuRXZlbnRSdWxlci5vbihlLCBcIm1vdXNlZW50ZXJcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcywgdCA9IGUuaW5wdXRtYXNrLl92YWx1ZUdldCghMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCAhPSAoZS5pbnB1dG1hc2suaXNSVEwgPyBsLmdldEJ1ZmZlci5jYWxsKGUuaW5wdXRtYXNrKS5zbGljZSgpLnJldmVyc2UoKSA6IGwuZ2V0QnVmZmVyLmNhbGwoZS5pbnB1dG1hc2spKS5qb2luKFwiXCIpICYmICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmFwcGx5SW5wdXRWYWx1ZSkoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0odCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0odCkgOiB0LmlucHV0bWFzayA9IHZvaWQgMCwgYTtcbiAgICAgICAgICAgICAgICAgICAgfShuLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCExICE9PSB1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLm9yaWdpbmFsUGxhY2Vob2xkZXIgPSBuLnBsYWNlaG9sZGVyLCBlLm1heExlbmd0aCA9IHZvaWQgMCAhPT0gbiA/IG4ubWF4TGVuZ3RoIDogdm9pZCAwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC0xID09PSBlLm1heExlbmd0aCAmJiAoZS5tYXhMZW5ndGggPSB2b2lkIDApLCBcImlucHV0TW9kZVwiIGluIG4gJiYgbnVsbCA9PT0gbi5nZXRBdHRyaWJ1dGUoXCJpbnB1dG1vZGVcIikgJiYgKG4uaW5wdXRNb2RlID0gdC5pbnB1dG1vZGUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgbi5zZXRBdHRyaWJ1dGUoXCJpbnB1dG1vZGVcIiwgdC5pbnB1dG1vZGUpKSwgITAgPT09IHUgJiYgKHQuc2hvd01hc2tPbkZvY3VzID0gdC5zaG93TWFza09uRm9jdXMgJiYgLTEgPT09IFsgXCJjYy1udW1iZXJcIiwgXCJjYy1leHBcIiBdLmluZGV4T2Yobi5hdXRvY29tcGxldGUpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuaXBob25lICYmICh0Lmluc2VydE1vZGVWaXN1YWwgPSAhMSwgbi5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLCBcIm9mZlwiKSksIHIuRXZlbnRSdWxlci5vbihuLCBcInN1Ym1pdFwiLCBhLkV2ZW50SGFuZGxlcnMuc3VibWl0RXZlbnQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuRXZlbnRSdWxlci5vbihuLCBcInJlc2V0XCIsIGEuRXZlbnRIYW5kbGVycy5yZXNldEV2ZW50KSwgci5FdmVudFJ1bGVyLm9uKG4sIFwiYmx1clwiLCBhLkV2ZW50SGFuZGxlcnMuYmx1ckV2ZW50KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICByLkV2ZW50UnVsZXIub24obiwgXCJmb2N1c1wiLCBhLkV2ZW50SGFuZGxlcnMuZm9jdXNFdmVudCksIHIuRXZlbnRSdWxlci5vbihuLCBcImludmFsaWRcIiwgYS5FdmVudEhhbmRsZXJzLmludmFsaWRFdmVudCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgci5FdmVudFJ1bGVyLm9uKG4sIFwiY2xpY2tcIiwgYS5FdmVudEhhbmRsZXJzLmNsaWNrRXZlbnQpLCByLkV2ZW50UnVsZXIub24obiwgXCJtb3VzZWxlYXZlXCIsIGEuRXZlbnRIYW5kbGVycy5tb3VzZWxlYXZlRXZlbnQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuRXZlbnRSdWxlci5vbihuLCBcIm1vdXNlZW50ZXJcIiwgYS5FdmVudEhhbmRsZXJzLm1vdXNlZW50ZXJFdmVudCksIHIuRXZlbnRSdWxlci5vbihuLCBcInBhc3RlXCIsIGEuRXZlbnRIYW5kbGVycy5wYXN0ZUV2ZW50KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICByLkV2ZW50UnVsZXIub24obiwgXCJjdXRcIiwgYS5FdmVudEhhbmRsZXJzLmN1dEV2ZW50KSwgci5FdmVudFJ1bGVyLm9uKG4sIFwiY29tcGxldGVcIiwgdC5vbmNvbXBsZXRlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICByLkV2ZW50UnVsZXIub24obiwgXCJpbmNvbXBsZXRlXCIsIHQub25pbmNvbXBsZXRlKSwgci5FdmVudFJ1bGVyLm9uKG4sIFwiY2xlYXJlZFwiLCB0Lm9uY2xlYXJlZCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgITAgIT09IHQuaW5wdXRFdmVudE9ubHkgJiYgci5FdmVudFJ1bGVyLm9uKG4sIFwia2V5ZG93blwiLCBhLkV2ZW50SGFuZGxlcnMua2V5RXZlbnQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIChpLm1vYmlsZSB8fCB0LmlucHV0RXZlbnRPbmx5KSAmJiBuLnJlbW92ZUF0dHJpYnV0ZShcIm1heExlbmd0aFwiKSwgci5FdmVudFJ1bGVyLm9uKG4sIFwiaW5wdXRcIiwgYS5FdmVudEhhbmRsZXJzLmlucHV0RmFsbEJhY2tFdmVudCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuRXZlbnRSdWxlci5vbihuLCBcInNldHZhbHVlXCIsIGEuRXZlbnRIYW5kbGVycy5zZXRWYWx1ZUV2ZW50KSwgdm9pZCAwID09PSBlLmFwcGx5TWFza0hvb2sgfHwgZS5hcHBseU1hc2tIb29rKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgbC5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGUpLmpvaW4oXCJcIiksIGUudW5kb1ZhbHVlID0gZS5fdmFsdWVHZXQoITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSAobi5pbnB1dG1hc2suc2hhZG93Um9vdCB8fCBuLm93bmVyRG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJcIiAhPT0gbi5pbnB1dG1hc2suX3ZhbHVlR2V0KCEwKSB8fCAhMSA9PT0gdC5jbGVhck1hc2tPbkxvc3RGb2N1cyB8fCBmID09PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIG8uYXBwbHlJbnB1dFZhbHVlKShuLCBuLmlucHV0bWFzay5fdmFsdWVHZXQoITApLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGwuZ2V0QnVmZmVyLmNhbGwoZSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhMSA9PT0gcy5pc0NvbXBsZXRlLmNhbGwoZSwgcCkgJiYgdC5jbGVhckluY29tcGxldGUgJiYgbC5yZXNldE1hc2tTZXQuY2FsbChlLCAhMSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgJiYgZiAhPT0gbiAmJiAoLTEgPT09IGwuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChlKSA/IHAgPSBbXSA6IG8uY2xlYXJPcHRpb25hbFRhaWwuY2FsbChlLCBwKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghMSA9PT0gdC5jbGVhck1hc2tPbkxvc3RGb2N1cyB8fCB0LnNob3dNYXNrT25Gb2N1cyAmJiBmID09PSBuIHx8IFwiXCIgIT09IG4uaW5wdXRtYXNrLl92YWx1ZUdldCghMCkpICYmICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLndyaXRlQnVmZmVyKShuLCBwKSwgZiA9PT0gbiAmJiBsLmNhcmV0LmNhbGwoZSwgbiwgbC5zZWVrTmV4dC5jYWxsKGUsIGwuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IG4oOTg0NSksIGEgPSBuKDYwMzApLCByID0gbig5NzE2KSwgbyA9IG4oNzc2MCksIGwgPSBuKDg3MTEpLCBzID0gbig3MjE1KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA5Njk1OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSBmdW5jdGlvbihlLCB0LCBuLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdLCB0aGlzLm9wZW5Hcm91cCA9IGUgfHwgITEsIHRoaXMuYWx0ZXJuYXRvckdyb3VwID0gITEsIHRoaXMuaXNHcm91cCA9IGUgfHwgITEsIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0IHx8ICExLCB0aGlzLmlzUXVhbnRpZmllciA9IG4gfHwgITEsIHRoaXMuaXNBbHRlcm5hdG9yID0gaSB8fCAhMSwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVhbnRpZmllciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMzE5NDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsIFwiaW5jbHVkZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gdGhpcykgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0aGlzXCIgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBPYmplY3QodGhpcyksIGkgPSBuLmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBpKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMCB8IHQsIHIgPSBNYXRoLm1heChhID49IDAgPyBhIDogaSAtIE1hdGguYWJzKGEpLCAwKTsgciA8IGk7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuW3JdID09PSBlKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgOTMwMjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBGdW5jdGlvbi5iaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLnJlZHVjZSksIHQgPSBGdW5jdGlvbi5iaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSksIG4gPSBGdW5jdGlvbi5iaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCksIGkgPSBPYmplY3Qua2V5cztcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyB8fCAoT2JqZWN0LmVudHJpZXMgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlKGkoYSksIChmdW5jdGlvbihlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbihlLCBcInN0cmluZ1wiID09IHR5cGVvZiBpICYmIHQoYSwgaSkgPyBbIFsgaSwgYVtpXSBdIF0gOiBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLCBbXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNzE0OTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZSh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIGUodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YgPSBcIm9iamVjdFwiID09PSBlKFwidGVzdFwiLl9fcHJvdG9fXykgPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLl9fcHJvdG9fXztcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNDAxMzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyB8fCAoU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgIT0gdHlwZW9mIHQgJiYgKHQgPSAwKSwgISh0ICsgZS5sZW5ndGggPiB0aGlzLmxlbmd0aCkgJiYgLTEgIT09IHRoaXMuaW5kZXhPZihlLCB0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA4NzExOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmNhcmV0ID0gZnVuY3Rpb24oZSwgdCwgbiwgaSwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbywgbCA9IHRoaXMsIHMgPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHQpIHJldHVybiBcInNlbGVjdGlvblN0YXJ0XCIgaW4gZSAmJiBcInNlbGVjdGlvbkVuZFwiIGluIGUgPyAodCA9IGUuc2VsZWN0aW9uU3RhcnQsIFxuICAgICAgICAgICAgICAgICAgICBuID0gZS5zZWxlY3Rpb25FbmQpIDogYS5kZWZhdWx0LmdldFNlbGVjdGlvbiA/IChvID0gYS5kZWZhdWx0LmdldFNlbGVjdGlvbigpLmdldFJhbmdlQXQoMCkpLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLnBhcmVudE5vZGUgIT09IGUgJiYgby5jb21tb25BbmNlc3RvckNvbnRhaW5lciAhPT0gZSB8fCAodCA9IG8uc3RhcnRPZmZzZXQsIFxuICAgICAgICAgICAgICAgICAgICBuID0gby5lbmRPZmZzZXQpIDogZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSAmJiAobiA9ICh0ID0gMCAtIChvID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkpLmR1cGxpY2F0ZSgpLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCAtZS5pbnB1dG1hc2suX3ZhbHVlR2V0KCkubGVuZ3RoKSkgKyBvLnRleHQubGVuZ3RoKSwgXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luOiBpID8gdCA6IGYuY2FsbChsLCB0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaSA/IG4gOiBmLmNhbGwobCwgbilcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkgJiYgKG4gPSBsLmlzUlRMID8gdFswXSA6IHRbMV0sIHQgPSBsLmlzUlRMID8gdFsxXSA6IHRbMF0pLCBcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSB0LmJlZ2luICYmIChuID0gbC5pc1JUTCA/IHQuYmVnaW4gOiB0LmVuZCwgdCA9IGwuaXNSVEwgPyB0LmVuZCA6IHQuYmVnaW4pLCBcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGkgPyB0IDogZi5jYWxsKGwsIHQpLCBuID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgKG4gPSBpID8gbiA6IGYuY2FsbChsLCBuKSkgPyBuIDogdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gcGFyc2VJbnQoKChlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgYS5kZWZhdWx0KS5nZXRDb21wdXRlZFN0eWxlID8gKGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCBhLmRlZmF1bHQpLmdldENvbXB1dGVkU3R5bGUoZSwgbnVsbCkgOiBlLmN1cnJlbnRTdHlsZSkuZm9udFNpemUpICogbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnNjcm9sbExlZnQgPSBjID4gZS5zY3JvbGxXaWR0aCA/IGMgOiAwLCBlLmlucHV0bWFzay5jYXJldFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHMuaW5zZXJ0TW9kZVZpc3VhbCAmJiAhMSA9PT0gcy5pbnNlcnRNb2RlICYmIHQgPT09IG4gJiYgKHIgfHwgbisrKSwgZSA9PT0gKGUuaW5wdXRtYXNrLnNoYWRvd1Jvb3QgfHwgZS5vd25lckRvY3VtZW50KS5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic2V0U2VsZWN0aW9uUmFuZ2VcIiBpbiBlKSBlLnNldFNlbGVjdGlvblJhbmdlKHQsIG4pOyBlbHNlIGlmIChhLmRlZmF1bHQuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgdm9pZCAwID09PSBlLmZpcnN0Q2hpbGQgfHwgbnVsbCA9PT0gZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZCh1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnNldFN0YXJ0KGUuZmlyc3RDaGlsZCwgdCA8IGUuaW5wdXRtYXNrLl92YWx1ZUdldCgpLmxlbmd0aCA/IHQgOiBlLmlucHV0bWFzay5fdmFsdWVHZXQoKS5sZW5ndGgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5zZXRFbmQoZS5maXJzdENoaWxkLCBuIDwgZS5pbnB1dG1hc2suX3ZhbHVlR2V0KCkubGVuZ3RoID8gbiA6IGUuaW5wdXRtYXNrLl92YWx1ZUdldCgpLmxlbmd0aCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmNvbGxhcHNlKCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBhLmRlZmF1bHQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAucmVtb3ZlQWxsUmFuZ2VzKCksIHAuYWRkUmFuZ2Uobyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGUuY3JlYXRlVGV4dFJhbmdlICYmICgobyA9IGUuY3JlYXRlVGV4dFJhbmdlKCkpLmNvbGxhcHNlKCEwKSwgby5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsIG4pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCB0KSwgby5zZWxlY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBlLmlucHV0bWFzay5jYXJldEhvb2sgfHwgZS5pbnB1dG1hc2suY2FyZXRIb29rLmNhbGwobCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0LmRldGVybWluZUxhc3RSZXF1aXJlZFBvc2l0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCwgbiwgaSA9IHRoaXMsIGEgPSBpLm1hc2tzZXQsIGwgPSBpLmRlcGVuZGVuY3lMaWIsIGMgPSBzLmNhbGwoaSksIHUgPSB7fSwgZiA9IGEudmFsaWRQb3NpdGlvbnNbY10sIHAgPSBvLmdldE1hc2tUZW1wbGF0ZS5jYWxsKGksICEwLCBzLmNhbGwoaSksICEwLCAhMCksIGQgPSBwLmxlbmd0aCwgaCA9IHZvaWQgMCAhPT0gZiA/IGYubG9jYXRvci5zbGljZSgpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHQgPSBjICsgMTsgdCA8IHAubGVuZ3RoOyB0KyspIGggPSAobiA9IG8uZ2V0VGVzdFRlbXBsYXRlLmNhbGwoaSwgdCwgaCwgdCAtIDEpKS5sb2NhdG9yLnNsaWNlKCksIFxuICAgICAgICAgICAgICAgICAgICB1W3RdID0gbC5leHRlbmQoITAsIHt9LCBuKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBmICYmIHZvaWQgMCAhPT0gZi5hbHRlcm5hdGlvbiA/IGYubG9jYXRvcltmLmFsdGVybmF0aW9uXSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0ID0gZCAtIDE7IHQgPiBjICYmICgoKG4gPSB1W3RdKS5tYXRjaC5vcHRpb25hbGl0eSB8fCBuLm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllciAmJiBuLm1hdGNoLm5ld0Jsb2NrTWFya2VyIHx8IHYgJiYgKHYgIT09IHVbdF0ubG9jYXRvcltmLmFsdGVybmF0aW9uXSAmJiAhMCAhPT0gbi5tYXRjaC5zdGF0aWMgfHwgITAgPT09IG4ubWF0Y2guc3RhdGljICYmIG4ubG9jYXRvcltmLmFsdGVybmF0aW9uXSAmJiByLmNoZWNrQWx0ZXJuYXRpb25NYXRjaC5jYWxsKGksIG4ubG9jYXRvcltmLmFsdGVybmF0aW9uXS50b1N0cmluZygpLnNwbGl0KFwiLFwiKSwgdi50b1N0cmluZygpLnNwbGl0KFwiLFwiKSkgJiYgXCJcIiAhPT0gby5nZXRUZXN0cy5jYWxsKGksIHQpWzBdLmRlZikpICYmIHBbdF0gPT09IG8uZ2V0UGxhY2Vob2xkZXIuY2FsbChpLCB0LCBuLm1hdGNoKSk7IHQtLSkgZC0tO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGw6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IHVbZF0gPyB1W2RdLm1hdGNoIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH0gOiBkO1xuICAgICAgICAgICAgICAgIH0sIHQuZGV0ZXJtaW5lTmV3Q2FyZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIGEsIHIsIGYgPSB0aGlzLCBwID0gZi5tYXNrc2V0LCBkID0gZi5vcHRzO1xuICAgICAgICAgICAgICAgICAgICB0ICYmIChmLmlzUlRMID8gZS5lbmQgPSBlLmJlZ2luIDogZS5iZWdpbiA9IGUuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYmVnaW4gPT09IGUuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG4gPSBuIHx8IGQucG9zaXRpb25DYXJldE9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbC5jYWxsKGYpLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlnbm9yZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZW5kID0gZS5iZWdpbiA9IHUuY2FsbChmLCBzLmNhbGwoZikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyYWRpeEZvY3VzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYuY2xpY2tlZCA+IDEgJiYgMCA9PT0gcC52YWxpZFBvc2l0aW9ucy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIlwiICE9PSBkLnJhZGl4UG9pbnQgJiYgMCAhPT0gZC5kaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gcC52YWxpZFBvc2l0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHRbZV0gfHwgdm9pZCAwID09PSB0W2VdLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgPCB1LmNhbGwoZiwgLTEpKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBsLmNhbGwoZikuaW5kZXhPZihkLnJhZGl4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYSA9IHQubGVuZ3RoOyBpIDwgYTsgaSsrKSBpZiAodFtpXSAmJiBuIDwgaSAmJiB0W2ldLmlucHV0ICE9PSBvLmdldFBsYWNlaG9sZGVyLmNhbGwoZiwgaSkpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlLmJlZ2luKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGwuY2FsbChmKS5qb2luKFwiXCIpLmluZGV4T2YoZC5yYWRpeFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5lbmQgPSBlLmJlZ2luID0gZC5udW1lcmljSW5wdXQgPyB1LmNhbGwoZiwgaCkgOiBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IGUuYmVnaW4sIGEgPSBzLmNhbGwoZiwgaSwgITApLCBpIDw9IChyID0gdS5jYWxsKGYsIC0xICE9PSBhIHx8IGMuY2FsbChmLCAwKSA/IGEgOiAtMSkpKSBlLmVuZCA9IGUuYmVnaW4gPSBjLmNhbGwoZiwgaSwgITEsICEwKSA/IGkgOiB1LmNhbGwoZiwgaSk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHAudmFsaWRQb3NpdGlvbnNbYV0sIG0gPSBvLmdldFRlc3RUZW1wbGF0ZS5jYWxsKGYsIHIsIHYgPyB2Lm1hdGNoLmxvY2F0b3IgOiB2b2lkIDAsIHYpLCBnID0gby5nZXRQbGFjZWhvbGRlci5jYWxsKGYsIHIsIG0ubWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJcIiAhPT0gZyAmJiBsLmNhbGwoZilbcl0gIT09IGcgJiYgITAgIT09IG0ubWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyICYmICEwICE9PSBtLm1hdGNoLm5ld0Jsb2NrTWFya2VyIHx8ICFjLmNhbGwoZiwgciwgZC5rZWVwU3RhdGljLCAhMCkgJiYgbS5tYXRjaC5kZWYgPT09IGcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdS5jYWxsKGYsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGkgPj0geSB8fCBpID09PSByKSAmJiAociA9IHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZW5kID0gZS5iZWdpbiA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0LmdldEJ1ZmZlciA9IGwsIHQuZ2V0QnVmZmVyVGVtcGxhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm1hc2tzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZS5fYnVmZmVyICYmIChlLl9idWZmZXIgPSBvLmdldE1hc2tUZW1wbGF0ZS5jYWxsKHRoaXMsICExLCAxKSwgdm9pZCAwID09PSBlLmJ1ZmZlciAmJiAoZS5idWZmZXIgPSBlLl9idWZmZXIuc2xpY2UoKSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5fYnVmZmVyO1xuICAgICAgICAgICAgICAgIH0sIHQuZ2V0TGFzdFZhbGlkUG9zaXRpb24gPSBzLCB0LmlzTWFzayA9IGMsIHQucmVzZXRNYXNrU2V0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMubWFza3NldDtcbiAgICAgICAgICAgICAgICAgICAgdC5idWZmZXIgPSB2b2lkIDAsICEwICE9PSBlICYmICh0LnZhbGlkUG9zaXRpb25zID0gW10sIHQucCA9IDApO1xuICAgICAgICAgICAgICAgICAgICAhMSA9PT0gZSAmJiAodC50ZXN0cyA9IHt9LCB0LmppdE9mZnNldCA9IHt9KTtcbiAgICAgICAgICAgICAgICB9LCB0LnNlZWtOZXh0ID0gdSwgdC5zZWVrUHJldmlvdXMgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcywgaSA9IGUgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSA8PSAwKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7aSA+IDAgJiYgKCEwID09PSB0ICYmICghMCAhPT0gby5nZXRUZXN0LmNhbGwobiwgaSkubWF0Y2gubmV3QmxvY2tNYXJrZXIgfHwgIWMuY2FsbChuLCBpLCB2b2lkIDAsICEwKSkgfHwgITAgIT09IHQgJiYgIWMuY2FsbChuLCBpLCB2b2lkIDAsICEwKSk7ICkgaS0tO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9LCB0LnRyYW5zbGF0ZVBvc2l0aW9uID0gZjtcbiAgICAgICAgICAgICAgICB2YXIgaSwgYSA9IChpID0gbig5MzgwKSkgJiYgaS5fX2VzTW9kdWxlID8gaSA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogaVxuICAgICAgICAgICAgICAgIH0sIHIgPSBuKDcyMTUpLCBvID0gbig0NzEzKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLCBuID0gdC5tYXNrc2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBuLmJ1ZmZlciAmJiAhMCAhPT0gZSB8fCAobi5idWZmZXIgPSBvLmdldE1hc2tUZW1wbGF0ZS5jYWxsKHQsICEwLCBzLmNhbGwodCksICEwKSwgXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gbi5fYnVmZmVyICYmIChuLl9idWZmZXIgPSBuLmJ1ZmZlci5zbGljZSgpKSksIG4uYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLm1hc2tzZXQsIGEgPSAtMSwgciA9IC0xLCBvID0gbiB8fCBpLnZhbGlkUG9zaXRpb25zO1xuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwLCBzID0gby5sZW5ndGg7IGwgPCBzOyBsKyspIG9bbF0gJiYgKHQgfHwgITAgIT09IG9bbF0uZ2VuZXJhdGVkSW5wdXQpICYmIChsIDw9IGUgJiYgKGEgPSBsKSwgXG4gICAgICAgICAgICAgICAgICAgIGwgPj0gZSAmJiAociA9IGwpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xID09PSBhIHx8IGEgPT09IGUgPyByIDogLTEgPT09IHIgfHwgZSAtIGEgPCByIC0gZSA/IGEgOiByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLCBhID0gdGhpcy5tYXNrc2V0LCByID0gby5nZXRUZXN0VGVtcGxhdGUuY2FsbChpLCBlKS5tYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgPT09IHIuZGVmICYmIChyID0gby5nZXRUZXN0LmNhbGwoaSwgZSkubWF0Y2gpLCAhMCAhPT0gci5zdGF0aWMpIHJldHVybiByLmZuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IG4gJiYgdm9pZCAwICE9PSBhLnZhbGlkUG9zaXRpb25zW2VdICYmICEwICE9PSBhLnZhbGlkUG9zaXRpb25zW2VdLmdlbmVyYXRlZElucHV0KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIGlmICghMCAhPT0gdCAmJiBlID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBvLmdldFRlc3RzLmNhbGwoaSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwubGVuZ3RoID4gMSArIChcIlwiID09PSBsW2wubGVuZ3RoIC0gMV0ubWF0Y2guZGVmID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBvLmRldGVybWluZVRlc3RUZW1wbGF0ZS5jYWxsKGksIGUsIG8uZ2V0VGVzdHMuY2FsbChpLCBlKSksIGMgPSBvLmdldFBsYWNlaG9sZGVyLmNhbGwoaSwgZSwgcy5tYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5tYXRjaC5kZWYgIT09IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG4gJiYgKG4gPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSBlICsgMTsgXCJcIiAhPT0gby5nZXRUZXN0LmNhbGwoaSwgYSkubWF0Y2guZGVmICYmICghMCA9PT0gdCAmJiAoITAgIT09IG8uZ2V0VGVzdC5jYWxsKGksIGEpLm1hdGNoLm5ld0Jsb2NrTWFya2VyIHx8ICFjLmNhbGwoaSwgYSwgdm9pZCAwLCAhMCkpIHx8ICEwICE9PSB0ICYmICFjLmNhbGwoaSwgYSwgdm9pZCAwLCBuKSk7ICkgYSsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5vcHRzLCBuID0gdGhpcy5lbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzUlRMIHx8IFwibnVtYmVyXCIgIT0gdHlwZW9mIGUgfHwgdC5ncmVlZHkgJiYgXCJcIiA9PT0gdC5wbGFjZWhvbGRlciB8fCAhbiB8fCAoZSA9IHRoaXMuX3ZhbHVlR2V0KCkubGVuZ3RoIC0gZSkgPCAwICYmIChlID0gMCksIFxuICAgICAgICAgICAgICAgICAgICBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA0NzEzOiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRldGVybWluZVRlc3RUZW1wbGF0ZSA9IGYsIHQuZ2V0RGVjaXNpb25UYWtlciA9IHMsIHQuZ2V0TWFza1RlbXBsYXRlID0gZnVuY3Rpb24oZSwgdCwgbiwgaSwgYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMsIG8gPSB0aGlzLm9wdHMsIGwgPSB0aGlzLm1hc2tzZXQsIHMgPSBvLmdyZWVkeTtcbiAgICAgICAgICAgICAgICAgICAgYSAmJiBvLmdyZWVkeSAmJiAoby5ncmVlZHkgPSAhMSwgci5tYXNrc2V0LnRlc3RzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICB0ID0gdCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCwgZCwgdiwgbSwgZyA9IFtdLCB5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBlICYmIGwudmFsaWRQb3NpdGlvbnNbeV0pIGQgPSAodiA9IGEgJiYgbC52YWxpZFBvc2l0aW9uc1t5XS5tYXRjaC5vcHRpb25hbGl0eSAmJiB2b2lkIDAgPT09IGwudmFsaWRQb3NpdGlvbnNbeSArIDFdICYmICghMCA9PT0gbC52YWxpZFBvc2l0aW9uc1t5XS5nZW5lcmF0ZWRJbnB1dCB8fCBsLnZhbGlkUG9zaXRpb25zW3ldLmlucHV0ID09IG8uc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciAmJiB5ID4gMCkgPyBmLmNhbGwociwgeSwgaC5jYWxsKHIsIHksIHAsIHkgLSAxKSkgOiBsLnZhbGlkUG9zaXRpb25zW3ldKS5tYXRjaCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gdi5sb2NhdG9yLnNsaWNlKCksIGcucHVzaCghMCA9PT0gbiA/IHYuaW5wdXQgOiAhMSA9PT0gbiA/IGQubmF0aXZlRGVmIDogYy5jYWxsKHIsIHksIGQpKTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9ICh2ID0gdS5jYWxsKHIsIHksIHAsIHkgLSAxKSkubWF0Y2gsIHAgPSB2LmxvY2F0b3Iuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9ICEwICE9PSBpICYmICghMSAhPT0gby5qaXRNYXNraW5nID8gby5qaXRNYXNraW5nIDogZC5qaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtID0gKG0gfHwgbC52YWxpZFBvc2l0aW9uc1t5IC0gMV0pICYmIGQuc3RhdGljICYmIGQuZGVmICE9PSBvLmdyb3VwU2VwYXJhdG9yICYmIG51bGwgPT09IGQuZm4pIHx8ICExID09PSBrIHx8IHZvaWQgMCA9PT0gayB8fCBcIm51bWJlclwiID09IHR5cGVvZiBrICYmIGlzRmluaXRlKGspICYmIGsgPiB5ID8gZy5wdXNoKCExID09PSBuID8gZC5uYXRpdmVEZWYgOiBjLmNhbGwociwgZy5sZW5ndGgsIGQpKSA6IG0gPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHkrKztcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoITAgIT09IGQuc3RhdGljIHx8IFwiXCIgIT09IGQuZGVmIHx8IHQgPiB5KTtcbiAgICAgICAgICAgICAgICAgICAgXCJcIiA9PT0gZ1tnLmxlbmd0aCAtIDFdICYmIGcucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICExID09PSBuICYmIHZvaWQgMCAhPT0gbC5tYXNrTGVuZ3RoIHx8IChsLm1hc2tMZW5ndGggPSB5IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvLmdyZWVkeSA9IHMsIGc7XG4gICAgICAgICAgICAgICAgfSwgdC5nZXRQbGFjZWhvbGRlciA9IGMsIHQuZ2V0VGVzdCA9IHAsIHQuZ2V0VGVzdFRlbXBsYXRlID0gdSwgdC5nZXRUZXN0cyA9IGgsIHQuaXNTdWJzZXRPZiA9IGQ7XG4gICAgICAgICAgICAgICAgdmFyIGksIGEgPSAoaSA9IG4oMjM5NCkpICYmIGkuX19lc01vZHVsZSA/IGkgOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGlcbiAgICAgICAgICAgICAgICB9LCByID0gbig4NzExKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgbyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gKG51bGwgIT0gZS5hbHRlcm5hdGlvbiA/IGUubWxvY1tzKGUpXSA6IGUubG9jYXRvcikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgIT09IG4pIGZvciAobiA9IG4uc3BsaXQoXCI6XCIpWzBdOyBuLmxlbmd0aCA8IHQ7ICkgbiArPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUubG9jYXRvcltlLmFsdGVybmF0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgdC5sZW5ndGggPiAwICYmICh0ID0gdC5zcGxpdChcIixcIilbMF0pLCB2b2lkIDAgIT09IHQgPyB0LnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLCBhID0gdGhpcy5vcHRzLCBsID0gdGhpcy5tYXNrc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSAodCA9IHQgfHwgcC5jYWxsKGksIGUpLm1hdGNoKS5wbGFjZWhvbGRlciB8fCAhMCA9PT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgIT09IHQucGxhY2Vob2xkZXIgJiYgITAgPT09IHQuc3RhdGljICYmICEwICE9PSB0LmdlbmVyYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gci5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGksIGUpLCBjID0gci5zZWVrTmV4dC5jYWxsKGksIHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobiA/IGUgPD0gYyA6IGUgPCBjKSA/IGEuc3RhdGljRGVmaW5pdGlvblN5bWJvbCAmJiB0LnN0YXRpYyA/IHQubmF0aXZlRGVmIDogdC5kZWYgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQucGxhY2Vob2xkZXIgPyB0LnBsYWNlaG9sZGVyKGEpIDogdC5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQucGxhY2Vob2xkZXIgPyB0LnBsYWNlaG9sZGVyKGEpIDogdC5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IHQuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSA+IC0xICYmIHZvaWQgMCA9PT0gbC52YWxpZFBvc2l0aW9uc1tlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1LCBmID0gaC5jYWxsKGksIGUpLCBkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGEucGxhY2Vob2xkZXIgJiYgZi5sZW5ndGggPiAxICsgKFwiXCIgPT09IGZbZi5sZW5ndGggLSAxXS5tYXRjaC5kZWYgPyAxIDogMCkpIGZvciAodmFyIHYgPSAwOyB2IDwgZi5sZW5ndGg7IHYrKykgaWYgKFwiXCIgIT09IGZbdl0ubWF0Y2guZGVmICYmICEwICE9PSBmW3ZdLm1hdGNoLm9wdGlvbmFsaXR5ICYmICEwICE9PSBmW3ZdLm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllciAmJiAoITAgPT09IGZbdl0ubWF0Y2guc3RhdGljIHx8IHZvaWQgMCA9PT0gdSB8fCAhMSAhPT0gZlt2XS5tYXRjaC5mbi50ZXN0KHUubWF0Y2guZGVmLCBsLCBlLCAhMCwgYSkpICYmIChkLnB1c2goZlt2XSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEwID09PSBmW3ZdLm1hdGNoLnN0YXRpYyAmJiAodSA9IGZbdl0pLCBkLmxlbmd0aCA+IDEgJiYgL1swLTlhLWJBLVpdLy50ZXN0KGRbMF0ubWF0Y2guZGVmKSkpIHJldHVybiBhLnBsYWNlaG9sZGVyLmNoYXJBdChlICUgYS5wbGFjZWhvbGRlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuZGVmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiID09PSBvKGEucGxhY2Vob2xkZXIpID8gdC5kZWYgOiBhLnBsYWNlaG9sZGVyLmNoYXJBdChlICUgYS5wbGFjZWhvbGRlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFza3NldC52YWxpZFBvc2l0aW9uc1tlXSB8fCBmLmNhbGwodGhpcywgZSwgaC5jYWxsKHRoaXMsIGUsIHQgPyB0LnNsaWNlKCkgOiB0LCBuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMub3B0cywgaSA9IDAsIGEgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IDAsIGkgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuZm9yRWFjaCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUubWF0Y2gub3B0aW9uYWxpdHkgJiYgKDAgIT09IG4gJiYgbiAhPT0gZS5tYXRjaC5vcHRpb25hbGl0eSAmJiAoaSA9ICEwKSwgKDAgPT09IG4gfHwgbiA+IGUubWF0Y2gub3B0aW9uYWxpdHkpICYmIChuID0gZS5tYXRjaC5vcHRpb25hbGl0eSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBuICYmICgwID09IGUgfHwgMSA9PSB0Lmxlbmd0aCA/IG4gPSAwIDogaSB8fCAobiA9IDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgICAgICB9KGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICBlID0gZSA+IDAgPyBlIC0gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciByLCBvLCBzLCBjID0gbChwLmNhbGwodGhpcywgZSkpO1xuICAgICAgICAgICAgICAgICAgICBuLmdyZWVkeSAmJiB0Lmxlbmd0aCA+IDEgJiYgXCJcIiA9PT0gdFt0Lmxlbmd0aCAtIDFdLm1hdGNoLmRlZiAmJiAoaSA9IDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IHQubGVuZ3RoIC0gaTsgdSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHRbdV07XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gbChmLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IE1hdGguYWJzKHIgLSBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICghMCAhPT0gZi51bk1hdGNoZWRBbHRlcm5hdGlvblN0b3BwZWQgfHwgdC5maWx0ZXIoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITAgIT09IGUudW5NYXRjaGVkQWx0ZXJuYXRpb25TdG9wcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmxlbmd0aCA8PSAxKSAmJiAodm9pZCAwID09PSBvIHx8IFwiXCIgIT09IHIgJiYgZCA8IG8gfHwgcyAmJiAhbi5ncmVlZHkgJiYgcy5tYXRjaC5vcHRpb25hbGl0eSAmJiBzLm1hdGNoLm9wdGlvbmFsaXR5IC0gYSA+IDAgJiYgXCJtYXN0ZXJcIiA9PT0gcy5tYXRjaC5uZXdCbG9ja01hcmtlciAmJiAoIWYubWF0Y2gub3B0aW9uYWxpdHkgfHwgZi5tYXRjaC5vcHRpb25hbGl0eSAtIGEgPCAxIHx8ICFmLm1hdGNoLm5ld0Jsb2NrTWFya2VyKSB8fCBzICYmICFuLmdyZWVkeSAmJiBzLm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllciAmJiAhZi5tYXRjaC5vcHRpb25hbFF1YW50aWZpZXIpICYmIChvID0gZCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMubWFza3NldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4udmFsaWRQb3NpdGlvbnNbZV0gPyBuLnZhbGlkUG9zaXRpb25zW2VdIDogKHQgfHwgaC5jYWxsKHRoaXMsIGUpKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCwgbiA9IFtdLCBpID0gLTEsIGEgPSAwLCByID0gZS5sZW5ndGg7IGEgPCByOyBhKyspIGlmIChcIi1cIiA9PT0gZS5jaGFyQXQoYSkpIGZvciAodCA9IGUuY2hhckNvZGVBdChhICsgMSk7ICsraSA8IHQ7ICkgbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpOyBlbHNlIGkgPSBlLmNoYXJDb2RlQXQoYSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgbi5wdXNoKGUuY2hhckF0KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubWF0Y2guZGVmID09PSB0Lm1hdGNoLm5hdGl2ZURlZiB8fCAhKCEobi5yZWdleCB8fCBlLm1hdGNoLmZuIGluc3RhbmNlb2YgUmVnRXhwICYmIHQubWF0Y2guZm4gaW5zdGFuY2VvZiBSZWdFeHApIHx8ICEwID09PSBlLm1hdGNoLnN0YXRpYyB8fCAhMCA9PT0gdC5tYXRjaC5zdGF0aWMpICYmIChcIi5cIiA9PT0gdC5tYXRjaC5mbi5zb3VyY2UgfHwgLTEgIT09IGkodC5tYXRjaC5mbi5zb3VyY2UucmVwbGFjZSgvW1tcXF0vXS9nLCBcIlwiKSkuaW5kZXhPZihpKGUubWF0Y2guZm4uc291cmNlLnJlcGxhY2UoL1tbXFxdL10vZywgXCJcIikpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGgoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgciwgbyA9IHRoaXMsIGwgPSB0aGlzLmRlcGVuZGVuY3lMaWIsIHMgPSB0aGlzLm1hc2tzZXQsIGMgPSB0aGlzLm9wdHMsIHUgPSB0aGlzLmVsLCBwID0gcy5tYXNrVG9rZW4sIGggPSB0ID8gbiA6IDAsIHYgPSB0ID8gdC5zbGljZSgpIDogWyAwIF0sIG0gPSBbXSwgZyA9ICExLCB5ID0gdCA/IHQuam9pbihcIlwiKSA6IFwiXCIsIGsgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYih0LCBuLCByLCBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKHIsIGwsIHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB2KGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAwID09PSB0Lm1hdGNoZXMuaW5kZXhPZihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gfHwgdC5tYXRjaGVzLmV2ZXJ5KChmdW5jdGlvbihpLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITAgPT09IGkuaXNRdWFudGlmaWVyID8gbiA9IHYoZSwgdC5tYXRjaGVzW2EgLSAxXSkgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSwgXCJtYXRjaGVzXCIpICYmIChuID0gdihlLCBpKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdyhlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHMudGVzdHNbZV0gfHwgcy52YWxpZFBvc2l0aW9uc1tlXSkgJiYgKHMudmFsaWRQb3NpdGlvbnNbZV0gPyBbIHMudmFsaWRQb3NpdGlvbnNbZV0gXSA6IHMudGVzdHNbZV0pLmV2ZXJ5KChmdW5jdGlvbihlLCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5tbG9jW3RdKSByZXR1cm4gaSA9IGUsICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB2b2lkIDAgIT09IG4gPyBuIDogZS5hbHRlcm5hdGlvbiwgbCA9IHZvaWQgMCAhPT0gZS5sb2NhdG9yW29dID8gZS5sb2NhdG9yW29dLnRvU3RyaW5nKCkuaW5kZXhPZih0KSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2b2lkIDAgPT09IGEgfHwgbCA8IGEpICYmIC0xICE9PSBsICYmIChpID0gZSwgYSA9IGwpLCAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGkubG9jYXRvcltpLmFsdGVybmF0aW9uXSwgbyA9IGkubWxvY1t0XSB8fCBpLm1sb2Nbcl0gfHwgaS5sb2NhdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0xICE9PSBvW28ubGVuZ3RoIC0gMV0udG9TdHJpbmcoKS5pbmRleE9mKFwiOlwiKSkgby5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvLnNsaWNlKCh2b2lkIDAgIT09IG4gPyBuIDogaS5hbHRlcm5hdGlvbikgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBuID8gdyhlLCB0KSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gUCh0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMCA9PT0gdC5tYXRjaC5zdGF0aWMgJiYgITAgIT09IG4ubWF0Y2guc3RhdGljICYmIG4ubWF0Y2guZm4udGVzdCh0Lm1hdGNoLmRlZiwgcywgZSwgITEsIGMsICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gUyhlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5hbHRlcm5hdGlvbiwgaSA9IHZvaWQgMCA9PT0gdCB8fCBuIDw9IHQuYWx0ZXJuYXRpb24gJiYgLTEgPT09IGUubG9jYXRvcltuXS50b1N0cmluZygpLmluZGV4T2YodC5sb2NhdG9yW25dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpICYmIG4gPiB0LmFsdGVybmF0aW9uKSBmb3IgKHZhciBhID0gMDsgYSA8IG47IGErKykgaWYgKGUubG9jYXRvclthXSAhPT0gdC5sb2NhdG9yW2FdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gYSwgaSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhaSAmJiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm1sb2MgPSBlLm1sb2MgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUubG9jYXRvcltuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgaSAmJiAoaSA9IGkuc3BsaXQoXCIsXCIpWzBdKSwgdm9pZCAwID09PSBlLm1sb2NbaV0gJiYgKGUubWxvY1tpXSA9IGUubG9jYXRvci5zbGljZSgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm1sb2NbaV0ucHVzaChcIjpcIi5jb25jYXQoZS5hbHRlcm5hdGlvbikpKSwgdm9pZCAwICE9PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgaW4gdC5tbG9jKSBcInN0cmluZ1wiID09IHR5cGVvZiBhICYmIChhID0gcGFyc2VJbnQoYS5zcGxpdChcIixcIilbMF0pKSwgZS5tbG9jW2EgKyAwXSA9IHQubWxvY1thXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5sb2NhdG9yW25dID0gT2JqZWN0LmtleXMoZS5tbG9jKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuYWx0ZXJuYXRpb24gPiBuICYmIChlLmFsdGVybmF0aW9uID0gbiksICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuYWx0ZXJuYXRpb24gPSB2b2lkIDAsICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBPKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubG9jYXRvci5sZW5ndGggIT09IHQubG9jYXRvci5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IGUuYWx0ZXJuYXRpb24gKyAxOyBuIDwgZS5sb2NhdG9yLmxlbmd0aDsgbisrKSBpZiAoZS5sb2NhdG9yW25dICE9PSB0LmxvY2F0b3Jbbl0pIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaCA+IGUgKyBjLl9tYXhUZXN0UG9zKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dG1hc2s6IFRoZXJlIGlzIHByb2JhYmx5IGFuIGVycm9yIGluIHlvdXIgbWFzayBkZWZpbml0aW9uIG9yIGluIHRoZSBjb2RlLiBDcmVhdGUgYW4gaXNzdWUgb24gZ2l0aHViIHdpdGggYW4gZXhhbXBsZSBvZiB0aGUgbWFzayB5b3UgYXJlIHVzaW5nLiBcIi5jb25jYXQocy5tYXNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGggPT09IGUgJiYgdm9pZCAwID09PSByLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaDogcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0b3I6IGwucmV2ZXJzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Q6IHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbG9jOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgIXIub3B0aW9uYWxpdHkgfHwgdm9pZCAwICE9PSBwIHx8ICEoYy5kZWZpbml0aW9ucyAmJiBjLmRlZmluaXRpb25zW3IubmF0aXZlRGVmXSAmJiBjLmRlZmluaXRpb25zW3IubmF0aXZlRGVmXS5vcHRpb25hbCB8fCBhLmRlZmF1bHQucHJvdG90eXBlLmRlZmluaXRpb25zW3IubmF0aXZlRGVmXSAmJiBhLmRlZmF1bHQucHJvdG90eXBlLmRlZmluaXRpb25zW3IubmF0aXZlRGVmXS5vcHRpb25hbCkpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9ICEwLCBoID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gci5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmlzR3JvdXAgJiYgcCAhPT0gcikgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSBmKHQubWF0Y2hlc1t0Lm1hdGNoZXMuaW5kZXhPZihyKSArIDFdLCBsLCBwKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmlzT3B0aW9uYWwpIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gciwgYSA9IG0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSBiKHIsIG4sIGwsIHApLCBtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS5mb3JFYWNoKChmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPj0gYSAmJiAoZS5tYXRjaC5vcHRpb25hbGl0eSA9IGUubWF0Y2gub3B0aW9uYWxpdHkgPyBlLm1hdGNoLm9wdGlvbmFsaXR5ICsgMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgaSA9IG1bbS5sZW5ndGggLSAxXS5tYXRjaCwgdm9pZCAwICE9PSBwIHx8ICF2KGksIHQpKSByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gITAsIGggPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmlzQWx0ZXJuYXRvcikgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaShlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCwgbiA9IGUubWF0Y2hlc1swXS5tYXRjaGVzID8gZS5tYXRjaGVzWzBdLm1hdGNoZXMubGVuZ3RoIDogMSwgaSA9IDA7IGkgPCBlLm1hdGNoZXMubGVuZ3RoICYmIG4gPT09ICh0ID0gZS5tYXRjaGVzW2ldLm1hdGNoZXMgPyBlLm1hdGNoZXNbaV0ubWF0Y2hlcy5sZW5ndGggOiAxKTsgaSsrKSA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gIT09IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmhhc0FsdGVybmF0b3IgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhLCB2ID0gciwgeSA9IFtdLCBiID0gbS5zbGljZSgpLCB4ID0gbC5sZW5ndGgsIF8gPSBuLmxlbmd0aCA+IDAgPyBuLnNoaWZ0KCkgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gXyB8fCBcInN0cmluZ1wiID09IHR5cGVvZiBfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE0sIEUgPSBoLCBqID0gbi5zbGljZSgpLCBUID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIF8pIFQgPSBfLnNwbGl0KFwiLFwiKTsgZWxzZSBmb3IgKE0gPSAwOyBNIDwgdi5tYXRjaGVzLmxlbmd0aDsgTSsrKSBULnB1c2goTS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBzLmV4Y2x1ZGVzW2VdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIEEgPSBULnNsaWNlKCksIEQgPSAwLCBMID0gcy5leGNsdWRlc1tlXS5sZW5ndGg7IEQgPCBMOyBEKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDID0gcy5leGNsdWRlc1tlXVtEXS50b1N0cmluZygpLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwubGVuZ3RoID09IENbMV0gJiYgVC5zcGxpY2UoVC5pbmRleE9mKENbMF0pLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwID09PSBULmxlbmd0aCAmJiAoZGVsZXRlIHMuZXhjbHVkZXNbZV0sIFQgPSBBKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCEwID09PSBjLmtlZXBTdGF0aWMgfHwgaXNGaW5pdGUocGFyc2VJbnQoYy5rZWVwU3RhdGljKSkgJiYgRSA+PSBjLmtlZXBTdGF0aWMpICYmIChUID0gVC5zbGljZSgwLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgQiA9IDA7IEIgPCBULmxlbmd0aDsgQisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0gPSBwYXJzZUludChUW0JdKSwgbSA9IFtdLCBuID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgXyAmJiB3KGgsIE0sIHgpIHx8IGouc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEkgPSB2Lm1hdGNoZXNbTV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChJICYmIGYoSSwgWyBNIF0uY29uY2F0KGwpLCBwKSkgciA9ICEwOyBlbHNlIGlmICgwID09PSBCICYmIChrID0gaSh2KSksIEkgJiYgSS5tYXRjaGVzICYmIEkubWF0Y2hlcy5sZW5ndGggPiB2Lm1hdGNoZXNbMF0ubWF0Y2hlcy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gbS5zbGljZSgpLCBoID0gRSwgbSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBSID0gMDsgUiA8IGEubGVuZ3RoOyBSKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBGID0gYVtSXSwgTiA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRi5hbHRlcm5hdGlvbiA9IEYuYWx0ZXJuYXRpb24gfHwgeCwgUyhGKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIFYgPSAwOyBWIDwgeS5sZW5ndGg7IFYrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBHID0geVtWXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgXyB8fCB2b2lkIDAgIT09IEYuYWx0ZXJuYXRpb24gJiYgVC5pbmNsdWRlcyhGLmxvY2F0b3JbRi5hbHRlcm5hdGlvbl0udG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEYubWF0Y2gubmF0aXZlRGVmID09PSBHLm1hdGNoLm5hdGl2ZURlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTiA9ICEwLCBTKEcsIEYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQoRiwgRywgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFMoRiwgRykgJiYgKE4gPSAhMCwgeS5zcGxpY2UoeS5pbmRleE9mKEcpLCAwLCBGKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZChHLCBGLCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUyhHLCBGKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChQKEYsIEcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKEYsIEcpIHx8IHZvaWQgMCAhPT0gdS5pbnB1dG1hc2sudXNlck9wdGlvbnMua2VlcFN0YXRpYyA/IFMoRiwgRykgJiYgKE4gPSAhMCwgeS5zcGxpY2UoeS5pbmRleE9mKEcpLCAwLCBGKSkgOiBjLmtlZXBTdGF0aWMgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChQKEcsIEYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTKEcsIEYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOIHx8IHkucHVzaChGKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gYi5jb25jYXQoeSksIGggPSBlLCBnID0gbS5sZW5ndGggPiAwICYmIGssIHIgPSB5Lmxlbmd0aCA+IDAgJiYgIWssIGsgJiYgZyAmJiAhciAmJiBtLmZvckVhY2goKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS51bk1hdGNoZWRBbHRlcm5hdGlvblN0b3BwZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksIG4gPSBqLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgciA9IGYodi5tYXRjaGVzW19dIHx8IHQubWF0Y2hlc1tfXSwgWyBfIF0uY29uY2F0KGwpLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuaXNRdWFudGlmaWVyICYmIHAgIT09IHQubWF0Y2hlc1t0Lm1hdGNoZXMuaW5kZXhPZihyKSAtIDFdKSByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gciwgbyA9ICExLCB1ID0gbi5sZW5ndGggPiAwID8gbi5zaGlmdCgpIDogMDsgdSA8IChpc05hTihhLnF1YW50aWZpZXIubWF4KSA/IHUgKyAxIDogYS5xdWFudGlmaWVyLm1heCkgJiYgaCA8PSBlOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHQubWF0Y2hlc1t0Lm1hdGNoZXMuaW5kZXhPZihhKSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID0gZihwLCBbIHUgXS5jb25jYXQobCksIHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLmZvckVhY2goKGZ1bmN0aW9uKHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpID0geChwLCB0Lm1hdGNoKSA/IHQubWF0Y2ggOiBtW20ubGVuZ3RoIC0gMV0ubWF0Y2gpLm9wdGlvbmFsUXVhbnRpZmllciA9IHUgPj0gYS5xdWFudGlmaWVyLm1pbiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLmppdCA9ICh1ICsgMSkgKiAocC5tYXRjaGVzLmluZGV4T2YoaSkgKyAxKSA+IGEucXVhbnRpZmllci5qaXQsIGkub3B0aW9uYWxRdWFudGlmaWVyICYmIHYoaSwgcCkgJiYgKGcgPSAhMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gZSwgYy5ncmVlZHkgJiYgbnVsbCA9PSBzLnZhbGlkUG9zaXRpb25zW2UgLSAxXSAmJiB1ID4gYS5xdWFudGlmaWVyLm1pbiAmJiAtMSAhPSBbIFwiKlwiLCBcIitcIiBdLmluZGV4T2YoYS5xdWFudGlmaWVyLm1heCkgJiYgKG0ucG9wKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHZvaWQgMCksIG8gPSAhMCwgciA9ICExKSwgIW8gJiYgaS5qaXQgJiYgKHMuaml0T2Zmc2V0W2VdID0gcC5tYXRjaGVzLmxlbmd0aCAtIHAubWF0Y2hlcy5pbmRleE9mKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBvKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IGIociwgbiwgbCwgcCkpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IG4ubGVuZ3RoID4gMCA/IG4uc2hpZnQoKSA6IDA7IHAgPCB0Lm1hdGNoZXMubGVuZ3RoOyBwKyspIGlmICghMCAhPT0gdC5tYXRjaGVzW3BdLmlzUXVhbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZih0Lm1hdGNoZXNbcF0sIFsgcCBdLmNvbmNhdChyKSwgbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgJiYgaCA9PT0gZSkgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGggPiBlKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB4KGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gLTEgIT0gZS5tYXRjaGVzLmluZGV4T2YodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiB8fCBlLm1hdGNoZXMuZm9yRWFjaCgoZnVuY3Rpb24oZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZS5tYXRjaGVzIHx8IG4gfHwgKG4gPSB4KGUsIHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdywgUCA9IGUgLSAxOyB2b2lkIDAgPT09ICh3ID0gcy52YWxpZFBvc2l0aW9uc1tQXSB8fCBzLnRlc3RzW1BdKSAmJiBQID4gLTE7ICkgUC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdyAmJiBQID4gLTEgJiYgKHYgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuLCBpID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpIHx8ICh0ID0gWyB0IF0pLCB0Lmxlbmd0aCA+IDAgJiYgKHZvaWQgMCA9PT0gdFswXS5hbHRlcm5hdGlvbiB8fCAhMCA9PT0gYy5rZWVwU3RhdGljID8gMCA9PT0gKGkgPSBmLmNhbGwobywgZSwgdC5zbGljZSgpKS5sb2NhdG9yLnNsaWNlKCkpLmxlbmd0aCAmJiAoaSA9IHRbMF0ubG9jYXRvci5zbGljZSgpKSA6IHQuZm9yRWFjaCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiAhPT0gZS5kZWYgJiYgKDAgPT09IGkubGVuZ3RoID8gKG4gPSBlLmFsdGVybmF0aW9uLCBpID0gZS5sb2NhdG9yLnNsaWNlKCkpIDogZS5sb2NhdG9yW25dICYmIC0xID09PSBpW25dLnRvU3RyaW5nKCkuaW5kZXhPZihlLmxvY2F0b3Jbbl0pICYmIChpW25dICs9IFwiLFwiICsgZS5sb2NhdG9yW25dKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSksIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShQLCB3KSwgeSA9IHYuam9pbihcIlwiKSwgaCA9IFApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMudGVzdHNbZV0gJiYgcy50ZXN0c1tlXVswXS5jZCA9PT0geSkgcmV0dXJuIHMudGVzdHNbZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBTID0gdi5zaGlmdCgpOyBTIDwgcC5sZW5ndGg7IFMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKHBbU10sIHYsIFsgUyBdKSAmJiBoID09PSBlIHx8IGggPiBlKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAgPT09IG0ubGVuZ3RoIHx8IGcpICYmIG0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpYzogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxpdHk6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2luZzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWY6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdG9yOiBrICYmIDAgPT09IG0uZmlsdGVyKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwICE9PSBlLnVuTWF0Y2hlZEFsdGVybmF0aW9uU3RvcHBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5sZW5ndGggPyBbIDAgXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxvYzoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjZDogeVxuICAgICAgICAgICAgICAgICAgICB9KSwgdm9pZCAwICE9PSB0ICYmIHMudGVzdHNbZV0gPyByID0gbC5leHRlbmQoITAsIFtdLCBtKSA6IChzLnRlc3RzW2VdID0gbC5leHRlbmQoITAsIFtdLCBtKSwgXG4gICAgICAgICAgICAgICAgICAgIHIgPSBzLnRlc3RzW2VdKSwgbS5mb3JFYWNoKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1hdGNoLm9wdGlvbmFsaXR5ID0gZS5tYXRjaC5kZWZPcHRpb25hbGl0eSB8fCAhMTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLCByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA3MjE1OiBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmFsdGVybmF0ZSA9IGwsIHQuY2hlY2tBbHRlcm5hdGlvbk1hdGNoID0gZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpLCBhID0gdGhpcy5vcHRzLmdyZWVkeSA/IHQgOiB0LnNsaWNlKDAsIDEpLCByID0gITEsIG8gPSB2b2lkIDAgIT09IG4gPyBuLnNwbGl0KFwiLFwiKSA6IFtdLCBsID0gMDsgbCA8IG8ubGVuZ3RoOyBsKyspIC0xICE9PSAoaSA9IGUuaW5kZXhPZihvW2xdKSkgJiYgZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgZS5sZW5ndGg7IHMrKykgaWYgKGEuaW5jbHVkZXMoZVtzXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH0sIHQuaGFuZGxlUmVtb3ZlID0gZnVuY3Rpb24oZSwgdCwgbiwgaSwgcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMsIHUgPSB0aGlzLm1hc2tzZXQsIGYgPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZi5udW1lcmljSW5wdXQgfHwgYy5pc1JUTCkgJiYgKHQgPT09IGEua2V5cy5CYWNrc3BhY2UgPyB0ID0gYS5rZXlzLkRlbGV0ZSA6IHQgPT09IGEua2V5cy5EZWxldGUgJiYgKHQgPSBhLmtleXMuQmFja3NwYWNlKSwgXG4gICAgICAgICAgICAgICAgICAgIGMuaXNSVEwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG4uZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5lbmQgPSBuLmJlZ2luLCBuLmJlZ2luID0gcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZCwgaCA9IHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChjLCB2b2lkIDAsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgbi5lbmQgPj0gci5nZXRCdWZmZXIuY2FsbChjKS5sZW5ndGggJiYgaCA+PSBuLmVuZCAmJiAobi5lbmQgPSBoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHQgPT09IGEua2V5cy5CYWNrc3BhY2UgPyBuLmVuZCAtIG4uYmVnaW4gPCAxICYmIChuLmJlZ2luID0gci5zZWVrUHJldmlvdXMuY2FsbChjLCBuLmJlZ2luKSkgOiB0ID09PSBhLmtleXMuRGVsZXRlICYmIG4uYmVnaW4gPT09IG4uZW5kICYmIChuLmVuZCA9IHIuaXNNYXNrLmNhbGwoYywgbi5lbmQsICEwLCAhMCkgPyBuLmVuZCArIDEgOiByLnNlZWtOZXh0LmNhbGwoYywgbi5lbmQpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICExICE9PSAoZCA9IHYuY2FsbChjLCBuKSkgJiYgKCghMCAhPT0gaSAmJiAhMSAhPT0gZi5rZWVwU3RhdGljIHx8IG51bGwgIT09IGYucmVnZXggJiYgLTEgIT09IG8uZ2V0VGVzdC5jYWxsKGMsIG4uYmVnaW4pLm1hdGNoLmRlZi5pbmRleE9mKFwifFwiKSkgJiYgbC5jYWxsKGMsICEwKSwgXG4gICAgICAgICAgICAgICAgICAgICEwICE9PSBpICYmICh1LnAgPSB0ID09PSBhLmtleXMuRGVsZXRlID8gbi5iZWdpbiArIGQgOiBuLmJlZ2luLCB1LnAgPSByLmRldGVybWluZU5ld0NhcmV0UG9zaXRpb24uY2FsbChjLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogdS5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB1LnBcbiAgICAgICAgICAgICAgICAgICAgfSwgITEsICExID09PSBmLmluc2VydE1vZGUgJiYgdCA9PT0gYS5rZXlzLkJhY2tzcGFjZSA/IFwibm9uZVwiIDogdm9pZCAwKS5iZWdpbikpO1xuICAgICAgICAgICAgICAgIH0sIHQuaXNDb21wbGV0ZSA9IGMsIHQuaXNTZWxlY3Rpb24gPSB1LCB0LmlzVmFsaWQgPSBmLCB0LnJlZnJlc2hGcm9tQnVmZmVyID0gZCwgXG4gICAgICAgICAgICAgICAgdC5yZXZhbGlkYXRlTWFzayA9IHY7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBuKDYwMzApLCBhID0gbigyODM5KSwgciA9IG4oODcxMSksIG8gPSBuKDQ3MTMpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSwgdCwgbiwgaSwgYSwgcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMsIHUgPSB0aGlzLmRlcGVuZGVuY3lMaWIsIHAgPSB0aGlzLm9wdHMsIGQgPSBjLm1hc2tzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYy5oYXNBbHRlcm5hdG9yKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoLCB2LCBtLCBnLCB5LCBrLCBiLCB4LCB3LCBQLCBTLCBPID0gdS5leHRlbmQoITAsIFtdLCBkLnZhbGlkUG9zaXRpb25zKSwgXyA9IHUuZXh0ZW5kKCEwLCB7fSwgZC50ZXN0cyksIE0gPSAhMSwgRSA9ICExLCBqID0gdm9pZCAwICE9PSBhID8gYSA6IHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgJiYgKFAgPSBzLmJlZ2luLCBTID0gcy5lbmQsIHMuYmVnaW4gPiBzLmVuZCAmJiAoUCA9IHMuZW5kLCBTID0gcy5iZWdpbikpLCBcbiAgICAgICAgICAgICAgICAgICAgLTEgPT09IGogJiYgdm9pZCAwID09PSBhKSBoID0gMCwgdiA9IChnID0gby5nZXRUZXN0LmNhbGwoYywgaCkpLmFsdGVybmF0aW9uOyBlbHNlIGZvciAoO2ogPj0gMDsgai0tKSBpZiAoKG0gPSBkLnZhbGlkUG9zaXRpb25zW2pdKSAmJiB2b2lkIDAgIT09IG0uYWx0ZXJuYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqIDw9IChlIHx8IDApICYmIGcgJiYgZy5sb2NhdG9yW20uYWx0ZXJuYXRpb25dICE9PSBtLmxvY2F0b3JbbS5hbHRlcm5hdGlvbl0pIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGosIHYgPSBkLnZhbGlkUG9zaXRpb25zW2hdLmFsdGVybmF0aW9uLCBnID0gbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gcGFyc2VJbnQoaCksIGQuZXhjbHVkZXNbYl0gPSBkLmV4Y2x1ZGVzW2JdIHx8IFtdLCAhMCAhPT0gZSAmJiBkLmV4Y2x1ZGVzW2JdLnB1c2goKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgby5nZXREZWNpc2lvblRha2VyKShnKSArIFwiOlwiICsgZy5hbHRlcm5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgVCA9IFtdLCBBID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHkgPSBiOyBiIDwgci5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGMsIHZvaWQgMCwgITApICsgMTsgeSsrKSAtMSA9PT0gQSAmJiBlIDw9IHkgJiYgdm9pZCAwICE9PSB0ICYmIChULnB1c2godCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgQSA9IFQubGVuZ3RoIC0gMSksIChrID0gZC52YWxpZFBvc2l0aW9uc1tiXSkgJiYgITAgIT09IGsuZ2VuZXJhdGVkSW5wdXQgJiYgKHZvaWQgMCA9PT0gcyB8fCB5IDwgUCB8fCB5ID49IFMpICYmIFQucHVzaChrLmlucHV0KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBkLnZhbGlkUG9zaXRpb25zLnNwbGljZShiLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoLTEgPT09IEEgJiYgdm9pZCAwICE9PSB0ICYmIChULnB1c2godCksIEEgPSBULmxlbmd0aCAtIDEpOyB2b2lkIDAgIT09IGQuZXhjbHVkZXNbYl0gJiYgZC5leGNsdWRlc1tiXS5sZW5ndGggPCAxMDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChkLnRlc3RzID0ge30sIHIucmVzZXRNYXNrU2V0LmNhbGwoYywgITApLCBNID0gITAsIHkgPSAwOyB5IDwgVC5sZW5ndGggJiYgKHggPSBNLmNhcmV0IHx8IDAgPT0gcC5pbnNlcnRNb2RlICYmIG51bGwgIT0geCA/IHIuc2Vla05leHQuY2FsbChjLCB4KSA6IHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChjLCB2b2lkIDAsICEwKSArIDEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBUW3ldLCBNID0gZi5jYWxsKGMsIHgsIHcsICExLCBpLCAhMCkpOyB5KyspIHkgPT09IEEgJiYgKEUgPSBNKSwgMSA9PSBlICYmIE0gJiYgKEUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zOiB5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE0pIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLnJlc2V0TWFza1NldC5jYWxsKGMpLCBnID0gby5nZXRUZXN0LmNhbGwoYywgYiksIGQudmFsaWRQb3NpdGlvbnMgPSB1LmV4dGVuZCghMCwgW10sIE8pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnRlc3RzID0gdS5leHRlbmQoITAsIHt9LCBfKSwgIWQuZXhjbHVkZXNbYl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRSA9IGwuY2FsbChjLCBlLCB0LCBuLCBpLCBiIC0gMSwgcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBnLmFsdGVybmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBEID0gKDAsIG8uZ2V0RGVjaXNpb25UYWtlcikoZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gZC5leGNsdWRlc1tiXS5pbmRleE9mKEQgKyBcIjpcIiArIGcuYWx0ZXJuYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFID0gbC5jYWxsKGMsIGUsIHQsIG4sIGksIGIgLSAxLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoZC5leGNsdWRlc1tiXS5wdXNoKEQgKyBcIjpcIiArIGcuYWx0ZXJuYXRpb24pLCB5ID0gYjsgeSA8IHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChjLCB2b2lkIDAsICEwKSArIDE7IHkrKykgZC52YWxpZFBvc2l0aW9ucy5zcGxpY2UoYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGRlbGV0ZSBkLmV4Y2x1ZGVzW2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFICYmICExID09PSBwLmtlZXBTdGF0aWMgfHwgZGVsZXRlIGQuZXhjbHVkZXNbYl0sIEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMub3B0cywgciA9IHRoaXMubWFza3NldDtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpLmNhc2luZyB8fCB0LmNhc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1cHBlclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxvd2VyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gci52YWxpZFBvc2l0aW9uc1tuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gMCA9PT0gbiB8fCBvICYmIG8uaW5wdXQgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoYS5rZXlDb2RlLlNwYWNlKSA/IGUudG9VcHBlckNhc2UoKSA6IGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGkuY2FzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwucHVzaChyLnZhbGlkUG9zaXRpb25zKSwgZSA9IGkuY2FzaW5nLmFwcGx5KHRoaXMsIGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLCBuID0gdGhpcy5vcHRzLCBpID0gdGhpcy5tYXNrc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBuLmlzQ29tcGxldGUpIHJldHVybiBuLmlzQ29tcGxldGUoZSwgbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIipcIiAhPT0gbi5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gITEsIGwgPSByLmRldGVybWluZUxhc3RSZXF1aXJlZFBvc2l0aW9uLmNhbGwodCwgITApLCBzID0gbC5sO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gbC5kZWYgfHwgbC5kZWYubmV3QmxvY2tNYXJrZXIgfHwgbC5kZWYub3B0aW9uYWxpdHkgfHwgbC5kZWYub3B0aW9uYWxRdWFudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDw9IHM7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IG8uZ2V0VGVzdFRlbXBsYXRlLmNhbGwodCwgYykubWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMCAhPT0gdS5zdGF0aWMgJiYgdm9pZCAwID09PSBpLnZhbGlkUG9zaXRpb25zW2NdICYmICghMSA9PT0gdS5vcHRpb25hbGl0eSB8fCB2b2lkIDAgPT09IHUub3B0aW9uYWxpdHkgfHwgdS5vcHRpb25hbGl0eSAmJiAwID09IHUubmV3QmxvY2tNYXJrZXIpICYmICghMSA9PT0gdS5vcHRpb25hbFF1YW50aWZpZXIgfHwgdm9pZCAwID09PSB1Lm9wdGlvbmFsUXVhbnRpZmllcikgfHwgITAgPT09IHUuc3RhdGljICYmIFwiXCIgIT0gdS5kZWYgJiYgZVtjXSAhPT0gby5nZXRQbGFjZWhvbGRlci5jYWxsKHQsIGMsIHUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMub3B0cy5pbnNlcnRNb2RlID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUlRMID8gZS5iZWdpbiAtIGUuZW5kID4gdCA6IGUuZW5kIC0gZS5iZWdpbiA+IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYoZSwgdCwgbiwgaSwgYSwgcCwgbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHRoaXMsIHkgPSB0aGlzLmRlcGVuZGVuY3lMaWIsIGsgPSB0aGlzLm9wdHMsIGIgPSBnLm1hc2tzZXQ7XG4gICAgICAgICAgICAgICAgICAgIG4gPSAhMCA9PT0gbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBlLnJlbW92ZSAmJiAoQXJyYXkuaXNBcnJheShlLnJlbW92ZSkgfHwgKGUucmVtb3ZlID0gWyBlLnJlbW92ZSBdKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmUuc29ydCgoZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZy5pc1JUTCA/IGUucG9zIC0gdC5wb3MgOiB0LnBvcyAtIGUucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5mb3JFYWNoKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuY2FsbChnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZSArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBlLnJlbW92ZSA9IHZvaWQgMCksIHZvaWQgMCAhPT0gZS5pbnNlcnQgJiYgKEFycmF5LmlzQXJyYXkoZS5pbnNlcnQpIHx8IChlLmluc2VydCA9IFsgZS5pbnNlcnQgXSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5zZXJ0LnNvcnQoKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGcuaXNSVEwgPyB0LnBvcyAtIGUucG9zIDogZS5wb3MgLSB0LnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuZm9yRWFjaCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiICE9PSBlLmMgJiYgZi5jYWxsKGcsIGUucG9zLCBlLmMsIHZvaWQgMCA9PT0gZS5zdHJpY3QgfHwgZS5zdHJpY3QsIHZvaWQgMCAhPT0gZS5mcm9tSXNWYWxpZCA/IGUuZnJvbUlzVmFsaWQgOiBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksIGUuaW5zZXJ0ID0gdm9pZCAwKSwgZS5yZWZyZXNoRnJvbUJ1ZmZlciAmJiBlLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUucmVmcmVzaEZyb21CdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuY2FsbChnLCAhMCA9PT0gdCA/IHQgOiB0LnN0YXJ0LCB0LmVuZCwgZS5idWZmZXIpLCBlLnJlZnJlc2hGcm9tQnVmZmVyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGUucmV3cml0ZVBvc2l0aW9uICYmICh4ID0gZS5yZXdyaXRlUG9zaXRpb24sIGUgPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBQKHQsIG4sIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gby5nZXRUZXN0cy5jYWxsKGcsIHQpLmV2ZXJ5KChmdW5jdGlvbihjLCBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBjLm1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmdldEJ1ZmZlci5jYWxsKGcsICEwKSwgITEgIT09IChsID0gKCFwLmppdCB8fCB2b2lkIDAgIT09IGIudmFsaWRQb3NpdGlvbnNbci5zZWVrUHJldmlvdXMuY2FsbChnLCB0KV0pICYmIChudWxsICE9IHAuZm4gPyBwLmZuLnRlc3QobiwgYiwgdCwgYSwgaywgdS5jYWxsKGcsIGUpKSA6IChuID09PSBwLmRlZiB8fCBuID09PSBrLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIpICYmIFwiXCIgIT09IHAuZGVmICYmIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzogby5nZXRQbGFjZWhvbGRlci5jYWxsKGcsIHQsIHAsICEwKSB8fCBwLmRlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gdm9pZCAwICE9PSBsLmMgPyBsLmMgOiBuLCBoID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQgPSBkID09PSBrLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIgJiYgITAgPT09IHAuc3RhdGljID8gby5nZXRQbGFjZWhvbGRlci5jYWxsKGcsIHQsIHAsICEwKSB8fCBwLmRlZiA6IGQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhMCAhPT0gKGwgPSB3KGwpKSAmJiB2b2lkIDAgIT09IGwucG9zICYmIGwucG9zICE9PSB0ICYmIChoID0gbC5wb3MpLCAhMCAhPT0gbCAmJiB2b2lkIDAgPT09IGwucG9zICYmIHZvaWQgMCA9PT0gbC5jID8gITEgOiAoITEgPT09IHYuY2FsbChnLCBlLCB5LmV4dGVuZCh7fSwgYywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHMuY2FsbChnLCBkLCBwLCBoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgaSwgaCkgJiYgKGwgPSAhMSksICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gZS5iZWdpbiAmJiAoeCA9IGcuaXNSVEwgPyBlLmVuZCA6IGUuYmVnaW4pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgUyA9ICEwLCBPID0geS5leHRlbmQoITAsIFtdLCBiLnZhbGlkUG9zaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCExID09PSBrLmtlZXBTdGF0aWMgJiYgdm9pZCAwICE9PSBiLmV4Y2x1ZGVzW3hdICYmICEwICE9PSBhICYmICEwICE9PSBpKSBmb3IgKHZhciBfID0geDsgXyA8IChnLmlzUlRMID8gZS5iZWdpbiA6IGUuZW5kKTsgXysrKSB2b2lkIDAgIT09IGIuZXhjbHVkZXNbX10gJiYgKGIuZXhjbHVkZXNbX10gPSB2b2lkIDAsIFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYi50ZXN0c1tfXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGsucHJlVmFsaWRhdGlvbiAmJiAhMCAhPT0gaSAmJiAhMCAhPT0gcCAmJiAoUyA9IHcoUyA9IGsucHJlVmFsaWRhdGlvbi5jYWxsKGcsIHIuZ2V0QnVmZmVyLmNhbGwoZyksIHgsIHQsIHUuY2FsbChnLCBlKSwgaywgYiwgZSwgbiB8fCBhKSkpLCBcbiAgICAgICAgICAgICAgICAgICAgITAgPT09IFMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTID0gUCh4LCB0LCBuKSwgKCFuIHx8ICEwID09PSBpKSAmJiAhMSA9PT0gUyAmJiAhMCAhPT0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBNID0gYi52YWxpZFBvc2l0aW9uc1t4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU0gfHwgITAgIT09IE0ubWF0Y2guc3RhdGljIHx8IE0ubWF0Y2guZGVmICE9PSB0ICYmIHQgIT09IGsuc2tpcE9wdGlvbmFsUGFydENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoay5pbnNlcnRNb2RlIHx8IHZvaWQgMCA9PT0gYi52YWxpZFBvc2l0aW9uc1tyLnNlZWtOZXh0LmNhbGwoZywgeCldIHx8IGUuZW5kID4geCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEUgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiLmppdE9mZnNldFt4XSAmJiB2b2lkIDAgPT09IGIudmFsaWRQb3NpdGlvbnNbci5zZWVrTmV4dC5jYWxsKGcsIHgpXSAmJiAhMSAhPT0gKFMgPSBmLmNhbGwoZywgeCArIGIuaml0T2Zmc2V0W3hdLCB0LCAhMCwgITApKSAmJiAoITAgIT09IGEgJiYgKFMuY2FyZXQgPSB4KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFID0gITApLCBlLmVuZCA+IHggJiYgKGIudmFsaWRQb3NpdGlvbnNbeF0gPSB2b2lkIDApLCAhRSAmJiAhci5pc01hc2suY2FsbChnLCB4LCBrLmtlZXBTdGF0aWMgJiYgMCA9PT0geCkpIGZvciAodmFyIGogPSB4ICsgMSwgVCA9IHIuc2Vla05leHQuY2FsbChnLCB4LCAhMSwgMCAhPT0geCk7IGogPD0gVDsgaisrKSBpZiAoITEgIT09IChTID0gUChqLCB0LCBuKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTID0gaC5jYWxsKGcsIHgsIHZvaWQgMCAhPT0gUy5wb3MgPyBTLnBvcyA6IGopIHx8IFMsIHggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIFMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiByLnNlZWtOZXh0LmNhbGwoZywgeClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZy5oYXNBbHRlcm5hdG9yICYmICEwICE9PSBhICYmICFuICYmIChhID0gITAsICExID09PSBTICYmIGsua2VlcFN0YXRpYyAmJiAoYy5jYWxsKGcsIHIuZ2V0QnVmZmVyLmNhbGwoZykpIHx8IDAgPT09IHgpID8gUyA9IGwuY2FsbChnLCB4LCB0LCBuLCBpLCB2b2lkIDAsIGUpIDogKHUuY2FsbChnLCBlKSAmJiBiLnRlc3RzW3hdICYmIGIudGVzdHNbeF0ubGVuZ3RoID4gMSAmJiBrLmtlZXBTdGF0aWMgfHwgMSA9PSBTICYmICEwICE9PSBrLm51bWVyaWNJbnB1dCAmJiBiLnRlc3RzW3hdICYmIGIudGVzdHNbeF0ubGVuZ3RoID4gMSAmJiByLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoZywgdm9pZCAwLCAhMCkgPiB4KSAmJiAoUyA9IGwuY2FsbChnLCAhMCkpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAhMCA9PT0gUyAmJiAoUyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGsucG9zdFZhbGlkYXRpb24gJiYgITAgIT09IGkgJiYgITAgIT09IHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBBID0gay5wb3N0VmFsaWRhdGlvbi5jYWxsKGcsIHIuZ2V0QnVmZmVyLmNhbGwoZywgITApLCB2b2lkIDAgIT09IGUuYmVnaW4gPyBnLmlzUlRMID8gZS5lbmQgOiBlLmJlZ2luIDogZSwgdCwgUywgaywgYiwgbiwgbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IEEgJiYgKFMgPSAhMCA9PT0gQSA/IFMgOiBBKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBTICYmIHZvaWQgMCA9PT0gUy5wb3MgJiYgKFMucG9zID0geCksICExID09PSBTIHx8ICEwID09PSBwID8gKHIucmVzZXRNYXNrU2V0LmNhbGwoZywgITApLCBcbiAgICAgICAgICAgICAgICAgICAgYi52YWxpZFBvc2l0aW9ucyA9IHkuZXh0ZW5kKCEwLCBbXSwgTykpIDogaC5jYWxsKGcsIHZvaWQgMCwgeCwgITApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgRCA9IHcoUyk7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gZy5tYXhMZW5ndGggJiYgKHIuZ2V0QnVmZmVyLmNhbGwoZykubGVuZ3RoID4gZy5tYXhMZW5ndGggJiYgIWkgJiYgKHIucmVzZXRNYXNrU2V0LmNhbGwoZywgITApLCBcbiAgICAgICAgICAgICAgICAgICAgYi52YWxpZFBvc2l0aW9ucyA9IHkuZXh0ZW5kKCEwLCBbXSwgTyksIEQgPSAhMSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLm1hc2tzZXQsIGEgPSAhMSwgciA9IG8uZ2V0VGVzdHMuY2FsbCh0aGlzLCBlKSwgbCA9IDA7IGwgPCByLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocltsXS5tYXRjaCAmJiAocltsXS5tYXRjaC5uYXRpdmVEZWYgPT09IHQubWF0Y2hbbi5zaGlmdFBvc2l0aW9ucyA/IFwiZGVmXCIgOiBcIm5hdGl2ZURlZlwiXSAmJiAoIW4uc2hpZnRQb3NpdGlvbnMgfHwgIXQubWF0Y2guc3RhdGljKSB8fCByW2xdLm1hdGNoLm5hdGl2ZURlZiA9PT0gdC5tYXRjaC5uYXRpdmVEZWYgfHwgbi5yZWdleCAmJiAhcltsXS5tYXRjaC5zdGF0aWMgJiYgcltsXS5tYXRjaC5mbi50ZXN0KHQuaW5wdXQsIGksIGUsICExLCBuKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocltsXS5tYXRjaCAmJiByW2xdLm1hdGNoLmRlZiA9PT0gdC5tYXRjaC5uYXRpdmVEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMSA9PT0gYSAmJiB2b2lkIDAgIT09IGkuaml0T2Zmc2V0W2VdICYmIChhID0gcC5jYWxsKHRoaXMsIGUgKyBpLmppdE9mZnNldFtlXSwgdCwgbikpLCBcbiAgICAgICAgICAgICAgICAgICAgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhLCBvLCBsID0gdGhpcywgcyA9IHRoaXMubWFza3NldCwgYyA9IHRoaXMub3B0cywgdSA9IHRoaXMuZGVwZW5kZW5jeUxpYiwgZiA9IGMuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciwgcCA9IGwuaXNSVEwgPyBuLnNsaWNlKCkucmV2ZXJzZSgpIDogbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciA9IFwiXCIsICEwID09PSBlKSByLnJlc2V0TWFza1NldC5jYWxsKGwsICExKSwgZSA9IDAsIFxuICAgICAgICAgICAgICAgICAgICB0ID0gbi5sZW5ndGgsIG8gPSByLmRldGVybWluZU5ld0NhcmV0UG9zaXRpb24uY2FsbChsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogMFxuICAgICAgICAgICAgICAgICAgICB9LCAhMSkuYmVnaW47IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChhID0gZTsgYSA8IHQ7IGErKykgcy52YWxpZFBvc2l0aW9ucy5zcGxpY2UoZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IG5ldyB1LkV2ZW50KFwia2V5cHJlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoYSA9IGU7IGEgPCB0OyBhKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQua2V5ID0gcFthXS50b1N0cmluZygpLCBsLmlnbm9yYWJsZSA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBpLkV2ZW50SGFuZGxlcnMua2V5cHJlc3NFdmVudC5jYWxsKGwsIGQsICEwLCAhMSwgITEsIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgITEgIT09IGggJiYgdm9pZCAwICE9PSBoICYmIChvID0gaC5mb3J3YXJkUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGMuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciA9IGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGgoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMsIGEgPSB0aGlzLm1hc2tzZXQsIGwgPSB0aGlzLmRlcGVuZGVuY3lMaWI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUpIGZvciAoZSA9IHQgLSAxOyBlID4gMCAmJiAhYS52YWxpZFBvc2l0aW9uc1tlXTsgZS0tKSA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSBlOyBzIDwgdDsgcysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBhLnZhbGlkUG9zaXRpb25zW3NdICYmICFyLmlzTWFzay5jYWxsKGksIHMsICExKSkgaWYgKDAgPT0gcyA/IG8uZ2V0VGVzdC5jYWxsKGksIHMpIDogYS52YWxpZFBvc2l0aW9uc1tzIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG8uZ2V0VGVzdHMuY2FsbChpLCBzKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgPT09IGNbYy5sZW5ndGggLSAxXS5tYXRjaC5kZWYgJiYgYy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSwgcCA9IG8uZGV0ZXJtaW5lVGVzdFRlbXBsYXRlLmNhbGwoaSwgcywgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgJiYgKCEwICE9PSBwLm1hdGNoLmppdCB8fCBcIm1hc3RlclwiID09PSBwLm1hdGNoLm5ld0Jsb2NrTWFya2VyICYmICh1ID0gYS52YWxpZFBvc2l0aW9uc1tzICsgMV0pICYmICEwID09PSB1Lm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllcikgJiYgKChwID0gbC5leHRlbmQoe30sIHAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG8uZ2V0UGxhY2Vob2xkZXIuY2FsbChpLCBzLCBwLm1hdGNoLCAhMCkgfHwgcC5tYXRjaC5kZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuZ2VuZXJhdGVkSW5wdXQgPSAhMCwgdi5jYWxsKGksIHMsIHAsICEwKSwgITAgIT09IG4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gYS52YWxpZFBvc2l0aW9uc1t0XS5pbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEudmFsaWRQb3NpdGlvbnNbdF0gPSB2b2lkIDAsIGYuY2FsbChpLCB0LCBkLCAhMCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB2KGUsIHQsIG4sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLCBsID0gdGhpcy5tYXNrc2V0LCBzID0gdGhpcy5vcHRzLCBjID0gdGhpcy5kZXBlbmRlbmN5TGliO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdFtlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGkgJiYgITAgPT09IGkubWF0Y2guc3RhdGljICYmICEwICE9PSBpLm1hdGNoLm9wdGlvbmFsaXR5ICYmICh2b2lkIDAgPT09IHRbMF0gfHwgdm9pZCAwID09PSB0WzBdLmFsdGVybmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gbi5iZWdpbiA8PSBlIC0gMSA/IHRbZSAtIDFdICYmICEwID09PSB0W2UgLSAxXS5tYXRjaC5zdGF0aWMgJiYgdFtlIC0gMV0gOiB0W2UgLSAxXSwgciA9IG4uZW5kID4gZSArIDEgPyB0W2UgKyAxXSAmJiAhMCA9PT0gdFtlICsgMV0ubWF0Y2guc3RhdGljICYmIHRbZSArIDFdIDogdFtlICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgJiYgcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IDAsIHYgPSB2b2lkIDAgIT09IGUuYmVnaW4gPyBlLmJlZ2luIDogZSwgbSA9IHZvaWQgMCAhPT0gZS5lbmQgPyBlLmVuZCA6IGUsIGcgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYmVnaW4gPiBlLmVuZCAmJiAodiA9IGUuZW5kLCBtID0gZS5iZWdpbiksIGkgPSB2b2lkIDAgIT09IGkgPyBpIDogdiwgdm9pZCAwID09PSBuICYmICh2ICE9PSBtIHx8IHMuaW5zZXJ0TW9kZSAmJiB2b2lkIDAgIT09IGwudmFsaWRQb3NpdGlvbnNbaV0gfHwgdm9pZCAwID09PSB0IHx8IHQubWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyIHx8IHQubWF0Y2gub3B0aW9uYWxpdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSwgayA9IGMuZXh0ZW5kKCEwLCBbXSwgbC52YWxpZFBvc2l0aW9ucyksIGIgPSByLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoYSwgdm9pZCAwLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsLnAgPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB1LmNhbGwoYSwgZSkgPyB2IDogaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeSA9IGI7IHkgPj0geDsgeS0tKSBsLnZhbGlkUG9zaXRpb25zLnNwbGljZSh5LCAxKSwgdm9pZCAwID09PSB0ICYmIGRlbGV0ZSBsLnRlc3RzW3kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3LCBQLCBTID0gaSwgTyA9IFM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHQgJiYgKGwudmFsaWRQb3NpdGlvbnNbaV0gPSBjLmV4dGVuZCghMCwge30sIHQpLCBPKyssIFMrKyksIG51bGwgPT0ga1ttXSAmJiBsLmppdE9mZnNldFttXSAmJiAobSArPSBsLmppdE9mZnNldFttXSArIDEpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0ID8gbSA6IG0gLSAxOyB5IDw9IGI7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09ICh3ID0ga1t5XSkgJiYgITAgIT09IHcuZ2VuZXJhdGVkSW5wdXQgJiYgKHkgPj0gbSB8fCB5ID49IHYgJiYgZCh5LCBrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luOiB2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7XCJcIiAhPT0gby5nZXRUZXN0LmNhbGwoYSwgTykubWF0Y2guZGVmOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0gKFAgPSBwLmNhbGwoYSwgTywgdywgcykpIHx8IFwiK1wiID09PSB3Lm1hdGNoLmRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiK1wiID09PSB3Lm1hdGNoLmRlZiAmJiByLmdldEJ1ZmZlci5jYWxsKGEsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgXyA9IGYuY2FsbChhLCBPLCB3LmlucHV0LCBcIitcIiAhPT0gdy5tYXRjaC5kZWYsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZyA9ICExICE9PSBfLCBTID0gKF8ucG9zIHx8IE8pICsgMSwgIWcgJiYgUCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZyA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHQgJiYgdy5tYXRjaC5zdGF0aWMgJiYgeSA9PT0gZS5iZWdpbiAmJiBoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWcgJiYgci5nZXRCdWZmZXIuY2FsbChhKSwgTyA+IGwubWFza0xlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiA9PSBvLmdldFRlc3QuY2FsbChhLCBPKS5tYXRjaC5kZWYgJiYgKGcgPSAhMSksIE8gPSBTO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWcpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnKSByZXR1cm4gbC52YWxpZFBvc2l0aW9ucyA9IGMuZXh0ZW5kKCEwLCBbXSwgayksIHIucmVzZXRNYXNrU2V0LmNhbGwoYSwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICExO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdCAmJiBvLmdldFRlc3QuY2FsbChhLCBpKS5tYXRjaC5jZCA9PT0gdC5tYXRjaC5jZCAmJiAobC52YWxpZFBvc2l0aW9uc1tpXSA9IGMuZXh0ZW5kKCEwLCB7fSwgdCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gci5yZXNldE1hc2tTZXQuY2FsbChhLCAhMCksIGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0ID0ge307XG4gICAgICAgIGZ1bmN0aW9uIG4oaSkge1xuICAgICAgICAgICAgdmFyIGEgPSB0W2ldO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSkgcmV0dXJuIGEuZXhwb3J0cztcbiAgICAgICAgICAgIHZhciByID0gdFtpXSA9IHtcbiAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBlW2ldKHIsIHIuZXhwb3J0cywgbiksIHIuZXhwb3J0cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IHt9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgIH0pLCBlLmRlZmF1bHQgPSB2b2lkIDAsIG4oNzE0OSksIG4oMzE5NCksIG4oOTMwMiksIG4oNDAxMyksIG4oMzg1MSksIG4oMjE5KSwgbigyMDcpLCBcbiAgICAgICAgICAgIG4oNTI5Nik7XG4gICAgICAgICAgICB2YXIgdCwgYSA9ICh0ID0gbigyMzk0KSkgJiYgdC5fX2VzTW9kdWxlID8gdCA6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZS5kZWZhdWx0ID0gYS5kZWZhdWx0O1xuICAgICAgICB9KCksIGk7XG4gICAgfSgpO1xufSkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/inputmask/dist/inputmask.js\n");

/***/ }),

/***/ "./node_modules/swiped-events/dist/swiped-events.min.js":
/*!**************************************************************!*\
  !*** ./node_modules/swiped-events/dist/swiped-events.min.js ***!
  \**************************************************************/
/***/ (() => {

eval("/*!\n * swiped-events.js - v1.2.0\n * Pure JavaScript swipe events\n * https://github.com/john-doherty/swiped-events\n * @inspiration https://stackoverflow.com/questions/16348031/disable-scrolling-when-touch-moving-certain-element\n * @author John Doherty <www.johndoherty.info>\n * @license MIT\n */\n!function(t,e){\"use strict\";\"function\"!=typeof t.CustomEvent&&(t.CustomEvent=function(t,n){n=n||{bubbles:!1,cancelable:!1,detail:void 0};var a=e.createEvent(\"CustomEvent\");return a.initCustomEvent(t,n.bubbles,n.cancelable,n.detail),a},t.CustomEvent.prototype=t.Event.prototype),e.addEventListener(\"touchstart\",function(t){if(\"true\"===t.target.getAttribute(\"data-swipe-ignore\"))return;l=t.target,r=Date.now(),n=t.touches[0].clientX,a=t.touches[0].clientY,u=0,i=0,o=t.touches.length},!1),e.addEventListener(\"touchmove\",function(t){if(!n||!a)return;var e=t.touches[0].clientX,r=t.touches[0].clientY;u=n-e,i=a-r},!1),e.addEventListener(\"touchend\",function(t){if(l!==t.target)return;var c=parseInt(s(l,\"data-swipe-threshold\",\"20\"),10),d=s(l,\"data-swipe-unit\",\"px\"),p=parseInt(s(l,\"data-swipe-timeout\",\"500\"),10),h=Date.now()-r,v=\"\",b=t.changedTouches||t.touches||[];\"vh\"===d&&(c=Math.round(c/100*e.documentElement.clientHeight));\"vw\"===d&&(c=Math.round(c/100*e.documentElement.clientWidth));Math.abs(u)>Math.abs(i)?Math.abs(u)>c&&h<p&&(v=u>0?\"swiped-left\":\"swiped-right\"):Math.abs(i)>c&&h<p&&(v=i>0?\"swiped-up\":\"swiped-down\");if(\"\"!==v){var E={dir:v.replace(/swiped-/,\"\"),touchType:(b[0]||{}).touchType||\"direct\",fingers:o,xStart:parseInt(n,10),xEnd:parseInt((b[0]||{}).clientX||-1,10),yStart:parseInt(a,10),yEnd:parseInt((b[0]||{}).clientY||-1,10)};l.dispatchEvent(new CustomEvent(\"swiped\",{bubbles:!0,cancelable:!0,detail:E})),l.dispatchEvent(new CustomEvent(v,{bubbles:!0,cancelable:!0,detail:E}))}n=null,a=null,r=null},!1);var n=null,a=null,u=null,i=null,r=null,l=null,o=0;function s(t,n,a){for(;t&&t!==e.documentElement;){var u=t.getAttribute(n);if(u)return u;t=t.parentNode}return a}}(window,document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3dpcGVkLWV2ZW50cy9kaXN0L3N3aXBlZC1ldmVudHMubWluLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWEsK0RBQStELE1BQU0sd0NBQXdDLG1DQUFtQyw4REFBOEQsd0ZBQXdGLDhEQUE4RCxpR0FBaUcsZ0RBQWdELGlCQUFpQixrREFBa0QsWUFBWSwrQ0FBK0MsdUJBQXVCLHVMQUF1TCwrREFBK0QsOERBQThELHVJQUF1SSxXQUFXLE9BQU8sK0NBQStDLDZFQUE2RSwrREFBK0QsbUJBQW1CLDBDQUEwQyxrQ0FBa0Msc0NBQXNDLGtDQUFrQyxHQUFHLHFCQUFxQixLQUFLLGtEQUFrRCxrQkFBa0IsS0FBSyx5QkFBeUIsRUFBRSx3QkFBd0IsY0FBYyxlQUFlLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndWxwLXNjc3Mtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9zd2lwZWQtZXZlbnRzL2Rpc3Qvc3dpcGVkLWV2ZW50cy5taW4uanM/NmM3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHN3aXBlZC1ldmVudHMuanMgLSB2MS4yLjBcbiAqIFB1cmUgSmF2YVNjcmlwdCBzd2lwZSBldmVudHNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qb2huLWRvaGVydHkvc3dpcGVkLWV2ZW50c1xuICogQGluc3BpcmF0aW9uIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2MzQ4MDMxL2Rpc2FibGUtc2Nyb2xsaW5nLXdoZW4tdG91Y2gtbW92aW5nLWNlcnRhaW4tZWxlbWVudFxuICogQGF1dGhvciBKb2huIERvaGVydHkgPHd3dy5qb2huZG9oZXJ0eS5pbmZvPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbiFmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO1wiZnVuY3Rpb25cIiE9dHlwZW9mIHQuQ3VzdG9tRXZlbnQmJih0LkN1c3RvbUV2ZW50PWZ1bmN0aW9uKHQsbil7bj1ufHx7YnViYmxlczohMSxjYW5jZWxhYmxlOiExLGRldGFpbDp2b2lkIDB9O3ZhciBhPWUuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtyZXR1cm4gYS5pbml0Q3VzdG9tRXZlbnQodCxuLmJ1YmJsZXMsbi5jYW5jZWxhYmxlLG4uZGV0YWlsKSxhfSx0LkN1c3RvbUV2ZW50LnByb3RvdHlwZT10LkV2ZW50LnByb3RvdHlwZSksZS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKHQpe2lmKFwidHJ1ZVwiPT09dC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zd2lwZS1pZ25vcmVcIikpcmV0dXJuO2w9dC50YXJnZXQscj1EYXRlLm5vdygpLG49dC50b3VjaGVzWzBdLmNsaWVudFgsYT10LnRvdWNoZXNbMF0uY2xpZW50WSx1PTAsaT0wLG89dC50b3VjaGVzLmxlbmd0aH0sITEpLGUuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLGZ1bmN0aW9uKHQpe2lmKCFufHwhYSlyZXR1cm47dmFyIGU9dC50b3VjaGVzWzBdLmNsaWVudFgscj10LnRvdWNoZXNbMF0uY2xpZW50WTt1PW4tZSxpPWEtcn0sITEpLGUuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsZnVuY3Rpb24odCl7aWYobCE9PXQudGFyZ2V0KXJldHVybjt2YXIgYz1wYXJzZUludChzKGwsXCJkYXRhLXN3aXBlLXRocmVzaG9sZFwiLFwiMjBcIiksMTApLGQ9cyhsLFwiZGF0YS1zd2lwZS11bml0XCIsXCJweFwiKSxwPXBhcnNlSW50KHMobCxcImRhdGEtc3dpcGUtdGltZW91dFwiLFwiNTAwXCIpLDEwKSxoPURhdGUubm93KCktcix2PVwiXCIsYj10LmNoYW5nZWRUb3VjaGVzfHx0LnRvdWNoZXN8fFtdO1widmhcIj09PWQmJihjPU1hdGgucm91bmQoYy8xMDAqZS5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSk7XCJ2d1wiPT09ZCYmKGM9TWF0aC5yb3VuZChjLzEwMCplLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkpO01hdGguYWJzKHUpPk1hdGguYWJzKGkpP01hdGguYWJzKHUpPmMmJmg8cCYmKHY9dT4wP1wic3dpcGVkLWxlZnRcIjpcInN3aXBlZC1yaWdodFwiKTpNYXRoLmFicyhpKT5jJiZoPHAmJih2PWk+MD9cInN3aXBlZC11cFwiOlwic3dpcGVkLWRvd25cIik7aWYoXCJcIiE9PXYpe3ZhciBFPXtkaXI6di5yZXBsYWNlKC9zd2lwZWQtLyxcIlwiKSx0b3VjaFR5cGU6KGJbMF18fHt9KS50b3VjaFR5cGV8fFwiZGlyZWN0XCIsZmluZ2VyczpvLHhTdGFydDpwYXJzZUludChuLDEwKSx4RW5kOnBhcnNlSW50KChiWzBdfHx7fSkuY2xpZW50WHx8LTEsMTApLHlTdGFydDpwYXJzZUludChhLDEwKSx5RW5kOnBhcnNlSW50KChiWzBdfHx7fSkuY2xpZW50WXx8LTEsMTApfTtsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwic3dpcGVkXCIse2J1YmJsZXM6ITAsY2FuY2VsYWJsZTohMCxkZXRhaWw6RX0pKSxsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KHYse2J1YmJsZXM6ITAsY2FuY2VsYWJsZTohMCxkZXRhaWw6RX0pKX1uPW51bGwsYT1udWxsLHI9bnVsbH0sITEpO3ZhciBuPW51bGwsYT1udWxsLHU9bnVsbCxpPW51bGwscj1udWxsLGw9bnVsbCxvPTA7ZnVuY3Rpb24gcyh0LG4sYSl7Zm9yKDt0JiZ0IT09ZS5kb2N1bWVudEVsZW1lbnQ7KXt2YXIgdT10LmdldEF0dHJpYnV0ZShuKTtpZih1KXJldHVybiB1O3Q9dC5wYXJlbnROb2RlfXJldHVybiBhfX0od2luZG93LGRvY3VtZW50KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/swiped-events/dist/swiped-events.min.js\n");

/***/ }),

/***/ "./src/blocks/card1/card1.js":
/*!***********************************!*\
  !*** ./src/blocks/card1/card1.js ***!
  \***********************************/
/***/ (() => {

eval("(function () {\n  document.querySelectorAll('.card1').forEach(function (card) {\n    // const { clear } = window.getComputedStyle(card);\n    // if (clear !== 'none') return;\n\n    card.addEventListener('mouseenter', function (e) {\n      var _card$children$;\n      var _card$children$0$getB = (_card$children$ = card.children[0]) === null || _card$children$ === void 0 ? void 0 : _card$children$.getBoundingClientRect(),\n        height = _card$children$0$getB.height;\n      card.style.setProperty('--height', \"\".concat(height, \"px\"));\n    });\n    card.addEventListener('mouseleave', function (e) {\n      card.style.removeProperty('--height');\n    });\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL2NhcmQxL2NhcmQxLmpzIiwibmFtZXMiOlsiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImNhcmQiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsIl9jYXJkJGNoaWxkcmVuJCIsIl9jYXJkJGNoaWxkcmVuJDAkZ2V0QiIsImNoaWxkcmVuIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGVpZ2h0Iiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsImNvbmNhdCIsInJlbW92ZVByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndWxwLXNjc3Mtc3RhcnRlci8uL3NyYy9ibG9ja3MvY2FyZDEvY2FyZDEuanM/MTNlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCkgPT4ge1xuXG5cdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJkMScpLmZvckVhY2goKGNhcmQpID0+IHtcblx0XHQvLyBjb25zdCB7IGNsZWFyIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjYXJkKTtcblx0XHQvLyBpZiAoY2xlYXIgIT09ICdub25lJykgcmV0dXJuO1xuXG5cdFx0Y2FyZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKGUpID0+IHtcblx0XHRcdGNvbnN0IHsgaGVpZ2h0IH0gPSBjYXJkLmNoaWxkcmVuWzBdPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdGNhcmQuc3R5bGUuc2V0UHJvcGVydHkoJy0taGVpZ2h0JywgYCR7aGVpZ2h0fXB4YCk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0Y2FyZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKGUpID0+IHtcblx0XHRcdGNhcmQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJy0taGVpZ2h0Jyk7XG5cdFx0fSk7XG5cdH0pO1xuXG59KSgpOyJdLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQyxZQUFNO0VBRU5BLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUNDLE9BQU8sQ0FBQyxVQUFDQyxJQUFJLEVBQUs7SUFDckQ7SUFDQTs7SUFFQUEsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsVUFBQ0MsQ0FBQyxFQUFLO01BQUEsSUFBQUMsZUFBQTtNQUMxQyxJQUFBQyxxQkFBQSxJQUFBRCxlQUFBLEdBQW1CSCxJQUFJLENBQUNLLFFBQVEsQ0FBQyxDQUFDLENBQUMsY0FBQUYsZUFBQSx1QkFBaEJBLGVBQUEsQ0FBa0JHLHFCQUFxQixDQUFDLENBQUM7UUFBcERDLE1BQU0sR0FBQUgscUJBQUEsQ0FBTkcsTUFBTTtNQUNkUCxJQUFJLENBQUNRLEtBQUssQ0FBQ0MsV0FBVyxDQUFDLFVBQVUsS0FBQUMsTUFBQSxDQUFLSCxNQUFNLE9BQUksQ0FBQztJQUNsRCxDQUFDLENBQUM7SUFFRlAsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsVUFBQ0MsQ0FBQyxFQUFLO01BQzFDRixJQUFJLENBQUNRLEtBQUssQ0FBQ0csY0FBYyxDQUFDLFVBQVUsQ0FBQztJQUN0QyxDQUFDLENBQUM7RUFDSCxDQUFDLENBQUM7QUFFSCxDQUFDLEVBQUUsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==\n//# sourceURL=webpack-internal:///./src/blocks/card1/card1.js\n");

/***/ }),

/***/ "./src/blocks/filter1/filter1.js":
/*!***************************************!*\
  !*** ./src/blocks/filter1/filter1.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_libs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/libs/utils */ \"./src/js/libs/utils.js\");\n/* harmony import */ var _js_libs_driveSlide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../js/libs/driveSlide */ \"./src/js/libs/driveSlide.js\");\n\n\n(function () {\n  var filters = document.querySelectorAll('.filter1');\n  var storage = JSON.parse(localStorage.getItem('filters')) || [];\n  filters === null || filters === void 0 || filters.forEach(function (filter, i) {\n    var _filter$querySelector;\n    filter.classList.toggle('opened', storage.includes(i));\n    (_filter$querySelector = filter.querySelector('.filter1__title')) === null || _filter$querySelector === void 0 || _filter$querySelector.addEventListener('click', function (e) {\n      var opened = _js_libs_driveSlide__WEBPACK_IMPORTED_MODULE_1__[\"default\"].toggle(filter.querySelector('.filter1__body'), {\n        duration: 300\n      });\n      filter.classList.toggle('opened', opened);\n      (0,_js_libs_utils__WEBPACK_IMPORTED_MODULE_0__.updateLocalStorage)('filters', i, opened);\n    });\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL2ZpbHRlcjEvZmlsdGVyMS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBeUQ7QUFDWjtBQUU3QyxDQUFDLFlBQU07RUFDTixJQUFNRSxPQUFPLEdBQUdDLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsVUFBVSxDQUFDO0VBQ3JELElBQUlDLE9BQU8sR0FBR0MsSUFBSSxDQUFDQyxLQUFLLENBQUNDLFlBQVksQ0FBQ0MsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRTtFQUUvRFAsT0FBTyxhQUFQQSxPQUFPLGVBQVBBLE9BQU8sQ0FBRVEsT0FBTyxDQUFDLFVBQUNDLE1BQU0sRUFBRUMsQ0FBQyxFQUFLO0lBQUEsSUFBQUMscUJBQUE7SUFDL0JGLE1BQU0sQ0FBQ0csU0FBUyxDQUFDQyxNQUFNLENBQUMsUUFBUSxFQUFFVixPQUFPLENBQUNXLFFBQVEsQ0FBQ0osQ0FBQyxDQUFDLENBQUM7SUFFdEQsQ0FBQUMscUJBQUEsR0FBQUYsTUFBTSxDQUFDTSxhQUFhLENBQUMsaUJBQWlCLENBQUMsY0FBQUoscUJBQUEsZUFBdkNBLHFCQUFBLENBQXlDSyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQ0MsQ0FBQyxFQUFLO01BQ3pFLElBQU1DLE1BQU0sR0FBR25CLGtFQUFZLENBQUNVLE1BQU0sQ0FBQ00sYUFBYSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7UUFBRUksUUFBUSxFQUFFO01BQUksQ0FBQyxDQUFDO01BRXRGVixNQUFNLENBQUNHLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDLFFBQVEsRUFBRUssTUFBTSxDQUFDO01BQ3pDcEIsa0VBQWtCLENBQUMsU0FBUyxFQUFFWSxDQUFDLEVBQUVRLE1BQU0sQ0FBQztJQUN6QyxDQUFDLENBQUM7RUFDSCxDQUFDLENBQUM7QUFFSCxDQUFDLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2d1bHAtc2Nzcy1zdGFydGVyLy4vc3JjL2Jsb2Nrcy9maWx0ZXIxL2ZpbHRlcjEuanM/N2Q5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1cGRhdGVMb2NhbFN0b3JhZ2UgfSBmcm9tIFwiLi4vLi4vanMvbGlicy91dGlsc1wiO1xuaW1wb3J0IHNsaWRlIGZyb20gXCIuLi8uLi9qcy9saWJzL2RyaXZlU2xpZGVcIjtcblxuKCgpID0+IHtcblx0Y29uc3QgZmlsdGVycyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5maWx0ZXIxJyk7XG5cdGxldCBzdG9yYWdlID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZmlsdGVycycpKSB8fCBbXTtcblxuXHRmaWx0ZXJzPy5mb3JFYWNoKChmaWx0ZXIsIGkpID0+IHtcblx0XHRmaWx0ZXIuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbmVkJywgc3RvcmFnZS5pbmNsdWRlcyhpKSk7XG5cblx0XHRmaWx0ZXIucXVlcnlTZWxlY3RvcignLmZpbHRlcjFfX3RpdGxlJyk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcblx0XHRcdGNvbnN0IG9wZW5lZCA9IHNsaWRlLnRvZ2dsZShmaWx0ZXIucXVlcnlTZWxlY3RvcignLmZpbHRlcjFfX2JvZHknKSwgeyBkdXJhdGlvbjogMzAwIH0pO1xuXG5cdFx0XHRmaWx0ZXIuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbmVkJywgb3BlbmVkKTtcblx0XHRcdHVwZGF0ZUxvY2FsU3RvcmFnZSgnZmlsdGVycycsIGksIG9wZW5lZCk7XG5cdFx0fSk7XG5cdH0pO1xuXG59KSgpOyJdLCJuYW1lcyI6WyJ1cGRhdGVMb2NhbFN0b3JhZ2UiLCJzbGlkZSIsImZpbHRlcnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzdG9yYWdlIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImZvckVhY2giLCJmaWx0ZXIiLCJpIiwiX2ZpbHRlciRxdWVyeVNlbGVjdG9yIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwiaW5jbHVkZXMiLCJxdWVyeVNlbGVjdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJvcGVuZWQiLCJkdXJhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/filter1/filter1.js\n");

/***/ }),

/***/ "./src/blocks/form1/form1.js":
/*!***********************************!*\
  !*** ./src/blocks/form1/form1.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_libs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/libs/utils */ \"./src/js/libs/utils.js\");\n/* harmony import */ var _js_libs_fieldValidate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../js/libs/fieldValidate */ \"./src/js/libs/fieldValidate.js\");\n/* harmony import */ var inputmask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! inputmask */ \"./node_modules/inputmask/dist/inputmask.js\");\n/* harmony import */ var inputmask__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(inputmask__WEBPACK_IMPORTED_MODULE_2__);\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2); } }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n\n\n\n(function () {\n  var form = document.querySelector('form.form1');\n  if (!form) return;\n\n  // маска для ввода телефона\n  inputmask__WEBPACK_IMPORTED_MODULE_2___default()({\n    \"mask\": \"+7 (999) 999-99-99\",\n    showMaskOnHover: false\n  }).mask(form.querySelectorAll('input[type=\"tel\"]'));\n\n  // оформление для прикрепления файла\t\n  form.querySelectorAll('.form1__file input[type=\"file\"]').forEach(function (input) {\n    input.addEventListener('change', function (e) {\n      var file = e.currentTarget.files[0];\n      var button = e.currentTarget.parentNode;\n      if (file) {\n        button.querySelector('span').innerText = file.name;\n        button.classList.add('added');\n      }\n    });\n  });\n\n  // фукция валидации полей\n  var validate = function validate(input) {\n    var _check$message;\n    var check = (0,_js_libs_fieldValidate__WEBPACK_IMPORTED_MODULE_1__.fieldValidate)(input);\n    var field = input.closest('.form1__field');\n    field.classList.toggle('error', !check.valid);\n    field.querySelector('.form1__error').innerText = (_check$message = check.message) !== null && _check$message !== void 0 ? _check$message : '';\n    return check.valid;\n  };\n  form.querySelectorAll('.form1__input input, .form1__input textarea').forEach(function (input) {\n    // адаптивное поле ввода текста\n    input.tagName === 'TEXTAREA' && (0,_js_libs_utils__WEBPACK_IMPORTED_MODULE_0__.textareaResize)(input);\n\n    // валидация полей при заполнении\n    ['change', 'blur'].forEach(function (event) {\n      input.addEventListener(event, function (e) {\n        return validate(input);\n      });\n    });\n  });\n  form.addEventListener('submit', /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(e) {\n      var valid;\n      return _regenerator().w(function (_context) {\n        while (1) switch (_context.n) {\n          case 0:\n            e.preventDefault();\n            valid = true; // валидация полей при отправке\n            this.querySelectorAll('[data-rules]').forEach(function (input) {\n              var check = validate(input);\n              valid && (valid = check);\n            });\n            if (valid) {\n              this.classList.add('pending');\n              try {\n                // тут логика отправки формы\n              } catch (error) {\n                console.error(error);\n              } finally {\n                this.classList.remove('pending');\n              }\n            }\n          case 1:\n            return _context.a(2);\n        }\n      }, _callee, this);\n    }));\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM7TUFBQSxJQUFBaUYsS0FBQTtNQUFBLE9BQUE3QyxZQUFBLEdBQUFDLENBQUEsV0FBQWtELFFBQUE7UUFBQSxrQkFBQUEsUUFBQSxDQUFBbkYsQ0FBQTtVQUFBO1lBQy9DSixDQUFDLENBQUN3RixjQUFjLENBQUMsQ0FBQztZQUNkUCxLQUFLLEdBQUcsSUFBSSxFQUVoQjtZQUNBLElBQUksQ0FBQ25CLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxDQUFDQyxPQUFPLENBQUMsVUFBQUMsS0FBSyxFQUFJO2NBQ3RELElBQU1hLEtBQUssR0FBR0YsUUFBUSxDQUFDWCxLQUFLLENBQUM7Y0FDN0JpQixLQUFLLEtBQUxBLEtBQUssR0FBS0osS0FBSztZQUNoQixDQUFDLENBQUM7WUFFRixJQUFJSSxLQUFLLEVBQUU7Y0FDVixJQUFJLENBQUNSLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDLFNBQVMsQ0FBQztjQUU3QixJQUFJO2dCQUNIO2NBQUEsQ0FDQSxDQUFDLE9BQU9lLEtBQUssRUFBRTtnQkFDZkMsT0FBTyxDQUFDRCxLQUFLLENBQUNBLEtBQUssQ0FBQztjQUNyQixDQUFDLFNBQVM7Z0JBQ1QsSUFBSSxDQUFDaEIsU0FBUyxDQUFDa0IsTUFBTSxDQUFDLFNBQVMsQ0FBQztjQUNqQztZQUNEO1VBQUM7WUFBQSxPQUFBSixRQUFBLENBQUFsRSxDQUFBO1FBQUE7TUFBQSxHQUFBaUUsT0FBQTtJQUFBLENBQ0Q7SUFBQSxpQkFBQU0sRUFBQTtNQUFBLE9BQUFQLElBQUEsQ0FBQWxDLEtBQUEsT0FBQUQsU0FBQTtJQUFBO0VBQUEsSUFBQztBQUVILENBQUMsRUFBRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvYmxvY2tzL2Zvcm0xL2Zvcm0xLmpzPzc1MjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdGV4dGFyZWFSZXNpemUgfSBmcm9tIFwiLi4vLi4vanMvbGlicy91dGlsc1wiO1xuaW1wb3J0IHsgZmllbGRWYWxpZGF0ZSB9IGZyb20gXCIuLi8uLi9qcy9saWJzL2ZpZWxkVmFsaWRhdGVcIjtcbmltcG9ydCBJbnB1dG1hc2sgZnJvbSBcImlucHV0bWFza1wiO1xuXG4oKCkgPT4ge1xuXHRjb25zdCBmb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZm9ybS5mb3JtMScpO1xuXHRpZiAoISBmb3JtKSByZXR1cm47XG5cblx0Ly8g0LzQsNGB0LrQsCDQtNC70Y8g0LLQstC+0LTQsCDRgtC10LvQtdGE0L7QvdCwXG5cdElucHV0bWFzayh7IFxuXHRcdFwibWFza1wiOiBcIis3ICg5OTkpIDk5OS05OS05OVwiLCBcblx0XHRzaG93TWFza09uSG92ZXI6IGZhbHNlIFxuXHR9KS5tYXNrKGZvcm0ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInRlbFwiXScpKTtcblxuXHQvLyDQvtGE0L7RgNC80LvQtdC90LjQtSDQtNC70Y8g0L/RgNC40LrRgNC10L/Qu9C10L3QuNGPINGE0LDQudC70LBcdFxuXHRmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb3JtMV9fZmlsZSBpbnB1dFt0eXBlPVwiZmlsZVwiXScpLmZvckVhY2goKGlucHV0KSA9PiB7XG5cdFx0aW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcblx0XHRcdGNvbnN0IGZpbGUgPSBlLmN1cnJlbnRUYXJnZXQuZmlsZXNbMF07XG5cdFx0XHRjb25zdCBidXR0b24gPSBlLmN1cnJlbnRUYXJnZXQucGFyZW50Tm9kZTtcblx0XG5cdFx0XHRpZiAoZmlsZSkge1xuXHRcdFx0XHRidXR0b24ucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVyVGV4dCA9IGZpbGUubmFtZTtcblx0XHRcdFx0YnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2FkZGVkJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG5cdC8vINGE0YPQutGG0LjRjyDQstCw0LvQuNC00LDRhtC40Lgg0L/QvtC70LXQuVxuXHRjb25zdCB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0Y29uc3QgY2hlY2sgPSBmaWVsZFZhbGlkYXRlKGlucHV0KTtcblx0XHRjb25zdCBmaWVsZCA9IGlucHV0LmNsb3Nlc3QoJy5mb3JtMV9fZmllbGQnKTtcblx0XHRmaWVsZC5jbGFzc0xpc3QudG9nZ2xlKCdlcnJvcicsICFjaGVjay52YWxpZCk7XG5cdFx0ZmllbGQucXVlcnlTZWxlY3RvcignLmZvcm0xX19lcnJvcicpLmlubmVyVGV4dCA9IGNoZWNrLm1lc3NhZ2UgPz8gJyc7XG5cblx0XHRyZXR1cm4gY2hlY2sudmFsaWQ7XG5cdH1cblxuXHRmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb3JtMV9faW5wdXQgaW5wdXQsIC5mb3JtMV9faW5wdXQgdGV4dGFyZWEnKS5mb3JFYWNoKGlucHV0ID0+IHtcblx0XHQvLyDQsNC00LDQv9GC0LjQstC90L7QtSDQv9C+0LvQtSDQstCy0L7QtNCwINGC0LXQutGB0YLQsFxuXHRcdChpbnB1dC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSAmJiB0ZXh0YXJlYVJlc2l6ZShpbnB1dCk7XG5cblx0XHQvLyDQstCw0LvQuNC00LDRhtC40Y8g0L/QvtC70LXQuSDQv9GA0Lgg0LfQsNC/0L7Qu9C90LXQvdC40Lhcblx0XHRbJ2NoYW5nZScsICdibHVyJ10uZm9yRWFjaChldmVudCA9PiB7XG5cdFx0XHRpbnB1dC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBlID0+IHZhbGlkYXRlKGlucHV0KSk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgYXN5bmMgZnVuY3Rpb24oZSkge1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRsZXQgdmFsaWQgPSB0cnVlO1xuXG5cdFx0Ly8g0LLQsNC70LjQtNCw0YbQuNGPINC/0L7Qu9C10Lkg0L/RgNC4INC+0YLQv9GA0LDQstC60LVcblx0XHR0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXJ1bGVzXScpLmZvckVhY2goaW5wdXQgPT4ge1xuXHRcdFx0Y29uc3QgY2hlY2sgPSB2YWxpZGF0ZShpbnB1dCk7XG5cdFx0XHR2YWxpZCAmJj0gY2hlY2s7XG5cdFx0fSk7XG5cblx0XHRpZiAodmFsaWQpIHtcblx0XHRcdHRoaXMuY2xhc3NMaXN0LmFkZCgncGVuZGluZycpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyDRgtGD0YIg0LvQvtCz0LjQutCwINC+0YLQv9GA0LDQstC60Lgg0YTQvtGA0LzRi1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihlcnJvcik7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3BlbmRpbmcnKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG59KSgpO1xuIl0sIm5hbWVzIjpbImUiLCJ0IiwiciIsIlN5bWJvbCIsIm4iLCJpdGVyYXRvciIsIm8iLCJ0b1N0cmluZ1RhZyIsImkiLCJjIiwicHJvdG90eXBlIiwiR2VuZXJhdG9yIiwidSIsIk9iamVjdCIsImNyZWF0ZSIsIl9yZWdlbmVyYXRvckRlZmluZTIiLCJmIiwicCIsInkiLCJHIiwidiIsImEiLCJkIiwiYmluZCIsImxlbmd0aCIsImwiLCJUeXBlRXJyb3IiLCJjYWxsIiwiZG9uZSIsInZhbHVlIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJkaXNwbGF5TmFtZSIsIl9yZWdlbmVyYXRvciIsInciLCJtIiwiZGVmaW5lUHJvcGVydHkiLCJfcmVnZW5lcmF0b3JEZWZpbmUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfaW52b2tlIiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9uZXh0IiwiX3Rocm93IiwidGV4dGFyZWFSZXNpemUiLCJmaWVsZFZhbGlkYXRlIiwiSW5wdXRtYXNrIiwiZm9ybSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInNob3dNYXNrT25Ib3ZlciIsIm1hc2siLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImlucHV0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImZpbGUiLCJjdXJyZW50VGFyZ2V0IiwiZmlsZXMiLCJidXR0b24iLCJwYXJlbnROb2RlIiwiaW5uZXJUZXh0IiwibmFtZSIsImNsYXNzTGlzdCIsImFkZCIsInZhbGlkYXRlIiwiX2NoZWNrJG1lc3NhZ2UiLCJjaGVjayIsImZpZWxkIiwiY2xvc2VzdCIsInRvZ2dsZSIsInZhbGlkIiwibWVzc2FnZSIsInRhZ05hbWUiLCJldmVudCIsIl9yZWYiLCJfY2FsbGVlIiwiX2NvbnRleHQiLCJwcmV2ZW50RGVmYXVsdCIsImVycm9yIiwiY29uc29sZSIsInJlbW92ZSIsIl94Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/blocks/form1/form1.js\n");

/***/ }),

/***/ "./src/blocks/header1/header1.js":
/*!***************************************!*\
  !*** ./src/blocks/header1/header1.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fluejs_noscroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluejs/noscroll */ \"./node_modules/@fluejs/noscroll/dist/index.mjs\");\n/* harmony import */ var _js_libs_driveMenu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/libs/driveMenu */ \"./src/js/libs/driveMenu.js\");\n\n\n(function (_document$querySelect) {\n  var header = document.querySelector('.header1');\n  if (!header) return;\n  var navi = header.querySelector('.header1__navi');\n  var toggle = header.querySelector('.header1__toggle');\n  var close = header.querySelector('.header1__close');\n  var menu = (0,_js_libs_driveMenu__WEBPACK_IMPORTED_MODULE_0__.driveMenu)(navi, [toggle, close], {\n    omitToClose: '.modal',\n    \"class\": 'opened',\n    open: function open() {\n      (0,_fluejs_noscroll__WEBPACK_IMPORTED_MODULE_1__.disablePageScroll)();\n      toggle.classList.add('opened');\n      document.body.classList.add('underlay');\n    },\n    close: function close() {\n      (0,_fluejs_noscroll__WEBPACK_IMPORTED_MODULE_1__.enablePageScroll)();\n      toggle.classList.remove('opened');\n      document.body.classList.add('underlay_closing');\n      this.addEventListener('transitionend', function (e) {\n        document.body.classList.remove('underlay', 'underlay_closing');\n      }, {\n        once: true\n      });\n    }\n  });\n  window.addEventListener('scroll', function () {\n    header.classList[window.scrollY < 30 ? 'remove' : 'add']('header1_scrolled');\n  });\n\n  // чтобы не перекрывались с сайдбаром\n  (_document$querySelect = document.querySelector('button.sidebar1__toggle')) === null || _document$querySelect === void 0 || _document$querySelect.addEventListener('click', function (e) {\n    return menu.menuClose(e, function () {\n      toggle.classList.remove('opened');\n      (0,_fluejs_noscroll__WEBPACK_IMPORTED_MODULE_1__.enablePageScroll)();\n    });\n  });\n  navi.addEventListener('swiped-left', function (e) {\n    return menu.menuClose(e);\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL2hlYWRlcjEvaGVhZGVyMS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBdUU7QUFDbkI7QUFFcEQsQ0FBQyxVQUFBRyxxQkFBQSxFQUFNO0VBQ04sSUFBTUMsTUFBTSxHQUFHQyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxVQUFVLENBQUM7RUFDakQsSUFBSSxDQUFFRixNQUFNLEVBQUU7RUFFZCxJQUFNRyxJQUFJLEdBQUdILE1BQU0sQ0FBQ0UsYUFBYSxDQUFDLGdCQUFnQixDQUFDO0VBQ25ELElBQU1FLE1BQU0sR0FBR0osTUFBTSxDQUFDRSxhQUFhLENBQUMsa0JBQWtCLENBQUM7RUFDdkQsSUFBTUcsS0FBSyxHQUFHTCxNQUFNLENBQUNFLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQztFQUVyRCxJQUFNSSxJQUFJLEdBQUdSLDZEQUFTLENBQUNLLElBQUksRUFBRSxDQUFDQyxNQUFNLEVBQUVDLEtBQUssQ0FBQyxFQUFFO0lBQzdDRSxXQUFXLEVBQUUsUUFBUTtJQUNyQixTQUFPLFFBQVE7SUFDZkMsSUFBSSxFQUFFLFNBQU5BLElBQUlBLENBQUEsRUFBYTtNQUNoQlosbUVBQWlCLENBQUMsQ0FBQztNQUNuQlEsTUFBTSxDQUFDSyxTQUFTLENBQUNDLEdBQUcsQ0FBQyxRQUFRLENBQUM7TUFDOUJULFFBQVEsQ0FBQ1UsSUFBSSxDQUFDRixTQUFTLENBQUNDLEdBQUcsQ0FBQyxVQUFVLENBQUM7SUFFeEMsQ0FBQztJQUNETCxLQUFLLEVBQUUsU0FBUEEsS0FBS0EsQ0FBQSxFQUFhO01BQ2pCUixrRUFBZ0IsQ0FBQyxDQUFDO01BQ2xCTyxNQUFNLENBQUNLLFNBQVMsQ0FBQ0csTUFBTSxDQUFDLFFBQVEsQ0FBQztNQUNqQ1gsUUFBUSxDQUFDVSxJQUFJLENBQUNGLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDLGtCQUFrQixDQUFDO01BRS9DLElBQUksQ0FBQ0csZ0JBQWdCLENBQUMsZUFBZSxFQUFFLFVBQUFDLENBQUMsRUFBSTtRQUMzQ2IsUUFBUSxDQUFDVSxJQUFJLENBQUNGLFNBQVMsQ0FBQ0csTUFBTSxDQUFDLFVBQVUsRUFBRSxrQkFBa0IsQ0FBQztNQUMvRCxDQUFDLEVBQUU7UUFBRUcsSUFBSSxFQUFFO01BQUssQ0FBQyxDQUFDO0lBQ25CO0VBQ0QsQ0FBQyxDQUFDO0VBRUZDLE1BQU0sQ0FBQ0gsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLFlBQU07SUFDdkNiLE1BQU0sQ0FBQ1MsU0FBUyxDQUFDTyxNQUFNLENBQUNDLE9BQU8sR0FBRyxFQUFFLEdBQUcsUUFBUSxHQUFFLEtBQUssQ0FBQyxDQUFDLGtCQUFrQixDQUFDO0VBQzVFLENBQUMsQ0FBQzs7RUFFRjtFQUNBLENBQUFsQixxQkFBQSxHQUFBRSxRQUFRLENBQUNDLGFBQWEsQ0FBQyx5QkFBeUIsQ0FBQyxjQUFBSCxxQkFBQSxlQUFqREEscUJBQUEsQ0FDR2MsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUNDLENBQUM7SUFBQSxPQUFLUixJQUFJLENBQUNZLFNBQVMsQ0FBQ0osQ0FBQyxFQUFFLFlBQU07TUFDMURWLE1BQU0sQ0FBQ0ssU0FBUyxDQUFDRyxNQUFNLENBQUMsUUFBUSxDQUFDO01BQ2pDZixrRUFBZ0IsQ0FBQyxDQUFDO0lBQ25CLENBQUMsQ0FBQztFQUFBLEVBQUM7RUFFSk0sSUFBSSxDQUFDVSxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsVUFBQ0MsQ0FBQztJQUFBLE9BQUtSLElBQUksQ0FBQ1ksU0FBUyxDQUFDSixDQUFDLENBQUM7RUFBQSxFQUFDO0FBRS9ELENBQUMsRUFBRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvYmxvY2tzL2hlYWRlcjEvaGVhZGVyMS5qcz85NGRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRpc2FibGVQYWdlU2Nyb2xsLCBlbmFibGVQYWdlU2Nyb2xsIH0gZnJvbSAnQGZsdWVqcy9ub3Njcm9sbCc7XG5pbXBvcnQgeyBkcml2ZU1lbnUgfSBmcm9tIFwiLi4vLi4vanMvbGlicy9kcml2ZU1lbnVcIjtcblxuKCgpID0+IHtcblx0Y29uc3QgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhlYWRlcjEnKTtcblx0aWYgKCEgaGVhZGVyKSByZXR1cm47XG5cblx0Y29uc3QgbmF2aSA9IGhlYWRlci5xdWVyeVNlbGVjdG9yKCcuaGVhZGVyMV9fbmF2aScpO1xuXHRjb25zdCB0b2dnbGUgPSBoZWFkZXIucXVlcnlTZWxlY3RvcignLmhlYWRlcjFfX3RvZ2dsZScpO1xuXHRjb25zdCBjbG9zZSA9IGhlYWRlci5xdWVyeVNlbGVjdG9yKCcuaGVhZGVyMV9fY2xvc2UnKTtcblxuXHRjb25zdCBtZW51ID0gZHJpdmVNZW51KG5hdmksIFt0b2dnbGUsIGNsb3NlXSwge1xuXHRcdG9taXRUb0Nsb3NlOiAnLm1vZGFsJyxcblx0XHRjbGFzczogJ29wZW5lZCcsXG5cdFx0b3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkaXNhYmxlUGFnZVNjcm9sbCgpO1xuXHRcdFx0dG9nZ2xlLmNsYXNzTGlzdC5hZGQoJ29wZW5lZCcpO1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCd1bmRlcmxheScpO1xuXG5cdFx0fSxcblx0XHRjbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRlbmFibGVQYWdlU2Nyb2xsKCk7XG5cdFx0XHR0b2dnbGUuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbmVkJyk7XG5cdFx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3VuZGVybGF5X2Nsb3NpbmcnKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZSA9PiB7XG5cdFx0XHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgndW5kZXJsYXknLCAndW5kZXJsYXlfY2xvc2luZycpO1xuXHRcdFx0fSwgeyBvbmNlOiB0cnVlIH0pO1xuXHRcdH1cblx0fSk7XG5cdFxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xuXHRcdGhlYWRlci5jbGFzc0xpc3Rbd2luZG93LnNjcm9sbFkgPCAzMCA/ICdyZW1vdmUnOiAnYWRkJ10oJ2hlYWRlcjFfc2Nyb2xsZWQnKTtcblx0fSk7XG5cblx0Ly8g0YfRgtC+0LHRiyDQvdC1INC/0LXRgNC10LrRgNGL0LLQsNC70LjRgdGMINGBINGB0LDQudC00LHQsNGA0L7QvFxuXHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b24uc2lkZWJhcjFfX3RvZ2dsZScpXG5cdFx0Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiBtZW51Lm1lbnVDbG9zZShlLCAoKSA9PiB7XG5cdFx0XHR0b2dnbGUuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbmVkJyk7XG5cdFx0XHRlbmFibGVQYWdlU2Nyb2xsKCk7XG5cdFx0fSkpO1xuXG5cdG5hdmkuYWRkRXZlbnRMaXN0ZW5lcignc3dpcGVkLWxlZnQnLCAoZSkgPT4gbWVudS5tZW51Q2xvc2UoZSkpO1xuXG59KSgpO1xuIl0sIm5hbWVzIjpbImRpc2FibGVQYWdlU2Nyb2xsIiwiZW5hYmxlUGFnZVNjcm9sbCIsImRyaXZlTWVudSIsIl9kb2N1bWVudCRxdWVyeVNlbGVjdCIsImhlYWRlciIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm5hdmkiLCJ0b2dnbGUiLCJjbG9zZSIsIm1lbnUiLCJvbWl0VG9DbG9zZSIsIm9wZW4iLCJjbGFzc0xpc3QiLCJhZGQiLCJib2R5IiwicmVtb3ZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJvbmNlIiwid2luZG93Iiwic2Nyb2xsWSIsIm1lbnVDbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/header1/header1.js\n");

/***/ }),

/***/ "./src/blocks/ladder1/ladder1.js":
/*!***************************************!*\
  !*** ./src/blocks/ladder1/ladder1.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_libs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/libs/utils */ \"./src/js/libs/utils.js\");\n/* harmony import */ var _js_libs_driveSlide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../js/libs/driveSlide */ \"./src/js/libs/driveSlide.js\");\n\n\n(function (_document$querySelect) {\n  var storage = JSON.parse(localStorage.getItem('ladder1')) || [];\n  (_document$querySelect = document.querySelectorAll('.ladder1__item')) === null || _document$querySelect === void 0 || _document$querySelect.forEach(function (item, i) {\n    var _item$querySelector;\n    item.classList.toggle('opened', storage.includes(i));\n    (_item$querySelector = item.querySelector('button')) === null || _item$querySelector === void 0 || _item$querySelector.addEventListener('click', function (e) {\n      var opened = _js_libs_driveSlide__WEBPACK_IMPORTED_MODULE_1__[\"default\"].toggle(item.querySelector('.ladder1__level'), {\n        duration: 300\n      });\n      item.classList.toggle('opened', opened);\n      (0,_js_libs_utils__WEBPACK_IMPORTED_MODULE_0__.updateLocalStorage)('ladder1', i, opened);\n    });\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL2xhZGRlcjEvbGFkZGVyMS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBeUQ7QUFDWjtBQUU3QyxDQUFDLFVBQUFFLHFCQUFBLEVBQU07RUFDTixJQUFNQyxPQUFPLEdBQUdDLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxZQUFZLENBQUNDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUU7RUFFakUsQ0FBQUwscUJBQUEsR0FBQU0sUUFBUSxDQUFDQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFBUCxxQkFBQSxlQUEzQ0EscUJBQUEsQ0FBNkNRLE9BQU8sQ0FBQyxVQUFDQyxJQUFJLEVBQUVDLENBQUMsRUFBSztJQUFBLElBQUFDLG1CQUFBO0lBQ2pFRixJQUFJLENBQUNHLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDLFFBQVEsRUFBRVosT0FBTyxDQUFDYSxRQUFRLENBQUNKLENBQUMsQ0FBQyxDQUFDO0lBRXBELENBQUFDLG1CQUFBLEdBQUFGLElBQUksQ0FBQ00sYUFBYSxDQUFDLFFBQVEsQ0FBQyxjQUFBSixtQkFBQSxlQUE1QkEsbUJBQUEsQ0FBOEJLLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDQyxDQUFDLEVBQUs7TUFDOUQsSUFBTUMsTUFBTSxHQUFHbkIsa0VBQVksQ0FBQ1UsSUFBSSxDQUFDTSxhQUFhLENBQUMsaUJBQWlCLENBQUMsRUFBRTtRQUFFSSxRQUFRLEVBQUU7TUFBSSxDQUFDLENBQUM7TUFFckZWLElBQUksQ0FBQ0csU0FBUyxDQUFDQyxNQUFNLENBQUMsUUFBUSxFQUFFSyxNQUFNLENBQUM7TUFDdkNwQixrRUFBa0IsQ0FBQyxTQUFTLEVBQUVZLENBQUMsRUFBRVEsTUFBTSxDQUFDO0lBQ3pDLENBQUMsQ0FBQztFQUNILENBQUMsQ0FBQztBQUVILENBQUMsRUFBRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvYmxvY2tzL2xhZGRlcjEvbGFkZGVyMS5qcz9hZDhjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVwZGF0ZUxvY2FsU3RvcmFnZSB9IGZyb20gXCIuLi8uLi9qcy9saWJzL3V0aWxzXCI7XG5pbXBvcnQgc2xpZGUgZnJvbSBcIi4uLy4uL2pzL2xpYnMvZHJpdmVTbGlkZVwiO1xuXG4oKCkgPT4ge1xuXHRjb25zdCBzdG9yYWdlID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbGFkZGVyMScpKSB8fCBbXTtcblxuXHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubGFkZGVyMV9faXRlbScpPy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG5cdFx0aXRlbS5jbGFzc0xpc3QudG9nZ2xlKCdvcGVuZWQnLCBzdG9yYWdlLmluY2x1ZGVzKGkpKTtcblxuXHRcdGl0ZW0ucXVlcnlTZWxlY3RvcignYnV0dG9uJyk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcblx0XHRcdGNvbnN0IG9wZW5lZCA9IHNsaWRlLnRvZ2dsZShpdGVtLnF1ZXJ5U2VsZWN0b3IoJy5sYWRkZXIxX19sZXZlbCcpLCB7IGR1cmF0aW9uOiAzMDAgfSk7XG5cblx0XHRcdGl0ZW0uY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbmVkJywgb3BlbmVkKTtcblx0XHRcdHVwZGF0ZUxvY2FsU3RvcmFnZSgnbGFkZGVyMScsIGksIG9wZW5lZCk7XG5cdFx0fSk7XG5cdH0pO1xuXG59KSgpOyJdLCJuYW1lcyI6WyJ1cGRhdGVMb2NhbFN0b3JhZ2UiLCJzbGlkZSIsIl9kb2N1bWVudCRxdWVyeVNlbGVjdCIsInN0b3JhZ2UiLCJKU09OIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsIml0ZW0iLCJpIiwiX2l0ZW0kcXVlcnlTZWxlY3RvciIsImNsYXNzTGlzdCIsInRvZ2dsZSIsImluY2x1ZGVzIiwicXVlcnlTZWxlY3RvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwib3BlbmVkIiwiZHVyYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/ladder1/ladder1.js\n");

/***/ }),

/***/ "./src/blocks/modal/modal.js":
/*!***********************************!*\
  !*** ./src/blocks/modal/modal.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fluejs_noscroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fluejs/noscroll */ \"./node_modules/@fluejs/noscroll/dist/index.mjs\");\n/* harmony import */ var _js_libs_makeModal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/libs/makeModal */ \"./src/js/libs/makeModal.js\");\n\n\n(function () {\n  var modal = (0,_js_libs_makeModal__WEBPACK_IMPORTED_MODULE_0__.makeModal)({\n    preserve: true,\n    init: function init(underlay) {},\n    open: function open(modal, source) {\n      (0,_fluejs_noscroll__WEBPACK_IMPORTED_MODULE_1__.disablePageScroll)();\n    },\n    close: function close() {\n      (0,_fluejs_noscroll__WEBPACK_IMPORTED_MODULE_1__.enablePageScroll)();\n    }\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL21vZGFsL21vZGFsLmpzIiwibWFwcGluZ3MiOiI7OztBQUF1RTtBQUNuQjtBQUVwRCxDQUFDLFlBQU07RUFFTixJQUFNRyxLQUFLLEdBQUdELDZEQUFTLENBQUM7SUFDdkJFLFFBQVEsRUFBRSxJQUFJO0lBQ2RDLElBQUksV0FBSkEsSUFBSUEsQ0FBQ0MsUUFBUSxFQUFFLENBRWYsQ0FBQztJQUNEQyxJQUFJLFdBQUpBLElBQUlBLENBQUNKLEtBQUssRUFBRUssTUFBTSxFQUFFO01BQ25CUixtRUFBaUIsQ0FBQyxDQUFDO0lBRXBCLENBQUM7SUFDRFMsS0FBSyxXQUFMQSxLQUFLQSxDQUFBLEVBQUc7TUFDUFIsa0VBQWdCLENBQUMsQ0FBQztJQUVuQjtFQUNELENBQUMsQ0FBQztBQUVILENBQUMsRUFBRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvYmxvY2tzL21vZGFsL21vZGFsLmpzPzRjNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGlzYWJsZVBhZ2VTY3JvbGwsIGVuYWJsZVBhZ2VTY3JvbGwgfSBmcm9tICdAZmx1ZWpzL25vc2Nyb2xsJztcclxuaW1wb3J0IHsgbWFrZU1vZGFsIH0gZnJvbSBcIi4uLy4uL2pzL2xpYnMvbWFrZU1vZGFsXCI7XHJcblxyXG4oKCkgPT4ge1xyXG5cclxuXHRjb25zdCBtb2RhbCA9IG1ha2VNb2RhbCh7XHJcblx0XHRwcmVzZXJ2ZTogdHJ1ZSxcclxuXHRcdGluaXQodW5kZXJsYXkpIHtcclxuXHJcblx0XHR9LFxyXG5cdFx0b3Blbihtb2RhbCwgc291cmNlKSB7XHJcblx0XHRcdGRpc2FibGVQYWdlU2Nyb2xsKCk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGNsb3NlKCkge1xyXG5cdFx0XHRlbmFibGVQYWdlU2Nyb2xsKCk7XHJcblxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxufSkoKTsiXSwibmFtZXMiOlsiZGlzYWJsZVBhZ2VTY3JvbGwiLCJlbmFibGVQYWdlU2Nyb2xsIiwibWFrZU1vZGFsIiwibW9kYWwiLCJwcmVzZXJ2ZSIsImluaXQiLCJ1bmRlcmxheSIsIm9wZW4iLCJzb3VyY2UiLCJjbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/modal/modal.js\n");

/***/ }),

/***/ "./src/blocks/range1/range1.js":
/*!*************************************!*\
  !*** ./src/blocks/range1/range1.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_libs_tweakerRangeDouble__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/libs/tweakerRangeDouble */ \"./src/js/libs/tweakerRangeDouble.js\");\n\n(function () {\n  document.querySelectorAll('.filter1__range').forEach(function (range) {\n    (0,_js_libs_tweakerRangeDouble__WEBPACK_IMPORTED_MODULE_0__.tweakerRangeDouble)(range, {\n      \"class\": 'range1',\n      input: true\n    });\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL3JhbmdlMS9yYW5nZTEuanMiLCJtYXBwaW5ncyI6Ijs7QUFBc0U7QUFFdEUsQ0FBQyxZQUFNO0VBQ05DLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLFVBQUNDLEtBQUssRUFBSztJQUMvREosK0VBQWtCLENBQUNJLEtBQUssRUFBRTtNQUFFLFNBQU8sUUFBUTtNQUFFQyxLQUFLLEVBQUU7SUFBSyxDQUFDLENBQUM7RUFDNUQsQ0FBQyxDQUFDO0FBRUgsQ0FBQyxFQUFFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndWxwLXNjc3Mtc3RhcnRlci8uL3NyYy9ibG9ja3MvcmFuZ2UxL3JhbmdlMS5qcz9iOWY3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHR3ZWFrZXJSYW5nZURvdWJsZSB9IGZyb20gXCIuLi8uLi9qcy9saWJzL3R3ZWFrZXJSYW5nZURvdWJsZVwiO1xuXG4oKCkgPT4ge1xuXHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZmlsdGVyMV9fcmFuZ2UnKS5mb3JFYWNoKChyYW5nZSkgPT4ge1xuXHRcdHR3ZWFrZXJSYW5nZURvdWJsZShyYW5nZSwgeyBjbGFzczogJ3JhbmdlMScsIGlucHV0OiB0cnVlIH0pO1xuXHR9KTtcblxufSkoKTtcbiJdLCJuYW1lcyI6WyJ0d2Vha2VyUmFuZ2VEb3VibGUiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwicmFuZ2UiLCJpbnB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/range1/range1.js\n");

/***/ }),

/***/ "./src/blocks/range2/range2.js":
/*!*************************************!*\
  !*** ./src/blocks/range2/range2.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_libs_tweakerRangeSingle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/libs/tweakerRangeSingle */ \"./src/js/libs/tweakerRangeSingle.js\");\n\n(function () {\n  document.querySelectorAll('.filter1__range2').forEach(function (range) {\n    (0,_js_libs_tweakerRangeSingle__WEBPACK_IMPORTED_MODULE_0__.tweakerRangeSingle)(range, {\n      \"class\": 'range2'\n    });\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL3JhbmdlMi9yYW5nZTIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBc0U7QUFFdEUsQ0FBQyxZQUFNO0VBQ05DLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsa0JBQWtCLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLFVBQUNDLEtBQUssRUFBSztJQUNoRUosK0VBQWtCLENBQUNJLEtBQUssRUFBRTtNQUFFLFNBQU87SUFBUyxDQUFDLENBQUM7RUFDL0MsQ0FBQyxDQUFDO0FBR0gsQ0FBQyxFQUFFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndWxwLXNjc3Mtc3RhcnRlci8uL3NyYy9ibG9ja3MvcmFuZ2UyL3JhbmdlMi5qcz8wMmJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHR3ZWFrZXJSYW5nZVNpbmdsZSB9IGZyb20gXCIuLi8uLi9qcy9saWJzL3R3ZWFrZXJSYW5nZVNpbmdsZVwiO1xuXG4oKCkgPT4ge1xuXHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZmlsdGVyMV9fcmFuZ2UyJykuZm9yRWFjaCgocmFuZ2UpID0+IHtcblx0XHR0d2Vha2VyUmFuZ2VTaW5nbGUocmFuZ2UsIHsgY2xhc3M6ICdyYW5nZTInIH0pO1xuXHR9KTtcblxuXG59KSgpOyJdLCJuYW1lcyI6WyJ0d2Vha2VyUmFuZ2VTaW5nbGUiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwicmFuZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/range2/range2.js\n");

/***/ }),

/***/ "./src/blocks/search1/search1.js":
/*!***************************************!*\
  !*** ./src/blocks/search1/search1.js ***!
  \***************************************/
/***/ (() => {

eval("(function () {\n  var search = document.querySelector('.search1');\n  search.addEventListener('click', function (e) {\n    if (window.getComputedStyle(e.currentTarget).position == 'relative') e.currentTarget.classList.add('opened');\n  });\n  ['click', 'touchstart'].forEach(function (event) {\n    document.addEventListener(event, function (e) {\n      if (!search.contains(e.target)) search.classList.remove('opened');\n    }, {\n      passive: false\n    });\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL3NlYXJjaDEvc2VhcmNoMS5qcyIsIm5hbWVzIjpbInNlYXJjaCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1cnJlbnRUYXJnZXQiLCJwb3NpdGlvbiIsImNsYXNzTGlzdCIsImFkZCIsImZvckVhY2giLCJldmVudCIsImNvbnRhaW5zIiwidGFyZ2V0IiwicmVtb3ZlIiwicGFzc2l2ZSJdLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvYmxvY2tzL3NlYXJjaDEvc2VhcmNoMS5qcz8xYzdmIl0sInNvdXJjZXNDb250ZW50IjpbIigoKSA9PiB7XG5cdGNvbnN0IHNlYXJjaCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWFyY2gxJyk7XG5cblx0c2VhcmNoLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcblx0XHRpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoZS5jdXJyZW50VGFyZ2V0KS5wb3NpdGlvbiA9PSAncmVsYXRpdmUnKVxuXHRcdFx0ZS5jdXJyZW50VGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ29wZW5lZCcpO1xuXHR9KTtcblx0XHRcblx0WydjbGljaycsJ3RvdWNoc3RhcnQnXS5mb3JFYWNoKGV2ZW50ID0+IHtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBlID0+IHsgXG5cdFx0XHRpZiAoIXNlYXJjaC5jb250YWlucyhlLnRhcmdldCkpIFxuXHRcdFx0XHRzZWFyY2guY2xhc3NMaXN0LnJlbW92ZSgnb3BlbmVkJyk7XG5cdFx0fSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblx0fSk7XG5cbn0pKCk7Il0sIm1hcHBpbmdzIjoiQUFBQSxDQUFDLFlBQU07RUFDTixJQUFNQSxNQUFNLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLFVBQVUsQ0FBQztFQUVqREYsTUFBTSxDQUFDRyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQ0MsQ0FBQyxFQUFLO0lBQ3ZDLElBQUlDLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUNGLENBQUMsQ0FBQ0csYUFBYSxDQUFDLENBQUNDLFFBQVEsSUFBSSxVQUFVLEVBQ2xFSixDQUFDLENBQUNHLGFBQWEsQ0FBQ0UsU0FBUyxDQUFDQyxHQUFHLENBQUMsUUFBUSxDQUFDO0VBQ3pDLENBQUMsQ0FBQztFQUVGLENBQUMsT0FBTyxFQUFDLFlBQVksQ0FBQyxDQUFDQyxPQUFPLENBQUMsVUFBQUMsS0FBSyxFQUFJO0lBQ3ZDWCxRQUFRLENBQUNFLGdCQUFnQixDQUFDUyxLQUFLLEVBQUUsVUFBQVIsQ0FBQyxFQUFJO01BQ3JDLElBQUksQ0FBQ0osTUFBTSxDQUFDYSxRQUFRLENBQUNULENBQUMsQ0FBQ1UsTUFBTSxDQUFDLEVBQzdCZCxNQUFNLENBQUNTLFNBQVMsQ0FBQ00sTUFBTSxDQUFDLFFBQVEsQ0FBQztJQUNuQyxDQUFDLEVBQUU7TUFBRUMsT0FBTyxFQUFFO0lBQU0sQ0FBQyxDQUFDO0VBQ3ZCLENBQUMsQ0FBQztBQUVILENBQUMsRUFBRSxDQUFDIiwiaWdub3JlTGlzdCI6W119\n//# sourceURL=webpack-internal:///./src/blocks/search1/search1.js\n");

/***/ }),

/***/ "./src/blocks/select1/select1.js":
/*!***************************************!*\
  !*** ./src/blocks/select1/select1.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_libs_tweakerSelect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/libs/tweakerSelect */ \"./src/js/libs/tweakerSelect.js\");\n\n(function () {\n  (0,_js_libs_tweakerSelect__WEBPACK_IMPORTED_MODULE_0__.tweakerSelect)(document.querySelectorAll('select.catalog1__select'), {\n    name: 'select1'\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL3NlbGVjdDEvc2VsZWN0MS5qcyIsIm1hcHBpbmdzIjoiOztBQUE0RDtBQUU1RCxDQUFDLFlBQU07RUFDTkEscUVBQWEsQ0FBQ0MsUUFBUSxDQUFDQyxnQkFBZ0IsQ0FBQyx5QkFBeUIsQ0FBQyxFQUFFO0lBQUVDLElBQUksRUFBRTtFQUFVLENBQUMsQ0FBQztBQUV6RixDQUFDLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2d1bHAtc2Nzcy1zdGFydGVyLy4vc3JjL2Jsb2Nrcy9zZWxlY3QxL3NlbGVjdDEuanM/MGVkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0d2Vha2VyU2VsZWN0IH0gZnJvbSBcIi4uLy4uL2pzL2xpYnMvdHdlYWtlclNlbGVjdFwiO1xuXG4oKCkgPT4ge1xuXHR0d2Vha2VyU2VsZWN0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdC5jYXRhbG9nMV9fc2VsZWN0JyksIHsgbmFtZTogJ3NlbGVjdDEnIH0pO1xuXG59KSgpOyJdLCJuYW1lcyI6WyJ0d2Vha2VyU2VsZWN0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/select1/select1.js\n");

/***/ }),

/***/ "./src/blocks/select2/select2.js":
/*!***************************************!*\
  !*** ./src/blocks/select2/select2.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_libs_tweakerSelect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/libs/tweakerSelect */ \"./src/js/libs/tweakerSelect.js\");\n\n(function () {\n  (0,_js_libs_tweakerSelect__WEBPACK_IMPORTED_MODULE_0__.tweakerSelect)(document.querySelectorAll('select.pagination1__select'), {\n    name: 'select2'\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL3NlbGVjdDIvc2VsZWN0Mi5qcyIsIm1hcHBpbmdzIjoiOztBQUE0RDtBQUU1RCxDQUFDLFlBQU07RUFDTkEscUVBQWEsQ0FBQ0MsUUFBUSxDQUFDQyxnQkFBZ0IsQ0FBQyw0QkFBNEIsQ0FBQyxFQUFFO0lBQUVDLElBQUksRUFBRTtFQUFVLENBQUMsQ0FBQztBQUU1RixDQUFDLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2d1bHAtc2Nzcy1zdGFydGVyLy4vc3JjL2Jsb2Nrcy9zZWxlY3QyL3NlbGVjdDIuanM/NzQwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0d2Vha2VyU2VsZWN0IH0gZnJvbSBcIi4uLy4uL2pzL2xpYnMvdHdlYWtlclNlbGVjdFwiO1xuXG4oKCkgPT4ge1xuXHR0d2Vha2VyU2VsZWN0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdC5wYWdpbmF0aW9uMV9fc2VsZWN0JyksIHsgbmFtZTogJ3NlbGVjdDInIH0pO1xuXG59KSgpOyJdLCJuYW1lcyI6WyJ0d2Vha2VyU2VsZWN0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/select2/select2.js\n");

/***/ }),

/***/ "./src/blocks/sidebar1/sidebar1.js":
/*!*****************************************!*\
  !*** ./src/blocks/sidebar1/sidebar1.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fluejs_noscroll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fluejs/noscroll */ \"./node_modules/@fluejs/noscroll/dist/index.mjs\");\n/* harmony import */ var _js_libs_driveSidebar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/libs/driveSidebar */ \"./src/js/libs/driveSidebar.js\");\n/* harmony import */ var _js_libs_driveMenu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../js/libs/driveMenu */ \"./src/js/libs/driveMenu.js\");\n\n\n\n(function () {\n  var sidebar = document.querySelector('.sidebar1');\n  if (!sidebar) return;\n  var toggles = sidebar.querySelectorAll('.sidebar1__toggle, .sidebar1__close');\n  var aside = (0,_js_libs_driveMenu__WEBPACK_IMPORTED_MODULE_1__.driveMenu)(sidebar, toggles, {\n    omitToClose: '.modal',\n    \"class\": 'opened',\n    open: function open() {\n      (0,_fluejs_noscroll__WEBPACK_IMPORTED_MODULE_2__.disablePageScroll)();\n      document.body.classList.add('underlay');\n    },\n    close: function close() {\n      (0,_fluejs_noscroll__WEBPACK_IMPORTED_MODULE_2__.enablePageScroll)();\n      document.body.classList.add('underlay_closing');\n      this.addEventListener('transitionend', function (e) {\n        document.body.classList.remove('underlay', 'underlay_closing');\n      }, {\n        once: true\n      });\n    }\n  });\n  sidebar.addEventListener('swiped-right', function (e) {\n    return aside.menuClose(e);\n  });\n  (0,_js_libs_driveSidebar__WEBPACK_IMPORTED_MODULE_0__.driveSidebar)(sidebar.querySelector('.sidebar1__inner'));\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmxvY2tzL3NpZGViYXIxL3NpZGViYXIxLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBdUU7QUFDYjtBQUNOO0FBRXBELENBQUMsWUFBTTtFQUNOLElBQU1JLE9BQU8sR0FBR0MsUUFBUSxDQUFDQyxhQUFhLENBQUMsV0FBVyxDQUFDO0VBQ25ELElBQUcsQ0FBQ0YsT0FBTyxFQUFFO0VBRWIsSUFBTUcsT0FBTyxHQUFHSCxPQUFPLENBQUNJLGdCQUFnQixDQUFDLHFDQUFxQyxDQUFDO0VBRS9FLElBQU1DLEtBQUssR0FBR04sNkRBQVMsQ0FBQ0MsT0FBTyxFQUFFRyxPQUFPLEVBQUU7SUFDekNHLFdBQVcsRUFBRSxRQUFRO0lBQ3JCLFNBQU8sUUFBUTtJQUNmQyxJQUFJLEVBQUUsU0FBTkEsSUFBSUEsQ0FBQSxFQUFhO01BQ2hCWCxtRUFBaUIsQ0FBQyxDQUFDO01BQ25CSyxRQUFRLENBQUNPLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxHQUFHLENBQUMsVUFBVSxDQUFDO0lBRXhDLENBQUM7SUFDREMsS0FBSyxFQUFFLFNBQVBBLEtBQUtBLENBQUEsRUFBYTtNQUNqQmQsa0VBQWdCLENBQUMsQ0FBQztNQUNsQkksUUFBUSxDQUFDTyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDLGtCQUFrQixDQUFDO01BRS9DLElBQUksQ0FBQ0UsZ0JBQWdCLENBQUMsZUFBZSxFQUFFLFVBQUFDLENBQUMsRUFBSTtRQUMzQ1osUUFBUSxDQUFDTyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0ssTUFBTSxDQUFDLFVBQVUsRUFBRSxrQkFBa0IsQ0FBQztNQUMvRCxDQUFDLEVBQUU7UUFBRUMsSUFBSSxFQUFFO01BQUssQ0FBQyxDQUFDO0lBQ25CO0VBQ0QsQ0FBQyxDQUFDO0VBRUZmLE9BQU8sQ0FBQ1ksZ0JBQWdCLENBQUMsY0FBYyxFQUFFLFVBQUNDLENBQUM7SUFBQSxPQUFLUixLQUFLLENBQUNXLFNBQVMsQ0FBQ0gsQ0FBQyxDQUFDO0VBQUEsRUFBQztFQUNuRWYsbUVBQVksQ0FBQ0UsT0FBTyxDQUFDRSxhQUFhLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUV4RCxDQUFDLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2d1bHAtc2Nzcy1zdGFydGVyLy4vc3JjL2Jsb2Nrcy9zaWRlYmFyMS9zaWRlYmFyMS5qcz9lZWM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRpc2FibGVQYWdlU2Nyb2xsLCBlbmFibGVQYWdlU2Nyb2xsIH0gZnJvbSAnQGZsdWVqcy9ub3Njcm9sbCc7XG5pbXBvcnQgeyBkcml2ZVNpZGViYXIgfSBmcm9tIFwiLi4vLi4vanMvbGlicy9kcml2ZVNpZGViYXJcIjtcbmltcG9ydCB7IGRyaXZlTWVudSB9IGZyb20gXCIuLi8uLi9qcy9saWJzL2RyaXZlTWVudVwiO1xuXG4oKCkgPT4ge1xuXHRjb25zdCBzaWRlYmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNpZGViYXIxJyk7XG5cdGlmKCFzaWRlYmFyKSByZXR1cm47XG5cblx0Y29uc3QgdG9nZ2xlcyA9IHNpZGViYXIucXVlcnlTZWxlY3RvckFsbCgnLnNpZGViYXIxX190b2dnbGUsIC5zaWRlYmFyMV9fY2xvc2UnKTtcblxuXHRjb25zdCBhc2lkZSA9IGRyaXZlTWVudShzaWRlYmFyLCB0b2dnbGVzLCB7XG5cdFx0b21pdFRvQ2xvc2U6ICcubW9kYWwnLFxuXHRcdGNsYXNzOiAnb3BlbmVkJyxcblx0XHRvcGVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRpc2FibGVQYWdlU2Nyb2xsKCk7XG5cdFx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3VuZGVybGF5Jyk7XG5cblx0XHR9LFxuXHRcdGNsb3NlOiBmdW5jdGlvbigpIHtcblx0XHRcdGVuYWJsZVBhZ2VTY3JvbGwoKTtcblx0XHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgndW5kZXJsYXlfY2xvc2luZycpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBlID0+IHtcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd1bmRlcmxheScsICd1bmRlcmxheV9jbG9zaW5nJyk7XG5cdFx0XHR9LCB7IG9uY2U6IHRydWUgfSk7XG5cdFx0fVxuXHR9KTtcblxuXHRzaWRlYmFyLmFkZEV2ZW50TGlzdGVuZXIoJ3N3aXBlZC1yaWdodCcsIChlKSA9PiBhc2lkZS5tZW51Q2xvc2UoZSkpO1xuXHRkcml2ZVNpZGViYXIoc2lkZWJhci5xdWVyeVNlbGVjdG9yKCcuc2lkZWJhcjFfX2lubmVyJykpO1xuXG59KSgpOyJdLCJuYW1lcyI6WyJkaXNhYmxlUGFnZVNjcm9sbCIsImVuYWJsZVBhZ2VTY3JvbGwiLCJkcml2ZVNpZGViYXIiLCJkcml2ZU1lbnUiLCJzaWRlYmFyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidG9nZ2xlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJhc2lkZSIsIm9taXRUb0Nsb3NlIiwib3BlbiIsImJvZHkiLCJjbGFzc0xpc3QiLCJhZGQiLCJjbG9zZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicmVtb3ZlIiwib25jZSIsIm1lbnVDbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/sidebar1/sidebar1.js\n");

/***/ }),

/***/ "./src/js/blocks.js":
/*!**************************!*\
  !*** ./src/js/blocks.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _blocks_header1_header1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../blocks/header1/header1.js */ \"./src/blocks/header1/header1.js\");\n/* harmony import */ var _blocks_search1_search1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../blocks/search1/search1.js */ \"./src/blocks/search1/search1.js\");\n/* harmony import */ var _blocks_search1_search1_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_blocks_search1_search1_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _blocks_sidebar1_sidebar1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../blocks/sidebar1/sidebar1.js */ \"./src/blocks/sidebar1/sidebar1.js\");\n/* harmony import */ var _blocks_filter1_filter1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../blocks/filter1/filter1.js */ \"./src/blocks/filter1/filter1.js\");\n/* harmony import */ var _blocks_ladder1_ladder1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../blocks/ladder1/ladder1.js */ \"./src/blocks/ladder1/ladder1.js\");\n/* harmony import */ var _blocks_select1_select1_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../blocks/select1/select1.js */ \"./src/blocks/select1/select1.js\");\n/* harmony import */ var _blocks_select2_select2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../blocks/select2/select2.js */ \"./src/blocks/select2/select2.js\");\n/* harmony import */ var _blocks_range1_range1_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../blocks/range1/range1.js */ \"./src/blocks/range1/range1.js\");\n/* harmony import */ var _blocks_range2_range2_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../blocks/range2/range2.js */ \"./src/blocks/range2/range2.js\");\n/* harmony import */ var _blocks_modal_modal_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../blocks/modal/modal.js */ \"./src/blocks/modal/modal.js\");\n/* harmony import */ var _blocks_form1_form1_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../blocks/form1/form1.js */ \"./src/blocks/form1/form1.js\");\n/* harmony import */ var _blocks_card1_card1_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../blocks/card1/card1.js */ \"./src/blocks/card1/card1.js\");\n/* harmony import */ var _blocks_card1_card1_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_blocks_card1_card1_js__WEBPACK_IMPORTED_MODULE_11__);\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYmxvY2tzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvanMvYmxvY2tzLmpzPzVlM2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiLi4vYmxvY2tzL2hlYWRlcjEvaGVhZGVyMS5qc1wiO1xyXG5pbXBvcnQgXCIuLi9ibG9ja3Mvc2VhcmNoMS9zZWFyY2gxLmpzXCI7XHJcbmltcG9ydCBcIi4uL2Jsb2Nrcy9zaWRlYmFyMS9zaWRlYmFyMS5qc1wiO1xyXG5pbXBvcnQgXCIuLi9ibG9ja3MvZmlsdGVyMS9maWx0ZXIxLmpzXCI7XHJcbmltcG9ydCBcIi4uL2Jsb2Nrcy9sYWRkZXIxL2xhZGRlcjEuanNcIjtcclxuaW1wb3J0IFwiLi4vYmxvY2tzL3NlbGVjdDEvc2VsZWN0MS5qc1wiO1xyXG5pbXBvcnQgXCIuLi9ibG9ja3Mvc2VsZWN0Mi9zZWxlY3QyLmpzXCI7XHJcbmltcG9ydCBcIi4uL2Jsb2Nrcy9yYW5nZTEvcmFuZ2UxLmpzXCI7XHJcbmltcG9ydCBcIi4uL2Jsb2Nrcy9yYW5nZTIvcmFuZ2UyLmpzXCI7XHJcbmltcG9ydCBcIi4uL2Jsb2Nrcy9tb2RhbC9tb2RhbC5qc1wiO1xyXG5pbXBvcnQgXCIuLi9ibG9ja3MvZm9ybTEvZm9ybTEuanNcIjtcclxuaW1wb3J0IFwiLi4vYmxvY2tzL2NhcmQxL2NhcmQxLmpzXCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/blocks.js\n");

/***/ }),

/***/ "./src/js/common.js":
/*!**************************!*\
  !*** ./src/js/common.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _libs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/utils */ \"./src/js/libs/utils.js\");\n/* harmony import */ var _libs_driveAdaptive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/driveAdaptive.js */ \"./src/js/libs/driveAdaptive.js\");\n/* harmony import */ var _node_modules_swiped_events_dist_swiped_events_min_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/swiped-events/dist/swiped-events.min.js */ \"./node_modules/swiped-events/dist/swiped-events.min.js\");\n/* harmony import */ var _node_modules_swiped_events_dist_swiped_events_min_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_swiped_events_dist_swiped_events_min_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _polyfills_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polyfills.js */ \"./src/js/polyfills.js\");\n/* harmony import */ var _polyfills_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_polyfills_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _blocks_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./blocks.js */ \"./src/js/blocks.js\");\n\n\n\n\n\n\n/* Тут можно писать код общий для всего проекта и требующий единого пространства имен */\n\nfunction updateVH() {\n  var _window$visualViewpor;\n  var vh = (((_window$visualViewpor = window.visualViewport) === null || _window$visualViewpor === void 0 ? void 0 : _window$visualViewpor.height) || window.innerHeight) * 0.01;\n  document.documentElement.style.setProperty('--vh', \"\".concat(vh, \"px\"));\n}\nwindow.addEventListener('resize', (0,_libs_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(updateVH, 200), {\n  passive: true\n});\nupdateVH();\n\n// Динамический адаптив\nnew _libs_driveAdaptive_js__WEBPACK_IMPORTED_MODULE_1__.driveAdaptive({\n  type: 'max',\n  className: 'moved',\n  aliases: {\n    xxxs: 360,\n    xxs: 480,\n    xs: 640,\n    sm: 780,\n    md: 960,\n    lg: 1100,\n    xlg: 1280,\n    xxlg: 1440,\n    xxxlg: 1680,\n    xxxxlg: 1920\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXdDO0FBQ2dCO0FBQ1k7QUFDNUM7QUFDSDs7QUFFckI7O0FBRUEsU0FBU0UsUUFBUUEsQ0FBQSxFQUFHO0VBQUEsSUFBQUMscUJBQUE7RUFDbkIsSUFBTUMsRUFBRSxHQUFHLENBQUMsRUFBQUQscUJBQUEsR0FBQUUsTUFBTSxDQUFDQyxjQUFjLGNBQUFILHFCQUFBLHVCQUFyQkEscUJBQUEsQ0FBdUJJLE1BQU0sS0FBSUYsTUFBTSxDQUFDRyxXQUFXLElBQUksSUFBSTtFQUN2RUMsUUFBUSxDQUFDQyxlQUFlLENBQUNDLEtBQUssQ0FBQ0MsV0FBVyxDQUFDLE1BQU0sS0FBQUMsTUFBQSxDQUFLVCxFQUFFLE9BQUksQ0FBQztBQUM5RDtBQUVBQyxNQUFNLENBQUNTLGdCQUFnQixDQUFDLFFBQVEsRUFBRWQscURBQVEsQ0FBQ0UsUUFBUSxFQUFFLEdBQUcsQ0FBQyxFQUFFO0VBQUVhLE9BQU8sRUFBRTtBQUFLLENBQUMsQ0FBQztBQUM3RWIsUUFBUSxDQUFDLENBQUM7O0FBRVY7QUFDQSxJQUFJRCxpRUFBYSxDQUFDO0VBQ2pCZSxJQUFJLEVBQUUsS0FBSztFQUNYQyxTQUFTLEVBQUUsT0FBTztFQUNsQkMsT0FBTyxFQUFFO0lBQ1JDLElBQUksRUFBRSxHQUFHO0lBQ1RDLEdBQUcsRUFBRSxHQUFHO0lBQ1JDLEVBQUUsRUFBRSxHQUFHO0lBQ1BDLEVBQUUsRUFBRSxHQUFHO0lBQ1BDLEVBQUUsRUFBRSxHQUFHO0lBQ1BDLEVBQUUsRUFBRSxJQUFJO0lBQ1JDLEdBQUcsRUFBRSxJQUFJO0lBQ1RDLElBQUksRUFBRSxJQUFJO0lBQ1ZDLEtBQUssRUFBRSxJQUFJO0lBQ1hDLE1BQU0sRUFBRTtFQUNUO0FBQ0QsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvanMvY29tbW9uLmpzPzQ0MGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdGhyb3R0bGUgfSBmcm9tIFwiLi9saWJzL3V0aWxzXCI7XHJcbmltcG9ydCB7IGRyaXZlQWRhcHRpdmUgfSBmcm9tIFwiLi9saWJzL2RyaXZlQWRhcHRpdmUuanNcIjtcclxuaW1wb3J0IFwiLi4vLi4vbm9kZV9tb2R1bGVzL3N3aXBlZC1ldmVudHMvZGlzdC9zd2lwZWQtZXZlbnRzLm1pbi5qc1wiO1xyXG5pbXBvcnQgXCIuL3BvbHlmaWxscy5qc1wiO1xyXG5pbXBvcnQgXCIuL2Jsb2Nrcy5qc1wiO1xyXG5cclxuLyog0KLRg9GCINC80L7QttC90L4g0L/QuNGB0LDRgtGMINC60L7QtCDQvtCx0YnQuNC5INC00LvRjyDQstGB0LXQs9C+INC/0YDQvtC10LrRgtCwINC4INGC0YDQtdCx0YPRjtGJ0LjQuSDQtdC00LjQvdC+0LPQviDQv9GA0L7RgdGC0YDQsNC90YHRgtCy0LAg0LjQvNC10L0gKi9cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVZIKCkge1xyXG5cdGNvbnN0IHZoID0gKHdpbmRvdy52aXN1YWxWaWV3cG9ydD8uaGVpZ2h0IHx8IHdpbmRvdy5pbm5lckhlaWdodCkgKiAwLjAxO1xyXG5cdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12aCcsIGAke3ZofXB4YCk7XHJcbn1cclxuXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aHJvdHRsZSh1cGRhdGVWSCwgMjAwKSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG51cGRhdGVWSCgpO1xyXG5cclxuLy8g0JTQuNC90LDQvNC40YfQtdGB0LrQuNC5INCw0LTQsNC/0YLQuNCyXHJcbm5ldyBkcml2ZUFkYXB0aXZlKHtcclxuXHR0eXBlOiAnbWF4JyxcclxuXHRjbGFzc05hbWU6ICdtb3ZlZCcsXHJcblx0YWxpYXNlczoge1xyXG5cdFx0eHh4czogMzYwLFxyXG5cdFx0eHhzOiA0ODAsXHJcblx0XHR4czogNjQwLFxyXG5cdFx0c206IDc4MCxcclxuXHRcdG1kOiA5NjAsXHJcblx0XHRsZzogMTEwMCxcclxuXHRcdHhsZzogMTI4MCxcclxuXHRcdHh4bGc6IDE0NDAsXHJcblx0XHR4eHhsZzogMTY4MCxcclxuXHRcdHh4eHhsZzogMTkyMFxyXG5cdH1cclxufSk7Il0sIm5hbWVzIjpbInRocm90dGxlIiwiZHJpdmVBZGFwdGl2ZSIsInVwZGF0ZVZIIiwiX3dpbmRvdyR2aXN1YWxWaWV3cG9yIiwidmgiLCJ3aW5kb3ciLCJ2aXN1YWxWaWV3cG9ydCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsInNldFByb3BlcnR5IiwiY29uY2F0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJ0eXBlIiwiY2xhc3NOYW1lIiwiYWxpYXNlcyIsInh4eHMiLCJ4eHMiLCJ4cyIsInNtIiwibWQiLCJsZyIsInhsZyIsInh4bGciLCJ4eHhsZyIsInh4eHhsZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/common.js\n");

/***/ }),

/***/ "./src/js/libs/driveAdaptive.js":
/*!**************************************!*\
  !*** ./src/js/libs/driveAdaptive.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   driveAdaptive: () => (/* binding */ driveAdaptive)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nvar _driveAdaptive_brand = /*#__PURE__*/new WeakSet();\n/**\r\n * Класс для адаптивного перемещения DOM-элементов в зависимости от ширины экрана.\r\n * Работает на основе data-атрибута и может использовать псевдонимы брейкпоинтов.\r\n * При достижении указанного брейкпоинта, элемент перемещается в целевой контейнер,\r\n * в заданную позицию. Когда условие не выполняется — возвращается на исходную позицию.\r\n * \r\n * Пример HTML:\r\n * <div data-moved=\".target, md, first\">Контент</div>\r\n * <div class=\"target\"></div>\r\n * \r\n * Пример JS:\r\n * const move = new driveAdaptive({\r\n *   type: \"max\", // или \"min\"\r\n *   movedClass: \"moved\",\r\n *   aliases: { md: 960, lg: 1280 }\r\n * });\r\n * \r\n * Синтаксис атрибута:\r\n * data-moved=\"селектор, брейкпоинт, позиция\"\r\n *   - селектор: CSS-селектор контейнера-приемника\r\n *   - брейкпоинт: число или псевдоним\r\n *   - позиция: \"first\", \"last\" или индекс\r\n * \r\n * Значения по умолчанию:\r\n *   - брейкпоинт = \"780\"\r\n *   - позиция = \"last\"\r\n *\r\n * Можно вызывать .init() повторно, если DOM обновился.\r\n */\n\nvar driveAdaptive = /*#__PURE__*/function () {\n  function driveAdaptive(_ref) {\n    var _ref$type = _ref.type,\n      type = _ref$type === void 0 ? \"max\" : _ref$type,\n      _ref$movedClass = _ref.movedClass,\n      movedClass = _ref$movedClass === void 0 ? \"moved\" : _ref$movedClass,\n      _ref$aliases = _ref.aliases,\n      aliases = _ref$aliases === void 0 ? {} : _ref$aliases;\n    _classCallCheck(this, driveAdaptive);\n    // Преобразование псевдонима брейкпоинта в значение, если определено в настройках\n    _classPrivateMethodInitSpec(this, _driveAdaptive_brand);\n    this.type = type; // Тип адаптации: 'min' или 'max'\n    this.movedClass = movedClass;\n    this.aliases = aliases; // Дополнительные псевдонимы для брейкпоинтов\n    this.nodes = document.querySelectorAll(\"[data-\".concat(movedClass, \"]\"));\n    this.objects = []; // Массив объектов с описанием перемещаемых элементов\n\n    this.init(); // Инициализация при создании экземпляра\n  }\n  return _createClass(driveAdaptive, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n      this.objects = Array.from(this.nodes).map(function (node) {\n        var _assertClassBrand$cal;\n        var _node$dataset$_this$m = node.dataset[_this.movedClass].trim().split(\",\").map(function (s) {\n            return s.trim();\n          }),\n          _node$dataset$_this$m2 = _slicedToArray(_node$dataset$_this$m, 3),\n          selector = _node$dataset$_this$m2[0],\n          _node$dataset$_this$m3 = _node$dataset$_this$m2[1],\n          rawBreakpoint = _node$dataset$_this$m3 === void 0 ? \"780\" : _node$dataset$_this$m3,\n          _node$dataset$_this$m4 = _node$dataset$_this$m2[2],\n          place = _node$dataset$_this$m4 === void 0 ? \"last\" : _node$dataset$_this$m4;\n        var destination = document.querySelector(selector) || console.warn(\"adaptiveMove: destination selector '\".concat(selector, \"' not found.\"));\n        return {\n          element: node,\n          parent: node.parentNode,\n          destination: destination,\n          index: _assertClassBrand(_driveAdaptive_brand, _this, _indexInParent).call(_this, node.parentNode, node),\n          breakpoint: (_assertClassBrand$cal = _assertClassBrand(_driveAdaptive_brand, _this, _resolveBreakpoint).call(_this, rawBreakpoint)) !== null && _assertClassBrand$cal !== void 0 ? _assertClassBrand$cal : rawBreakpoint,\n          place: place\n        };\n      });\n      _assertClassBrand(_driveAdaptive_brand, this, _arraySort).call(this, this.objects); // Сортировка по условиям\n\n      this.mediaQueries = _toConsumableArray(new Set(this.objects.map(function (item) {\n        return \"(\".concat(_this.type, \"-width: \").concat(item.breakpoint, \"px),\").concat(item.breakpoint);\n      })));\n      this.mediaQueries.forEach(function (media) {\n        var _media$split = media.split(\",\"),\n          _media$split2 = _slicedToArray(_media$split, 2),\n          mediaQuery = _media$split2[0],\n          breakpoint = _media$split2[1];\n        var matchMedia = window.matchMedia(mediaQuery);\n        var relevantObjects = _this.objects.filter(function (obj) {\n          return obj.breakpoint === breakpoint;\n        });\n        matchMedia.addEventListener(\"change\", function () {\n          return _assertClassBrand(_driveAdaptive_brand, _this, _mediaHandler).call(_this, matchMedia, relevantObjects);\n        });\n        _assertClassBrand(_driveAdaptive_brand, _this, _mediaHandler).call(_this, matchMedia, relevantObjects); // Первичная проверка\n      });\n    }\n  }]);\n}();\nfunction _resolveBreakpoint(value) {\n  return Object.prototype.hasOwnProperty.call(this.aliases, value) ? this.aliases[value].toString() : undefined;\n}\n// Обработчик медиа-запроса: перемещение или возврат элементов\nfunction _mediaHandler(matchMedia, objects) {\n  var _this2 = this;\n  if (matchMedia.matches) {\n    objects.forEach(function (obj) {\n      if (!obj.destination) return; // Fail-safe: пропустить, если нет места назначения\n\n      obj.index = _assertClassBrand(_driveAdaptive_brand, _this2, _indexInParent).call(_this2, obj.parent, obj.element);\n      _assertClassBrand(_driveAdaptive_brand, _this2, _moveTo).call(_this2, obj.place, obj.element, obj.destination);\n    });\n  } else {\n    for (var i = objects.length - 1; i >= 0; i--) {\n      var obj = objects[i];\n      if (obj.element.classList.contains(this.movedClass)) {\n        _assertClassBrand(_driveAdaptive_brand, this, _moveBack).call(this, obj.parent, obj.element, obj.index);\n      }\n    }\n  }\n}\n// Перемещение элемента\nfunction _moveTo(place, element, destination) {\n  element.classList.add(this.movedClass);\n  if (place === \"last\" || place >= destination.children.length) {\n    destination.append(element);\n  } else if (place === \"first\") {\n    destination.prepend(element);\n  } else {\n    destination.children[place].before(element);\n  }\n}\n// Возврат элемента на исходное место\nfunction _moveBack(parent, element, index) {\n  element.classList.remove(this.movedClass);\n  if (parent.children[index] !== undefined) {\n    parent.children[index].before(element);\n  } else {\n    parent.append(element);\n  }\n}\n// Получение индекса элемента в родителе\nfunction _indexInParent(parent, element) {\n  return _toConsumableArray(parent.children).indexOf(element);\n}\n// Сортировка массива по breakpoint и place\nfunction _arraySort(arr) {\n  var _this3 = this;\n  var priority = function priority(place) {\n    if (place === \"first\") return -1;\n    if (place === \"last\") return 9999;\n    return parseInt(place, 10);\n  };\n  arr.sort(function (a, b) {\n    if (a.breakpoint === b.breakpoint) {\n      return _this3.type === \"min\" ? priority(a.place) - priority(b.place) : priority(b.place) - priority(a.place);\n    }\n    return _this3.type === \"min\" ? a.breakpoint - b.breakpoint : b.breakpoint - a.breakpoint;\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SyxDQUFDLEdBQUdxRCxRQUFRLENBQUNJLENBQUMsQ0FBQ3pELEtBQUssQ0FBQyxHQUNyQ3FELFFBQVEsQ0FBQ0ksQ0FBQyxDQUFDekQsS0FBSyxDQUFDLEdBQUdxRCxRQUFRLENBQUNHLENBQUMsQ0FBQ3hELEtBQUssQ0FBQztJQUN6QztJQUNBLE9BQU9vRCxNQUFJLENBQUN0RixJQUFJLEtBQUssS0FBSyxHQUN2QjBGLENBQUMsQ0FBQzVDLFVBQVUsR0FBRzZDLENBQUMsQ0FBQzdDLFVBQVUsR0FDM0I2QyxDQUFDLENBQUM3QyxVQUFVLEdBQUc0QyxDQUFDLENBQUM1QyxVQUFVO0VBQy9CLENBQUMsQ0FBQztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvanMvbGlicy9kcml2ZUFkYXB0aXZlLmpzP2VjMTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqINCa0LvQsNGB0YEg0LTQu9GPINCw0LTQsNC/0YLQuNCy0L3QvtCz0L4g0L/QtdGA0LXQvNC10YnQtdC90LjRjyBET00t0Y3Qu9C10LzQtdC90YLQvtCyINCyINC30LDQstC40YHQuNC80L7RgdGC0Lgg0L7RgiDRiNC40YDQuNC90Ysg0Y3QutGA0LDQvdCwLlxyXG4gKiDQoNCw0LHQvtGC0LDQtdGCINC90LAg0L7RgdC90L7QstC1IGRhdGEt0LDRgtGA0LjQsdGD0YLQsCDQuCDQvNC+0LbQtdGCINC40YHQv9C+0LvRjNC30L7QstCw0YLRjCDQv9GB0LXQstC00L7QvdC40LzRiyDQsdGA0LXQudC60L/QvtC40L3RgtC+0LIuXHJcbiAqINCf0YDQuCDQtNC+0YHRgtC40LbQtdC90LjQuCDRg9C60LDQt9Cw0L3QvdC+0LPQviDQsdGA0LXQudC60L/QvtC40L3RgtCwLCDRjdC70LXQvNC10L3RgiDQv9C10YDQtdC80LXRidCw0LXRgtGB0Y8g0LIg0YbQtdC70LXQstC+0Lkg0LrQvtC90YLQtdC50L3QtdGALFxyXG4gKiDQsiDQt9Cw0LTQsNC90L3Rg9GOINC/0L7Qt9C40YbQuNGOLiDQmtC+0LPQtNCwINGD0YHQu9C+0LLQuNC1INC90LUg0LLRi9C/0L7Qu9C90Y/QtdGC0YHRjyDigJQg0LLQvtC30LLRgNCw0YnQsNC10YLRgdGPINC90LAg0LjRgdGF0L7QtNC90YPRjiDQv9C+0LfQuNGG0LjRji5cclxuICogXHJcbiAqINCf0YDQuNC80LXRgCBIVE1MOlxyXG4gKiA8ZGl2IGRhdGEtbW92ZWQ9XCIudGFyZ2V0LCBtZCwgZmlyc3RcIj7QmtC+0L3RgtC10L3RgjwvZGl2PlxyXG4gKiA8ZGl2IGNsYXNzPVwidGFyZ2V0XCI+PC9kaXY+XHJcbiAqIFxyXG4gKiDQn9GA0LjQvNC10YAgSlM6XHJcbiAqIGNvbnN0IG1vdmUgPSBuZXcgZHJpdmVBZGFwdGl2ZSh7XHJcbiAqICAgdHlwZTogXCJtYXhcIiwgLy8g0LjQu9C4IFwibWluXCJcclxuICogICBtb3ZlZENsYXNzOiBcIm1vdmVkXCIsXHJcbiAqICAgYWxpYXNlczogeyBtZDogOTYwLCBsZzogMTI4MCB9XHJcbiAqIH0pO1xyXG4gKiBcclxuICog0KHQuNC90YLQsNC60YHQuNGBINCw0YLRgNC40LHRg9GC0LA6XHJcbiAqIGRhdGEtbW92ZWQ9XCLRgdC10LvQtdC60YLQvtGALCDQsdGA0LXQudC60L/QvtC40L3Rgiwg0L/QvtC30LjRhtC40Y9cIlxyXG4gKiAgIC0g0YHQtdC70LXQutGC0L7RgDogQ1NTLdGB0LXQu9C10LrRgtC+0YAg0LrQvtC90YLQtdC50L3QtdGA0LAt0L/RgNC40LXQvNC90LjQutCwXHJcbiAqICAgLSDQsdGA0LXQudC60L/QvtC40L3Rgjog0YfQuNGB0LvQviDQuNC70Lgg0L/RgdC10LLQtNC+0L3QuNC8XHJcbiAqICAgLSDQv9C+0LfQuNGG0LjRjzogXCJmaXJzdFwiLCBcImxhc3RcIiDQuNC70Lgg0LjQvdC00LXQutGBXHJcbiAqIFxyXG4gKiDQl9C90LDRh9C10L3QuNGPINC/0L4g0YPQvNC+0LvRh9Cw0L3QuNGOOlxyXG4gKiAgIC0g0LHRgNC10LnQutC/0L7QuNC90YIgPSBcIjc4MFwiXHJcbiAqICAgLSDQv9C+0LfQuNGG0LjRjyA9IFwibGFzdFwiXHJcbiAqXHJcbiAqINCc0L7QttC90L4g0LLRi9C30YvQstCw0YLRjCAuaW5pdCgpINC/0L7QstGC0L7RgNC90L4sINC10YHQu9C4IERPTSDQvtCx0L3QvtCy0LjQu9GB0Y8uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIGRyaXZlQWRhcHRpdmUge1xyXG5cdGNvbnN0cnVjdG9yKHt0eXBlID0gXCJtYXhcIiwgbW92ZWRDbGFzcyA9IFwibW92ZWRcIiwgYWxpYXNlcyA9IHt9fSkge1xyXG5cdFx0dGhpcy50eXBlID0gdHlwZTsgLy8g0KLQuNC/INCw0LTQsNC/0YLQsNGG0LjQuDogJ21pbicg0LjQu9C4ICdtYXgnXHJcblx0XHR0aGlzLm1vdmVkQ2xhc3MgPSBtb3ZlZENsYXNzO1xyXG5cdFx0dGhpcy5hbGlhc2VzID0gYWxpYXNlczsgLy8g0JTQvtC/0L7Qu9C90LjRgtC10LvRjNC90YvQtSDQv9GB0LXQstC00L7QvdC40LzRiyDQtNC70Y8g0LHRgNC10LnQutC/0L7QuNC90YLQvtCyXHJcblx0XHR0aGlzLm5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtJHttb3ZlZENsYXNzfV1gKTtcclxuXHRcdHRoaXMub2JqZWN0cyA9IFtdOyAvLyDQnNCw0YHRgdC40LIg0L7QsdGK0LXQutGC0L7QsiDRgSDQvtC/0LjRgdCw0L3QuNC10Lwg0L/QtdGA0LXQvNC10YnQsNC10LzRi9GFINGN0LvQtdC80LXQvdGC0L7QslxyXG5cclxuXHRcdHRoaXMuaW5pdCgpOyAvLyDQmNC90LjRhtC40LDQu9C40LfQsNGG0LjRjyDQv9GA0Lgg0YHQvtC30LTQsNC90LjQuCDRjdC60LfQtdC80L/Qu9GP0YDQsFxyXG5cdH1cclxuXHJcblx0aW5pdCgpIHtcclxuXHRcdHRoaXMub2JqZWN0cyA9IEFycmF5LmZyb20odGhpcy5ub2RlcykubWFwKG5vZGUgPT4ge1xyXG5cdFx0XHRjb25zdCBbXHJcblx0XHRcdFx0c2VsZWN0b3IsIFxyXG5cdFx0XHRcdHJhd0JyZWFrcG9pbnQgPSBcIjc4MFwiLCBcclxuXHRcdFx0XHRwbGFjZSA9IFwibGFzdFwiXHJcblx0XHRcdF0gPSBub2RlLmRhdGFzZXRbdGhpcy5tb3ZlZENsYXNzXS50cmltKCkuc3BsaXQoXCIsXCIpLm1hcChzID0+IHMudHJpbSgpKTtcclxuXHJcblx0XHRcdGNvbnN0IGRlc3RpbmF0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgfHwgY29uc29sZS53YXJuKGBhZGFwdGl2ZU1vdmU6IGRlc3RpbmF0aW9uIHNlbGVjdG9yICcke3NlbGVjdG9yfScgbm90IGZvdW5kLmApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRlbGVtZW50OiBub2RlLFxyXG5cdFx0XHRcdHBhcmVudDogbm9kZS5wYXJlbnROb2RlLFxyXG5cdFx0XHRcdGRlc3RpbmF0aW9uLFxyXG5cdFx0XHRcdGluZGV4OiB0aGlzLiNpbmRleEluUGFyZW50KG5vZGUucGFyZW50Tm9kZSwgbm9kZSksXHJcblx0XHRcdFx0YnJlYWtwb2ludDogdGhpcy4jcmVzb2x2ZUJyZWFrcG9pbnQocmF3QnJlYWtwb2ludCkgPz8gcmF3QnJlYWtwb2ludCxcclxuXHRcdFx0XHRwbGFjZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy4jYXJyYXlTb3J0KHRoaXMub2JqZWN0cyk7IC8vINCh0L7RgNGC0LjRgNC+0LLQutCwINC/0L4g0YPRgdC70L7QstC40Y/QvFxyXG5cclxuXHRcdHRoaXMubWVkaWFRdWVyaWVzID0gWy4uLm5ldyBTZXQoXHJcblx0XHRcdHRoaXMub2JqZWN0cy5tYXAoaXRlbSA9PiBgKCR7dGhpcy50eXBlfS13aWR0aDogJHtpdGVtLmJyZWFrcG9pbnR9cHgpLCR7aXRlbS5icmVha3BvaW50fWApXHJcblx0XHQpXTtcclxuXHJcblx0XHR0aGlzLm1lZGlhUXVlcmllcy5mb3JFYWNoKG1lZGlhID0+IHtcclxuXHRcdFx0Y29uc3QgW21lZGlhUXVlcnksIGJyZWFrcG9pbnRdID0gbWVkaWEuc3BsaXQoXCIsXCIpO1xyXG5cdFx0XHRjb25zdCBtYXRjaE1lZGlhID0gd2luZG93Lm1hdGNoTWVkaWEobWVkaWFRdWVyeSk7XHJcblx0XHRcdGNvbnN0IHJlbGV2YW50T2JqZWN0cyA9IHRoaXMub2JqZWN0cy5maWx0ZXIob2JqID0+IG9iai5icmVha3BvaW50ID09PSBicmVha3BvaW50KTtcclxuXHJcblx0XHRcdG1hdGNoTWVkaWEuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiB0aGlzLiNtZWRpYUhhbmRsZXIobWF0Y2hNZWRpYSwgcmVsZXZhbnRPYmplY3RzKSk7XHJcblx0XHRcdHRoaXMuI21lZGlhSGFuZGxlcihtYXRjaE1lZGlhLCByZWxldmFudE9iamVjdHMpOyAvLyDQn9C10YDQstC40YfQvdCw0Y8g0L/RgNC+0LLQtdGA0LrQsFxyXG5cdFx0fSk7XHJcblx0fVxyXG5cdFxyXG5cdC8vINCf0YDQtdC+0LHRgNCw0LfQvtCy0LDQvdC40LUg0L/RgdC10LLQtNC+0L3QuNC80LAg0LHRgNC10LnQutC/0L7QuNC90YLQsCDQsiDQt9C90LDRh9C10L3QuNC1LCDQtdGB0LvQuCDQvtC/0YDQtdC00LXQu9C10L3QviDQsiDQvdCw0YHRgtGA0L7QudC60LDRhVxyXG5cdCNyZXNvbHZlQnJlYWtwb2ludCh2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmFsaWFzZXMsIHZhbHVlKVxyXG5cdFx0XHQ/IHRoaXMuYWxpYXNlc1t2YWx1ZV0udG9TdHJpbmcoKVxyXG5cdFx0XHQ6IHVuZGVmaW5lZDtcclxuXHR9XHJcblx0XHJcblx0Ly8g0J7QsdGA0LDQsdC+0YLRh9C40Log0LzQtdC00LjQsC3Qt9Cw0L/RgNC+0YHQsDog0L/QtdGA0LXQvNC10YnQtdC90LjQtSDQuNC70Lgg0LLQvtC30LLRgNCw0YIg0Y3Qu9C10LzQtdC90YLQvtCyXHJcblx0I21lZGlhSGFuZGxlcihtYXRjaE1lZGlhLCBvYmplY3RzKSB7XHJcblx0XHRpZiAobWF0Y2hNZWRpYS5tYXRjaGVzKSB7XHJcblx0XHRcdG9iamVjdHMuZm9yRWFjaChvYmogPT4ge1xyXG5cdFx0XHRcdGlmICghb2JqLmRlc3RpbmF0aW9uKSByZXR1cm47IC8vIEZhaWwtc2FmZTog0L/RgNC+0L/Rg9GB0YLQuNGC0YwsINC10YHQu9C4INC90LXRgiDQvNC10YHRgtCwINC90LDQt9C90LDRh9C10L3QuNGPXHJcblxyXG5cdFx0XHRcdG9iai5pbmRleCA9IHRoaXMuI2luZGV4SW5QYXJlbnQob2JqLnBhcmVudCwgb2JqLmVsZW1lbnQpO1xyXG5cdFx0XHRcdHRoaXMuI21vdmVUbyhvYmoucGxhY2UsIG9iai5lbGVtZW50LCBvYmouZGVzdGluYXRpb24pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciAobGV0IGkgPSBvYmplY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0Y29uc3Qgb2JqID0gb2JqZWN0c1tpXTtcclxuXHRcdFx0XHRpZiAob2JqLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMubW92ZWRDbGFzcykpIHtcclxuXHRcdFx0XHRcdHRoaXMuI21vdmVCYWNrKG9iai5wYXJlbnQsIG9iai5lbGVtZW50LCBvYmouaW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8g0J/QtdGA0LXQvNC10YnQtdC90LjQtSDRjdC70LXQvNC10L3RgtCwXHJcblx0I21vdmVUbyhwbGFjZSwgZWxlbWVudCwgZGVzdGluYXRpb24pIHtcclxuXHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLm1vdmVkQ2xhc3MpO1xyXG5cdFx0aWYgKHBsYWNlID09PSBcImxhc3RcIiB8fCBwbGFjZSA+PSBkZXN0aW5hdGlvbi5jaGlsZHJlbi5sZW5ndGgpIHtcclxuXHRcdFx0ZGVzdGluYXRpb24uYXBwZW5kKGVsZW1lbnQpO1xyXG5cdFx0fSBlbHNlIGlmIChwbGFjZSA9PT0gXCJmaXJzdFwiKSB7XHJcblx0XHRcdGRlc3RpbmF0aW9uLnByZXBlbmQoZWxlbWVudCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkZXN0aW5hdGlvbi5jaGlsZHJlbltwbGFjZV0uYmVmb3JlKGVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8g0JLQvtC30LLRgNCw0YIg0Y3Qu9C10LzQtdC90YLQsCDQvdCwINC40YHRhdC+0LTQvdC+0LUg0LzQtdGB0YLQvlxyXG5cdCNtb3ZlQmFjayhwYXJlbnQsIGVsZW1lbnQsIGluZGV4KSB7XHJcblx0XHRlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5tb3ZlZENsYXNzKTtcclxuXHRcdGlmIChwYXJlbnQuY2hpbGRyZW5baW5kZXhdICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cGFyZW50LmNoaWxkcmVuW2luZGV4XS5iZWZvcmUoZWxlbWVudCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwYXJlbnQuYXBwZW5kKGVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8g0J/QvtC70YPRh9C10L3QuNC1INC40L3QtNC10LrRgdCwINGN0LvQtdC80LXQvdGC0LAg0LIg0YDQvtC00LjRgtC10LvQtVxyXG5cdCNpbmRleEluUGFyZW50KHBhcmVudCwgZWxlbWVudCkge1xyXG5cdFx0cmV0dXJuIFsuLi5wYXJlbnQuY2hpbGRyZW5dLmluZGV4T2YoZWxlbWVudCk7XHJcblx0fVxyXG5cclxuXHQvLyDQodC+0YDRgtC40YDQvtCy0LrQsCDQvNCw0YHRgdC40LLQsCDQv9C+IGJyZWFrcG9pbnQg0LggcGxhY2VcclxuXHQjYXJyYXlTb3J0KGFycikge1xyXG5cdFx0Y29uc3QgcHJpb3JpdHkgPSBwbGFjZSA9PiB7XHJcblx0XHRcdGlmIChwbGFjZSA9PT0gXCJmaXJzdFwiKSByZXR1cm4gLTE7XHJcblx0XHRcdGlmIChwbGFjZSA9PT0gXCJsYXN0XCIpIHJldHVybiA5OTk5O1xyXG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQocGxhY2UsIDEwKTtcclxuXHRcdH07XHJcblxyXG5cdFx0YXJyLnNvcnQoKGEsIGIpID0+IHtcclxuXHRcdFx0aWYgKGEuYnJlYWtwb2ludCA9PT0gYi5icmVha3BvaW50KSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMudHlwZSA9PT0gXCJtaW5cIlxyXG5cdFx0XHRcdFx0PyBwcmlvcml0eShhLnBsYWNlKSAtIHByaW9yaXR5KGIucGxhY2UpXHJcblx0XHRcdFx0XHQ6IHByaW9yaXR5KGIucGxhY2UpIC0gcHJpb3JpdHkoYS5wbGFjZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXMudHlwZSA9PT0gXCJtaW5cIlxyXG5cdFx0XHRcdD8gYS5icmVha3BvaW50IC0gYi5icmVha3BvaW50XHJcblx0XHRcdFx0OiBiLmJyZWFrcG9pbnQgLSBhLmJyZWFrcG9pbnQ7XHJcblx0XHR9KTtcclxuXHR9XHJcbn0iXSwibmFtZXMiOlsiZHJpdmVBZGFwdGl2ZSIsIl9yZWYiLCJfcmVmJHR5cGUiLCJ0eXBlIiwiX3JlZiRtb3ZlZENsYXNzIiwibW92ZWRDbGFzcyIsIl9yZWYkYWxpYXNlcyIsImFsaWFzZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMiLCJfZHJpdmVBZGFwdGl2ZV9icmFuZCIsIm5vZGVzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29uY2F0Iiwib2JqZWN0cyIsImluaXQiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJ2YWx1ZSIsIl90aGlzIiwiQXJyYXkiLCJmcm9tIiwibWFwIiwibm9kZSIsIl9hc3NlcnRDbGFzc0JyYW5kJGNhbCIsIl9ub2RlJGRhdGFzZXQkX3RoaXMkbSIsImRhdGFzZXQiLCJ0cmltIiwic3BsaXQiLCJzIiwiX25vZGUkZGF0YXNldCRfdGhpcyRtMiIsIl9zbGljZWRUb0FycmF5Iiwic2VsZWN0b3IiLCJfbm9kZSRkYXRhc2V0JF90aGlzJG0zIiwicmF3QnJlYWtwb2ludCIsIl9ub2RlJGRhdGFzZXQkX3RoaXMkbTQiLCJwbGFjZSIsImRlc3RpbmF0aW9uIiwicXVlcnlTZWxlY3RvciIsImNvbnNvbGUiLCJ3YXJuIiwiZWxlbWVudCIsInBhcmVudCIsInBhcmVudE5vZGUiLCJpbmRleCIsIl9hc3NlcnRDbGFzc0JyYW5kIiwiX2luZGV4SW5QYXJlbnQiLCJjYWxsIiwiYnJlYWtwb2ludCIsIl9yZXNvbHZlQnJlYWtwb2ludCIsIl9hcnJheVNvcnQiLCJtZWRpYVF1ZXJpZXMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJTZXQiLCJpdGVtIiwiZm9yRWFjaCIsIm1lZGlhIiwiX21lZGlhJHNwbGl0IiwiX21lZGlhJHNwbGl0MiIsIm1lZGlhUXVlcnkiLCJtYXRjaE1lZGlhIiwid2luZG93IiwicmVsZXZhbnRPYmplY3RzIiwiZmlsdGVyIiwib2JqIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9tZWRpYUhhbmRsZXIiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInRvU3RyaW5nIiwidW5kZWZpbmVkIiwiX3RoaXMyIiwibWF0Y2hlcyIsIl9tb3ZlVG8iLCJpIiwibGVuZ3RoIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJfbW92ZUJhY2siLCJhZGQiLCJjaGlsZHJlbiIsImFwcGVuZCIsInByZXBlbmQiLCJiZWZvcmUiLCJyZW1vdmUiLCJpbmRleE9mIiwiYXJyIiwiX3RoaXMzIiwicHJpb3JpdHkiLCJwYXJzZUludCIsInNvcnQiLCJhIiwiYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/libs/driveAdaptive.js\n");

/***/ }),

/***/ "./src/js/libs/driveMenu.js":
/*!**********************************!*\
  !*** ./src/js/libs/driveMenu.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   driveMenu: () => (/* binding */ driveMenu)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\n/* \r\n* Переключатель класса для мобильного меню. Отслеживает клик по заданным\r\n* кнопкам и переключает класс для заданного блока. Так же отслеживает клик\r\n* по страничке за пределами заданного блока.\r\n* \r\n* @разметка\r\n* \r\n<div class=\"menu\">\r\n\t<button class=\"menu__close\"></button>\r\n\t<a class=\"menu__item\" href=\"./\">One</a>\r\n\t<a class=\"menu__item\" href=\"./\">Two</a>\r\n\t<a class=\"menu__item\" href=\"./\">Three</a>\r\n</div>\r\n<button class=\"menu__toggle\"></button>\r\n* \r\n* @вызов\r\n* \r\nimport scrollLock from 'scroll-lock';\r\nimport { driveMenu } from \"../../js/libs/driveMenu\";\r\nconst menu = document.querySelector('.menu');\r\nconst toggles = document.querySelectorAll('.menu__toggle, .menu__close');\r\ndriveMenu(menu, toggles,  {\r\n\tscrollLock,\r\n\tclass: 'opened',\r\n\tglobalClose: true,\r\n\tomitToClose: '.modal, .form',\r\n\topen: function() {\r\n\t\tconst maxw = parseInt(getComputedStyle(this).maxWidth);\r\n\t\tconst scrollw = scrollLock.getPageScrollBarWidth();\r\n\r\n\t\tObject.assign(this.style, { maxWidth: maxw + scrollw + 'px' });\r\n\t\tscrollLock.disablePageScroll();\r\n\t},\r\n\tclose: function() {\r\n\t\tscrollLock.clearQueueScrollLocks();\r\n\t\tscrollLock.enablePageScroll();\r\n\t}\r\n});\r\n* \r\n*/\n\nvar driveMenu = function driveMenu(menu, toggles) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _Menu_brand = /*#__PURE__*/new WeakSet();\n  var Menu = /*#__PURE__*/function () {\n    function Menu(_menu, _toggles, options) {\n      _classCallCheck(this, Menu);\n      _classPrivateMethodInitSpec(this, _Menu_brand);\n      if (!_menu || !_menu instanceof Element || !_toggles) return;\n      this.options = _objectSpread({\n        \"class\": false,\n        globalClose: true\n      }, options);\n      _assertClassBrand(_Menu_brand, this, _init).call(this);\n      this.opened = false;\n    }\n    return _createClass(Menu, [{\n      key: \"menuOpen\",\n      value: function menuOpen(e) {\n        var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.open;\n        if (e) {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n        this.options[\"class\"] && menu.classList.add(\"\".concat(this.options[\"class\"]));\n        this.opened = true;\n        cb === null || cb === void 0 || cb.call(menu, e === null || e === void 0 ? void 0 : e.currentTarget);\n        return true;\n      }\n    }, {\n      key: \"menuClose\",\n      value: function menuClose(e) {\n        var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.close;\n        if (e) e.stopPropagation();\n        this.options[\"class\"] && menu.classList.remove(\"\".concat(this.options[\"class\"]));\n        this.opened = false;\n        cb === null || cb === void 0 || cb.call(menu, e === null || e === void 0 ? void 0 : e.currentTarget);\n        return false;\n      }\n    }, {\n      key: \"menuToggle\",\n      value: function menuToggle(e) {\n        this.opened ? this.menuClose(e) : this.menuOpen(e);\n      }\n    }]);\n  }();\n  function _omitToClose(e) {\n    var _this$options$omitToC;\n    var omits = (_this$options$omitToC = this.options.omitToClose) === null || _this$options$omitToC === void 0 ? void 0 : _this$options$omitToC.split(\",\").map(function (item) {\n      return item.trim();\n    });\n    return omits === null || omits === void 0 ? void 0 : omits.some(function (omit) {\n      return !!e.target.closest(\"\".concat(omit));\n    });\n  }\n  function _init() {\n    var _this = this;\n    toggles.forEach(function (toggle) {\n      toggle.addEventListener('click', function (e) {\n        return _this.menuToggle(e);\n      });\n    });\n    if (this.options.globalClose) {\n      ['click', 'touchstart'].forEach(function (event) {\n        document.addEventListener(event, function (e) {\n          var isself = e.target.closest(\".\".concat(menu.className.split(' ')[0]));\n          if (_this.opened && !isself && !_assertClassBrand(_Menu_brand, _this, _omitToClose).call(_this, e)) {\n            e.preventDefault();\n            _this.menuClose(e);\n          }\n        }, {\n          passive: false\n        });\n      });\n    }\n  }\n  return new Menu(menu, toggles, options);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFlBQVksQ0FBQyxDQUFDbUMsT0FBTyxDQUFDLFVBQUFHLEtBQUssRUFBSTtRQUN2Q0MsUUFBUSxDQUFDRixnQkFBZ0IsQ0FBQ0MsS0FBSyxFQUFFLFVBQUM3QixDQUFDLEVBQUs7VUFDdkMsSUFBTStCLE1BQU0sR0FBRy9CLENBQUMsQ0FBQ3VCLE1BQU0sQ0FBQ0MsT0FBTyxLQUFBakIsTUFBQSxDQUFLN0IsSUFBSSxDQUFDc0QsU0FBUyxDQUFDZixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUUsQ0FBQztVQUVuRSxJQUFHUSxLQUFJLENBQUM5QixNQUFNLElBQUksQ0FBQ29DLE1BQU0sSUFBSSxDQUFDdkMsaUJBQUEsQ0FBQVIsV0FBQSxFQUFBeUMsS0FBSSxFQUFDWixZQUFXLENBQUMsQ0FBQW5CLElBQUEsQ0FBakIrQixLQUFJLEVBQWN6QixDQUFDLENBQUMsRUFBRTtZQUNuREEsQ0FBQyxDQUFDRyxjQUFjLENBQUMsQ0FBQztZQUNsQnNCLEtBQUksQ0FBQ2hCLFNBQVMsQ0FBQ1QsQ0FBQyxDQUFDO1VBQ2xCO1FBQ0QsQ0FBQyxFQUFFO1VBQUVpQyxPQUFPLEVBQUU7UUFBTSxDQUFDLENBQUM7TUFDdkIsQ0FBQyxDQUFDO0lBQ0g7RUFDRDtFQUdELE9BQU8sSUFBSS9DLElBQUksQ0FBQ1IsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sQ0FBQztBQUN4QyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvanMvbGlicy9kcml2ZU1lbnUuanM/ZmFkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBcclxuKiDQn9C10YDQtdC60LvRjtGH0LDRgtC10LvRjCDQutC70LDRgdGB0LAg0LTQu9GPINC80L7QsdC40LvRjNC90L7Qs9C+INC80LXQvdGOLiDQntGC0YHQu9C10LbQuNCy0LDQtdGCINC60LvQuNC6INC/0L4g0LfQsNC00LDQvdC90YvQvFxyXG4qINC60L3QvtC/0LrQsNC8INC4INC/0LXRgNC10LrQu9GO0YfQsNC10YIg0LrQu9Cw0YHRgSDQtNC70Y8g0LfQsNC00LDQvdC90L7Qs9C+INCx0LvQvtC60LAuINCi0LDQuiDQttC1INC+0YLRgdC70LXQttC40LLQsNC10YIg0LrQu9C40LpcclxuKiDQv9C+INGB0YLRgNCw0L3QuNGH0LrQtSDQt9CwINC/0YDQtdC00LXQu9Cw0LzQuCDQt9Cw0LTQsNC90L3QvtCz0L4g0LHQu9C+0LrQsC5cclxuKiBcclxuKiBA0YDQsNC30LzQtdGC0LrQsFxyXG4qIFxyXG48ZGl2IGNsYXNzPVwibWVudVwiPlxyXG5cdDxidXR0b24gY2xhc3M9XCJtZW51X19jbG9zZVwiPjwvYnV0dG9uPlxyXG5cdDxhIGNsYXNzPVwibWVudV9faXRlbVwiIGhyZWY9XCIuL1wiPk9uZTwvYT5cclxuXHQ8YSBjbGFzcz1cIm1lbnVfX2l0ZW1cIiBocmVmPVwiLi9cIj5Ud288L2E+XHJcblx0PGEgY2xhc3M9XCJtZW51X19pdGVtXCIgaHJlZj1cIi4vXCI+VGhyZWU8L2E+XHJcbjwvZGl2PlxyXG48YnV0dG9uIGNsYXNzPVwibWVudV9fdG9nZ2xlXCI+PC9idXR0b24+XHJcbiogXHJcbiogQNCy0YvQt9C+0LJcclxuKiBcclxuaW1wb3J0IHNjcm9sbExvY2sgZnJvbSAnc2Nyb2xsLWxvY2snO1xyXG5pbXBvcnQgeyBkcml2ZU1lbnUgfSBmcm9tIFwiLi4vLi4vanMvbGlicy9kcml2ZU1lbnVcIjtcclxuY29uc3QgbWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZW51Jyk7XHJcbmNvbnN0IHRvZ2dsZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubWVudV9fdG9nZ2xlLCAubWVudV9fY2xvc2UnKTtcclxuZHJpdmVNZW51KG1lbnUsIHRvZ2dsZXMsICB7XHJcblx0c2Nyb2xsTG9jayxcclxuXHRjbGFzczogJ29wZW5lZCcsXHJcblx0Z2xvYmFsQ2xvc2U6IHRydWUsXHJcblx0b21pdFRvQ2xvc2U6ICcubW9kYWwsIC5mb3JtJyxcclxuXHRvcGVuOiBmdW5jdGlvbigpIHtcclxuXHRcdGNvbnN0IG1heHcgPSBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKHRoaXMpLm1heFdpZHRoKTtcclxuXHRcdGNvbnN0IHNjcm9sbHcgPSBzY3JvbGxMb2NrLmdldFBhZ2VTY3JvbGxCYXJXaWR0aCgpO1xyXG5cclxuXHRcdE9iamVjdC5hc3NpZ24odGhpcy5zdHlsZSwgeyBtYXhXaWR0aDogbWF4dyArIHNjcm9sbHcgKyAncHgnIH0pO1xyXG5cdFx0c2Nyb2xsTG9jay5kaXNhYmxlUGFnZVNjcm9sbCgpO1xyXG5cdH0sXHJcblx0Y2xvc2U6IGZ1bmN0aW9uKCkge1xyXG5cdFx0c2Nyb2xsTG9jay5jbGVhclF1ZXVlU2Nyb2xsTG9ja3MoKTtcclxuXHRcdHNjcm9sbExvY2suZW5hYmxlUGFnZVNjcm9sbCgpO1xyXG5cdH1cclxufSk7XHJcbiogXHJcbiovXHJcblxyXG5leHBvcnQgY29uc3QgZHJpdmVNZW51ID0gKG1lbnUsIHRvZ2dsZXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG5cdGNsYXNzIE1lbnUge1xyXG5cdFx0Y29uc3RydWN0b3IobWVudSwgdG9nZ2xlcywgb3B0aW9ucykge1xyXG5cdFx0XHRpZighbWVudSB8fCAhbWVudSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgIXRvZ2dsZXMpIHJldHVybjtcclxuXHJcblx0XHRcdHRoaXMub3B0aW9ucyA9IHtcclxuXHRcdFx0XHRjbGFzczogZmFsc2UsXHJcblx0XHRcdFx0Z2xvYmFsQ2xvc2U6IHRydWUsXHJcblx0XHRcdFx0Li4ub3B0aW9uc1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dGhpcy4jaW5pdCgpO1xyXG5cdFx0XHR0aGlzLm9wZW5lZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lbnVPcGVuKGUsIGNiID0gdGhpcy5vcHRpb25zLm9wZW4pIHtcclxuXHRcdFx0aWYoZSkge1xyXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm9wdGlvbnMuY2xhc3MgJiYgbWVudS5jbGFzc0xpc3QuYWRkKGAke3RoaXMub3B0aW9ucy5jbGFzc31gKTtcclxuXHRcdFx0dGhpcy5vcGVuZWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0Y2I/LmNhbGwobWVudSwgZT8uY3VycmVudFRhcmdldCk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0XHJcblxyXG5cdFx0bWVudUNsb3NlKGUsIGNiID0gdGhpcy5vcHRpb25zLmNsb3NlKSB7XHJcblx0XHRcdGlmIChlKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5vcHRpb25zLmNsYXNzICYmIG1lbnUuY2xhc3NMaXN0LnJlbW92ZShgJHt0aGlzLm9wdGlvbnMuY2xhc3N9YCk7XHJcblx0XHRcdHRoaXMub3BlbmVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRjYj8uY2FsbChtZW51LCBlPy5jdXJyZW50VGFyZ2V0KTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFxyXG5cdFx0bWVudVRvZ2dsZShlKSB7XHJcblx0XHRcdHRoaXMub3BlbmVkID8gdGhpcy5tZW51Q2xvc2UoZSkgOiB0aGlzLm1lbnVPcGVuKGUpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQjb21pdFRvQ2xvc2UoZSkge1xyXG5cdFx0XHRjb25zdCBvbWl0cyA9IHRoaXMub3B0aW9ucy5vbWl0VG9DbG9zZT8uc3BsaXQoXCIsXCIpLm1hcCgoaXRlbSkgPT4gaXRlbS50cmltKCkpO1xyXG5cdFx0XHRyZXR1cm4gb21pdHM/LnNvbWUob21pdCA9PiAhIWUudGFyZ2V0LmNsb3Nlc3QoYCR7b21pdH1gKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0XHJcblx0XHQjaW5pdCgpIHtcclxuXHRcdFx0dG9nZ2xlcy5mb3JFYWNoKHRvZ2dsZSA9PiB7XHJcblx0XHRcdFx0dG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHRoaXMubWVudVRvZ2dsZShlKSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0aWYodGhpcy5vcHRpb25zLmdsb2JhbENsb3NlKSB7XHJcblx0XHRcdFx0WydjbGljaycsJ3RvdWNoc3RhcnQnXS5mb3JFYWNoKGV2ZW50ID0+IHtcclxuXHRcdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIChlKSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGlzc2VsZiA9IGUudGFyZ2V0LmNsb3Nlc3QoYC4ke21lbnUuY2xhc3NOYW1lLnNwbGl0KCcgJylbMF19YCk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZih0aGlzLm9wZW5lZCAmJiAhaXNzZWxmICYmICF0aGlzLiNvbWl0VG9DbG9zZShlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLm1lbnVDbG9zZShlKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBNZW51KG1lbnUsIHRvZ2dsZXMsIG9wdGlvbnMpO1xyXG59Il0sIm5hbWVzIjpbImRyaXZlTWVudSIsIm1lbnUiLCJ0b2dnbGVzIiwib3B0aW9ucyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIl9NZW51X2JyYW5kIiwiV2Vha1NldCIsIk1lbnUiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMiLCJFbGVtZW50IiwiX29iamVjdFNwcmVhZCIsImdsb2JhbENsb3NlIiwiX2Fzc2VydENsYXNzQnJhbmQiLCJfaW5pdCIsImNhbGwiLCJvcGVuZWQiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJ2YWx1ZSIsIm1lbnVPcGVuIiwiZSIsImNiIiwib3BlbiIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2xhc3NMaXN0IiwiYWRkIiwiY29uY2F0IiwiY3VycmVudFRhcmdldCIsIm1lbnVDbG9zZSIsImNsb3NlIiwicmVtb3ZlIiwibWVudVRvZ2dsZSIsIl9vbWl0VG9DbG9zZSIsIl90aGlzJG9wdGlvbnMkb21pdFRvQyIsIm9taXRzIiwib21pdFRvQ2xvc2UiLCJzcGxpdCIsIm1hcCIsIml0ZW0iLCJ0cmltIiwic29tZSIsIm9taXQiLCJ0YXJnZXQiLCJjbG9zZXN0IiwiX3RoaXMiLCJmb3JFYWNoIiwidG9nZ2xlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiZG9jdW1lbnQiLCJpc3NlbGYiLCJjbGFzc05hbWUiLCJwYXNzaXZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/libs/driveMenu.js\n");

/***/ }),

/***/ "./src/js/libs/driveSidebar.js":
/*!*************************************!*\
  !*** ./src/js/libs/driveSidebar.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   driveSidebar: () => (/* binding */ driveSidebar)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\n/* \r\n* Простая реализация прилипающего сайдбара, когда сайдбар плавно следует \r\n* за прокруткой страницы, но с дополнительной логикой для ограничения\r\n* области прокрутки. Если сайдбар короче высоты экрана — он остаётся на месте. \r\n* Если длиннее — плавно скроллится в пределах экрана, не выходя за границы.\r\n* \r\n* Важно! - крайние значения для верхнего и нижнего 'прилипания', берет из стилей\r\n* элемента - top и bottom, соответственно. По этому, если они по дизайну, отличаются\r\n* от 0 - их обязательно нужно задавать в css. Такой подход, кроме того, еще позволяет\r\n* задавать разные значения top и bottom в медиазапросах, что дает возможность для адаптации\r\n* \r\n* \r\n* @разметка:\r\n* \r\n<aside class=\"aside\">\r\n\t<div class=\"aside__sidebar\"></div>\r\n</aside>\r\n* \r\n* \r\n* @необходимые стили: \r\n* \r\n.aside {\r\n\t&__sidebar {\r\n\t\tposition: sticky;\r\n\t\tbottom: 20px;\r\n\t\ttop: 0px;\r\n\t}\r\n}\r\n* \r\n* \r\n* @вызов:\r\n* \r\nimport { driveSidebar } from \"../../js/libs/driveSidebar\";\r\n\r\ndriveSidebar(document.querySelector('.aside__sidebar'), {\r\n\tresizeSensitivity: 100,\r\n\teasing: 0.2\r\n});\r\n* \r\n* @параметры вызова:\r\n*\r\n* resizeSensitivity - скорость реагирования на resize для обновления стартовых данных\r\n* easing - скорость анимации остановки скролла\r\n* \r\n*/\n\nvar driveSidebar = function driveSidebar(items) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _Sidebar_brand = /*#__PURE__*/new WeakSet();\n  var Sidebar = /*#__PURE__*/_createClass(function Sidebar(aside, _options) {\n    var _this$options$easing;\n    _classCallCheck(this, Sidebar);\n    _classPrivateMethodInitSpec(this, _Sidebar_brand);\n    if (!aside) return;\n    this.options = _objectSpread({\n      resizeSensitivity: 250,\n      easing: 0.5\n    }, _options);\n    this.aside = aside;\n    this.currPos = window.scrollY;\n    this.styles = window.getComputedStyle(aside);\n    this.startScroll = parseInt(this.styles.top, 10);\n    this.availableHeightTop = window.innerHeight - this.startScroll;\n    this.availableHeightBottom = window.innerHeight - parseInt(this.styles.bottom, 10);\n    this.aside.style.top = this.startScroll + 'px';\n    this.currentTop = this.startScroll;\n    this.targetTop = this.startScroll;\n    this.ticking = false;\n    this.easing = Math.max(0.05, Math.min((_this$options$easing = this.options.easing) !== null && _this$options$easing !== void 0 ? _this$options$easing : 0.1, 1));\n    _assertClassBrand(_Sidebar_brand, this, _init).call(this);\n  });\n  function _asideScroll() {\n    if (this.styles.position !== 'sticky') return;\n    if (this.aside.offsetHeight <= this.availableHeightTop) {\n      this.targetTop = this.startScroll;\n      _assertClassBrand(_Sidebar_brand, this, _startAnimation).call(this);\n      return;\n    }\n    var endScroll = this.availableHeightBottom - this.aside.offsetHeight;\n    if (this.aside.offsetHeight > this.availableHeightTop) {\n      // если не влезает в экран\n      if (window.scrollY < this.currPos) {\n        // скроллим вверх\n        if (this.targetTop < this.startScroll) {\n          this.targetTop += this.currPos - window.scrollY; // задаем позицию к которой будем стремиться\n        } else {\n          this.targetTop = this.startScroll; // останавливаем у крайнего значения\n        }\n      } else {\n        if (this.targetTop > endScroll) {\n          // скроллим вниз\n          this.targetTop += this.currPos - window.scrollY;\n        } else {\n          this.targetTop = endScroll;\n        }\n      }\n    }\n    this.currPos = window.scrollY;\n    _assertClassBrand(_Sidebar_brand, this, _startAnimation).call(this);\n  }\n  function _startAnimation() {\n    if (this.ticking) return;\n    this.ticking = true;\n    requestAnimationFrame(_assertClassBrand(_Sidebar_brand, this, _animatePosition).bind(this));\n  }\n  function _animatePosition() {\n    var diff = this.targetTop - this.currentTop;\n    if (Math.abs(diff) < 1) {\n      // догнали заданную скроллом позицию\n      this.currentTop = this.targetTop;\n      this.aside.style.top = \"\".concat(this.currentTop, \"px\");\n      this.ticking = false;\n      return;\n    }\n    this.currentTop += diff * this.easing; // догоняем заданную скроллом позицию\n    this.aside.style.top = \"\".concat(this.currentTop, \"px\");\n    requestAnimationFrame(_assertClassBrand(_Sidebar_brand, this, _animatePosition).bind(this));\n  }\n  function _throttle(fn) {\n    var _this = this;\n    var timeout = null;\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      if (timeout === null) {\n        timeout = setTimeout(function () {\n          fn.apply(_this, args);\n          timeout = null;\n        }, options.resizeSensitivity);\n      }\n    };\n  }\n  function _init() {\n    var _this2 = this;\n    window.addEventListener('scroll', _assertClassBrand(_Sidebar_brand, this, _asideScroll).bind(this), {\n      capture: true,\n      passive: true\n    });\n    window.addEventListener('resize', _assertClassBrand(_Sidebar_brand, this, _throttle).call(this, function () {\n      var top = _this2.aside.style.top;\n      _this2.aside.removeAttribute('style');\n      _this2.styles = window.getComputedStyle(_this2.aside);\n      _this2.startScroll = parseInt(_this2.styles.top, 10);\n      _this2.availableHeightTop = window.innerHeight - _this2.startScroll;\n      _this2.availableHeightBottom = window.innerHeight - parseInt(_this2.styles.bottom, 10);\n      _this2.currentTop = _this2.targetTop = parseFloat(top);\n      _this2.aside.style.top = top;\n      _assertClassBrand(_Sidebar_brand, _this2, _asideScroll).call(_this2);\n    }));\n    _assertClassBrand(_Sidebar_brand, this, _asideScroll).call(this);\n  }\n  if (items instanceof NodeList) {\n    items.forEach(function (item) {\n      return new Sidebar(item, options);\n    });\n  } else {\n    return new Sidebar(items, options);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU0sQ0FBQ1EsTUFBTSxFQUFFLEVBQUUsQ0FBQztNQUNsRmdDLE1BQUksQ0FBQzlCLFVBQVUsR0FBRzhCLE1BQUksQ0FBQzdCLFNBQVMsR0FBR2tDLFVBQVUsQ0FBQ3pDLEdBQUcsQ0FBQztNQUNsRG9DLE1BQUksQ0FBQ2xELEtBQUssQ0FBQ21CLEtBQUssQ0FBQ0wsR0FBRyxHQUFHQSxHQUFHO01BQzFCWSxpQkFBQSxDQUFBOUIsY0FBQSxFQUFBc0QsTUFBSSxFQUFDckIsWUFBVyxDQUFDLENBQUFELElBQUEsQ0FBakJzQixNQUFJO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSHhCLGlCQUFBLENBQUE5QixjQUFBLE1BQUksRUFBQ2lDLFlBQVcsQ0FBQyxDQUFBRCxJQUFBLENBQWpCLElBQUk7RUFDTDtFQUdELElBQUdyQyxLQUFLLFlBQVlpRSxRQUFRLEVBQUU7SUFDN0JqRSxLQUFLLENBQUNrRSxPQUFPLENBQUMsVUFBQ0MsSUFBSTtNQUFBLE9BQUssSUFBSTVELE9BQU8sQ0FBQzRELElBQUksRUFBRWxFLE9BQU8sQ0FBQztJQUFBLEVBQUM7RUFDcEQsQ0FBQyxNQUFNO0lBQ04sT0FBTyxJQUFJTSxPQUFPLENBQUNQLEtBQUssRUFBRUMsT0FBTyxDQUFDO0VBQ25DO0FBQ0QsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2d1bHAtc2Nzcy1zdGFydGVyLy4vc3JjL2pzL2xpYnMvZHJpdmVTaWRlYmFyLmpzPzc4ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogXHJcbiog0J/RgNC+0YHRgtCw0Y8g0YDQtdCw0LvQuNC30LDRhtC40Y8g0L/RgNC40LvQuNC/0LDRjtGJ0LXQs9C+INGB0LDQudC00LHQsNGA0LAsINC60L7Qs9C00LAg0YHQsNC50LTQsdCw0YAg0L/Qu9Cw0LLQvdC+INGB0LvQtdC00YPQtdGCIFxyXG4qINC30LAg0L/RgNC+0LrRgNGD0YLQutC+0Lkg0YHRgtGA0LDQvdC40YbRiywg0L3QviDRgSDQtNC+0L/QvtC70L3QuNGC0LXQu9GM0L3QvtC5INC70L7Qs9C40LrQvtC5INC00LvRjyDQvtCz0YDQsNC90LjRh9C10L3QuNGPXHJcbiog0L7QsdC70LDRgdGC0Lgg0L/RgNC+0LrRgNGD0YLQutC4LiDQldGB0LvQuCDRgdCw0LnQtNCx0LDRgCDQutC+0YDQvtGH0LUg0LLRi9GB0L7RgtGLINGN0LrRgNCw0L3QsCDigJQg0L7QvSDQvtGB0YLQsNGR0YLRgdGPINC90LAg0LzQtdGB0YLQtS4gXHJcbiog0JXRgdC70Lgg0LTQu9C40L3QvdC10LUg4oCUINC/0LvQsNCy0L3QviDRgdC60YDQvtC70LvQuNGC0YHRjyDQsiDQv9GA0LXQtNC10LvQsNGFINGN0LrRgNCw0L3QsCwg0L3QtSDQstGL0YXQvtC00Y8g0LfQsCDQs9GA0LDQvdC40YbRiy5cclxuKiBcclxuKiDQktCw0LbQvdC+ISAtINC60YDQsNC50L3QuNC1INC30L3QsNGH0LXQvdC40Y8g0LTQu9GPINCy0LXRgNGF0L3QtdCz0L4g0Lgg0L3QuNC20L3QtdCz0L4gJ9C/0YDQuNC70LjQv9Cw0L3QuNGPJywg0LHQtdGA0LXRgiDQuNC3INGB0YLQuNC70LXQuVxyXG4qINGN0LvQtdC80LXQvdGC0LAgLSB0b3Ag0LggYm90dG9tLCDRgdC+0L7RgtCy0LXRgtGB0YLQstC10L3QvdC+LiDQn9C+INGN0YLQvtC80YMsINC10YHQu9C4INC+0L3QuCDQv9C+INC00LjQt9Cw0LnQvdGDLCDQvtGC0LvQuNGH0LDRjtGC0YHRj1xyXG4qINC+0YIgMCAtINC40YUg0L7QsdGP0LfQsNGC0LXQu9GM0L3QviDQvdGD0LbQvdC+INC30LDQtNCw0LLQsNGC0Ywg0LIgY3NzLiDQotCw0LrQvtC5INC/0L7QtNGF0L7QtCwg0LrRgNC+0LzQtSDRgtC+0LPQviwg0LXRidC1INC/0L7Qt9Cy0L7Qu9GP0LXRglxyXG4qINC30LDQtNCw0LLQsNGC0Ywg0YDQsNC30L3Ri9C1INC30L3QsNGH0LXQvdC40Y8gdG9wINC4IGJvdHRvbSDQsiDQvNC10LTQuNCw0LfQsNC/0YDQvtGB0LDRhSwg0YfRgtC+INC00LDQtdGCINCy0L7Qt9C80L7QttC90L7RgdGC0Ywg0LTQu9GPINCw0LTQsNC/0YLQsNGG0LjQuFxyXG4qIFxyXG4qIFxyXG4qIEDRgNCw0LfQvNC10YLQutCwOlxyXG4qIFxyXG48YXNpZGUgY2xhc3M9XCJhc2lkZVwiPlxyXG5cdDxkaXYgY2xhc3M9XCJhc2lkZV9fc2lkZWJhclwiPjwvZGl2PlxyXG48L2FzaWRlPlxyXG4qIFxyXG4qIFxyXG4qIEDQvdC10L7QsdGF0L7QtNC40LzRi9C1INGB0YLQuNC70Lg6IFxyXG4qIFxyXG4uYXNpZGUge1xyXG5cdCZfX3NpZGViYXIge1xyXG5cdFx0cG9zaXRpb246IHN0aWNreTtcclxuXHRcdGJvdHRvbTogMjBweDtcclxuXHRcdHRvcDogMHB4O1xyXG5cdH1cclxufVxyXG4qIFxyXG4qIFxyXG4qIEDQstGL0LfQvtCyOlxyXG4qIFxyXG5pbXBvcnQgeyBkcml2ZVNpZGViYXIgfSBmcm9tIFwiLi4vLi4vanMvbGlicy9kcml2ZVNpZGViYXJcIjtcclxuXHJcbmRyaXZlU2lkZWJhcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXNpZGVfX3NpZGViYXInKSwge1xyXG5cdHJlc2l6ZVNlbnNpdGl2aXR5OiAxMDAsXHJcblx0ZWFzaW5nOiAwLjJcclxufSk7XHJcbiogXHJcbiogQNC/0LDRgNCw0LzQtdGC0YDRiyDQstGL0LfQvtCy0LA6XHJcbipcclxuKiByZXNpemVTZW5zaXRpdml0eSAtINGB0LrQvtGA0L7RgdGC0Ywg0YDQtdCw0LPQuNGA0L7QstCw0L3QuNGPINC90LAgcmVzaXplINC00LvRjyDQvtCx0L3QvtCy0LvQtdC90LjRjyDRgdGC0LDRgNGC0L7QstGL0YUg0LTQsNC90L3Ri9GFXHJcbiogZWFzaW5nIC0g0YHQutC+0YDQvtGB0YLRjCDQsNC90LjQvNCw0YbQuNC4INC+0YHRgtCw0L3QvtCy0LrQuCDRgdC60YDQvtC70LvQsFxyXG4qIFxyXG4qL1xyXG5cclxuZXhwb3J0IGNvbnN0IGRyaXZlU2lkZWJhciA9IChpdGVtcywgb3B0aW9ucyA9IHt9KSA9PiB7XHJcblx0Y2xhc3MgU2lkZWJhciB7XHJcblx0XHRjb25zdHJ1Y3Rvcihhc2lkZSwgb3B0aW9ucykge1xyXG5cdFx0XHRpZighIGFzaWRlKSByZXR1cm47XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLm9wdGlvbnMgPSB7XHJcblx0XHRcdFx0cmVzaXplU2Vuc2l0aXZpdHk6IDI1MCxcclxuXHRcdFx0XHRlYXNpbmc6IDAuNSxcclxuXHRcdFx0XHQuLi5vcHRpb25zXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYXNpZGUgPSBhc2lkZTtcclxuXHRcdFx0dGhpcy5jdXJyUG9zID0gd2luZG93LnNjcm9sbFk7XHJcblx0XHRcdHRoaXMuc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoYXNpZGUpO1xyXG5cdFx0XHR0aGlzLnN0YXJ0U2Nyb2xsID0gcGFyc2VJbnQodGhpcy5zdHlsZXMudG9wLCAxMCk7XHJcblx0XHRcdHRoaXMuYXZhaWxhYmxlSGVpZ2h0VG9wID0gd2luZG93LmlubmVySGVpZ2h0IC0gdGhpcy5zdGFydFNjcm9sbDtcclxuXHRcdFx0dGhpcy5hdmFpbGFibGVIZWlnaHRCb3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBwYXJzZUludCh0aGlzLnN0eWxlcy5ib3R0b20sIDEwKTtcclxuXHRcdFx0dGhpcy5hc2lkZS5zdHlsZS50b3AgPSB0aGlzLnN0YXJ0U2Nyb2xsICsgJ3B4JztcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuY3VycmVudFRvcCA9IHRoaXMuc3RhcnRTY3JvbGw7XHJcblx0XHRcdHRoaXMudGFyZ2V0VG9wID0gdGhpcy5zdGFydFNjcm9sbDtcclxuXHRcdFx0dGhpcy50aWNraW5nID0gZmFsc2U7XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLmVhc2luZyA9IE1hdGgubWF4KDAuMDUsIE1hdGgubWluKHRoaXMub3B0aW9ucy5lYXNpbmcgPz8gMC4xLCAxKSk7XHJcblx0XHRcdHRoaXMuI2luaXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQjYXNpZGVTY3JvbGwoKSB7XHJcblx0XHRcdGlmKHRoaXMuc3R5bGVzLnBvc2l0aW9uICE9PSAnc3RpY2t5JykgcmV0dXJuO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHRoaXMuYXNpZGUub2Zmc2V0SGVpZ2h0IDw9IHRoaXMuYXZhaWxhYmxlSGVpZ2h0VG9wKSB7XHJcblx0XHRcdFx0dGhpcy50YXJnZXRUb3AgPSB0aGlzLnN0YXJ0U2Nyb2xsO1xyXG5cdFx0XHRcdHRoaXMuI3N0YXJ0QW5pbWF0aW9uKCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRjb25zdCBlbmRTY3JvbGwgPSB0aGlzLmF2YWlsYWJsZUhlaWdodEJvdHRvbSAtIHRoaXMuYXNpZGUub2Zmc2V0SGVpZ2h0XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAodGhpcy5hc2lkZS5vZmZzZXRIZWlnaHQgPiB0aGlzLmF2YWlsYWJsZUhlaWdodFRvcCkgeyAvLyDQtdGB0LvQuCDQvdC1INCy0LvQtdC30LDQtdGCINCyINGN0LrRgNCw0L1cclxuXHRcdFx0XHRpZiAod2luZG93LnNjcm9sbFkgPCB0aGlzLmN1cnJQb3MpIHsgLy8g0YHQutGA0L7Qu9C70LjQvCDQstCy0LXRgNGFXHJcblx0XHRcdFx0XHRpZiAodGhpcy50YXJnZXRUb3AgPCB0aGlzLnN0YXJ0U2Nyb2xsKSB7IFxyXG5cdFx0XHRcdFx0XHR0aGlzLnRhcmdldFRvcCArPSB0aGlzLmN1cnJQb3MgLSB3aW5kb3cuc2Nyb2xsWTsgLy8g0LfQsNC00LDQtdC8INC/0L7Qt9C40YbQuNGOINC6INC60L7RgtC+0YDQvtC5INCx0YPQtNC10Lwg0YHRgtGA0LXQvNC40YLRjNGB0Y9cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMudGFyZ2V0VG9wID0gdGhpcy5zdGFydFNjcm9sbDsgLy8g0L7RgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0YMg0LrRgNCw0LnQvdC10LPQviDQt9C90LDRh9C10L3QuNGPXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLnRhcmdldFRvcCA+IGVuZFNjcm9sbCkgeyAvLyDRgdC60YDQvtC70LvQuNC8INCy0L3QuNC3XHJcblx0XHRcdFx0XHRcdHRoaXMudGFyZ2V0VG9wICs9IHRoaXMuY3VyclBvcyAtIHdpbmRvdy5zY3JvbGxZO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy50YXJnZXRUb3AgPSBlbmRTY3JvbGw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJQb3MgPSB3aW5kb3cuc2Nyb2xsWTtcclxuXHRcdFx0dGhpcy4jc3RhcnRBbmltYXRpb24oKTtcclxuXHRcdH1cclxuXHJcblx0XHQjc3RhcnRBbmltYXRpb24oKSB7XHJcblx0XHRcdGlmICh0aGlzLnRpY2tpbmcpIHJldHVybjtcclxuXHRcdFx0dGhpcy50aWNraW5nID0gdHJ1ZTtcclxuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuI2FuaW1hdGVQb3NpdGlvbi5iaW5kKHRoaXMpKTtcclxuXHRcdH1cclxuXHJcblx0XHQjYW5pbWF0ZVBvc2l0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBkaWZmID0gdGhpcy50YXJnZXRUb3AgLSB0aGlzLmN1cnJlbnRUb3A7XHJcblxyXG5cdFx0XHRpZiAoTWF0aC5hYnMoZGlmZikgPCAxKSB7IC8vINC00L7Qs9C90LDQu9C4INC30LDQtNCw0L3QvdGD0Y4g0YHQutGA0L7Qu9C70L7QvCDQv9C+0LfQuNGG0LjRjlxyXG5cdFx0XHRcdHRoaXMuY3VycmVudFRvcCA9IHRoaXMudGFyZ2V0VG9wO1xyXG5cdFx0XHRcdHRoaXMuYXNpZGUuc3R5bGUudG9wID0gYCR7dGhpcy5jdXJyZW50VG9wfXB4YDtcclxuXHRcdFx0XHR0aGlzLnRpY2tpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuY3VycmVudFRvcCArPSBkaWZmICogdGhpcy5lYXNpbmc7IC8vINC00L7Qs9C+0L3Rj9C10Lwg0LfQsNC00LDQvdC90YPRjiDRgdC60YDQvtC70LvQvtC8INC/0L7Qt9C40YbQuNGOXHJcblx0XHRcdHRoaXMuYXNpZGUuc3R5bGUudG9wID0gYCR7dGhpcy5jdXJyZW50VG9wfXB4YDtcclxuXHJcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLiNhbmltYXRlUG9zaXRpb24uYmluZCh0aGlzKSk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdCN0aHJvdHRsZShmbikge1xyXG5cdFx0XHRsZXQgdGltZW91dCA9IG51bGw7XHJcblx0XHRcclxuXHRcdFx0cmV0dXJuICguLi5hcmdzKSA9PiB7XHJcblx0XHRcdFx0aWYgKHRpbWVvdXQgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRmbi5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHRcdFx0XHRcdFx0dGltZW91dCA9IG51bGw7XHJcblx0XHRcdFx0XHR9LCBvcHRpb25zLnJlc2l6ZVNlbnNpdGl2aXR5KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdCNpbml0KCkge1xyXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy4jYXNpZGVTY3JvbGwuYmluZCh0aGlzKSwgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH0pO1xyXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy4jdGhyb3R0bGUoKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHsgdG9wIH0gPSB0aGlzLmFzaWRlLnN0eWxlO1xyXG5cclxuXHRcdFx0XHR0aGlzLmFzaWRlLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuXHRcdFx0XHR0aGlzLnN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuYXNpZGUpO1xyXG5cdFx0XHRcdHRoaXMuc3RhcnRTY3JvbGwgPSBwYXJzZUludCh0aGlzLnN0eWxlcy50b3AsIDEwKTtcclxuXHRcdFx0XHR0aGlzLmF2YWlsYWJsZUhlaWdodFRvcCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHRoaXMuc3RhcnRTY3JvbGw7XHJcblx0XHRcdFx0dGhpcy5hdmFpbGFibGVIZWlnaHRCb3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBwYXJzZUludCh0aGlzLnN0eWxlcy5ib3R0b20sIDEwKTtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRUb3AgPSB0aGlzLnRhcmdldFRvcCA9IHBhcnNlRmxvYXQodG9wKTtcclxuXHRcdFx0XHR0aGlzLmFzaWRlLnN0eWxlLnRvcCA9IHRvcDtcclxuXHRcdFx0XHR0aGlzLiNhc2lkZVNjcm9sbCgpO1xyXG5cdFx0XHR9KSk7XHJcblxyXG5cdFx0XHR0aGlzLiNhc2lkZVNjcm9sbCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYoaXRlbXMgaW5zdGFuY2VvZiBOb2RlTGlzdCkge1xyXG5cdFx0aXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4gbmV3IFNpZGViYXIoaXRlbSwgb3B0aW9ucykpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gbmV3IFNpZGViYXIoaXRlbXMsIG9wdGlvbnMpO1xyXG5cdH1cclxufSJdLCJuYW1lcyI6WyJkcml2ZVNpZGViYXIiLCJpdGVtcyIsIm9wdGlvbnMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJfU2lkZWJhcl9icmFuZCIsIldlYWtTZXQiLCJTaWRlYmFyIiwiX2NyZWF0ZUNsYXNzIiwiYXNpZGUiLCJfdGhpcyRvcHRpb25zJGVhc2luZyIsIl9jbGFzc0NhbGxDaGVjayIsIl9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyIsIl9vYmplY3RTcHJlYWQiLCJyZXNpemVTZW5zaXRpdml0eSIsImVhc2luZyIsImN1cnJQb3MiLCJ3aW5kb3ciLCJzY3JvbGxZIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInN0YXJ0U2Nyb2xsIiwicGFyc2VJbnQiLCJ0b3AiLCJhdmFpbGFibGVIZWlnaHRUb3AiLCJpbm5lckhlaWdodCIsImF2YWlsYWJsZUhlaWdodEJvdHRvbSIsImJvdHRvbSIsInN0eWxlIiwiY3VycmVudFRvcCIsInRhcmdldFRvcCIsInRpY2tpbmciLCJNYXRoIiwibWF4IiwibWluIiwiX2Fzc2VydENsYXNzQnJhbmQiLCJfaW5pdCIsImNhbGwiLCJfYXNpZGVTY3JvbGwiLCJwb3NpdGlvbiIsIm9mZnNldEhlaWdodCIsIl9zdGFydEFuaW1hdGlvbiIsImVuZFNjcm9sbCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9hbmltYXRlUG9zaXRpb24iLCJiaW5kIiwiZGlmZiIsImFicyIsImNvbmNhdCIsIl90aHJvdHRsZSIsImZuIiwiX3RoaXMiLCJ0aW1lb3V0IiwiX2xlbiIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJfdGhpczIiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FwdHVyZSIsInBhc3NpdmUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwYXJzZUZsb2F0IiwiTm9kZUxpc3QiLCJmb3JFYWNoIiwiaXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/libs/driveSidebar.js\n");

/***/ }),

/***/ "./src/js/libs/driveSlide.js":
/*!***********************************!*\
  !*** ./src/js/libs/driveSlide.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accordion: () => (/* binding */ accordion),\n/* harmony export */   accordionSimple: () => (/* binding */ accordionSimple),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   down: () => (/* binding */ down),\n/* harmony export */   toggle: () => (/* binding */ toggle),\n/* harmony export */   up: () => (/* binding */ up)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar driveSlide = {\n  up: function up(el) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$duration = _ref.duration,\n      duration = _ref$duration === void 0 ? 500 : _ref$duration,\n      _ref$opacity = _ref.opacity,\n      opacity = _ref$opacity === void 0 ? false : _ref$opacity,\n      callback = _ref.callback;\n    if (el.timeout || window.getComputedStyle(el).display === 'none') return;\n    el.style.display = 'block';\n    Object.assign(el.style, {\n      transitionProperty: 'height, margin, padding, opacity',\n      transitionDuration: duration + 'ms',\n      height: el.offsetHeight + 'px',\n      boxSizing: 'border-box',\n      opacity: 1\n    });\n    requestAnimationFrame(function () {\n      el.offsetHeight;\n      Object.assign(el.style, _objectSpread({\n        overflow: 'hidden',\n        paddingBottom: 0,\n        marginBottom: 0,\n        paddingTop: 0,\n        marginTop: 0,\n        height: 0\n      }, opacity && {\n        opacity: 0\n      }));\n    });\n    el.timeout = window.setTimeout(function () {\n      el.removeAttribute('style');\n      el.style.display = 'none';\n      callback === null || callback === void 0 || callback.call(el);\n      delete el.timeout;\n    }, duration);\n  },\n  down: function down(el) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$duration = _ref2.duration,\n      duration = _ref2$duration === void 0 ? 500 : _ref2$duration,\n      _ref2$opacity = _ref2.opacity,\n      opacity = _ref2$opacity === void 0 ? false : _ref2$opacity,\n      callback = _ref2.callback;\n    if (el.timeout || window.getComputedStyle(el).display !== 'none') return;\n    el.style.display = 'block';\n    var height = el.offsetHeight + 'px';\n    var animateProps = ['padding-bottom', 'margin-bottom', 'padding-top', 'margin-top'];\n    var resetProps = ['transition-duration', 'transition-property', 'box-sizing', 'overflow', 'opacity', 'height'];\n    Object.assign(el.style, _objectSpread({\n      transitionProperty: 'height, margin, padding, opacity',\n      boxSizing: 'border-box',\n      overflow: 'hidden',\n      paddingBottom: 0,\n      marginBottom: 0,\n      paddingTop: 0,\n      marginTop: 0,\n      height: 0\n    }, opacity && {\n      opacity: 0\n    }));\n    requestAnimationFrame(function () {\n      el.offsetHeight;\n      Object.assign(el.style, {\n        transitionDuration: duration + 'ms',\n        opacity: 1,\n        height: height\n      });\n      requestAnimationFrame(function () {\n        animateProps.forEach(function (pr) {\n          return el.style.removeProperty(pr);\n        });\n      });\n    });\n    el.timeout = window.setTimeout(function () {\n      resetProps.forEach(function (pr) {\n        return el.style.removeProperty(pr);\n      });\n      callback === null || callback === void 0 || callback.call(el);\n      delete el.timeout;\n    }, duration);\n  },\n  toggle: function toggle(el, options) {\n    return window.getComputedStyle(el).display === 'none' ? (this.down(el, options), true) : (this.up(el, options), false);\n  },\n  accordion: function accordion(items) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$cls = options.cls,\n      cls = _options$cls === void 0 ? 'opened' : _options$cls,\n      _options$events = options.events,\n      events = _options$events === void 0 ? 'click' : _options$events,\n      _options$duration = options.duration,\n      duration = _options$duration === void 0 ? 400 : _options$duration,\n      _options$toggle = options.toggle,\n      toggle = _options$toggle === void 0 ? false : _options$toggle;\n    var slide = this;\n    events.split(/\\s+/).forEach(function (event) {\n      items.forEach(function (item) {\n        var content = item.nextElementSibling;\n        var parent = item.parentNode;\n        item.addEventListener(event, function (e) {\n          var _this = this;\n          e.stopPropagation();\n          if (options.lock) return;\n          items.forEach(function (other) {\n            if (other != _this) {\n              slide.up(other.nextElementSibling, {\n                duration: duration\n              });\n              other.parentNode.classList.remove(cls);\n            }\n          });\n          if (toggle) {\n            parent.classList.toggle(cls, slide.toggle(content, {\n              duration: duration\n            }));\n          } else {\n            slide.down(content, {\n              duration: duration\n            });\n            parent.classList.add(cls);\n          }\n          options.lock = window.setTimeout(function () {\n            delete options.lock;\n          }, duration);\n        });\n      });\n    });\n  },\n  accordionSimple: function accordionSimple(items) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$events2 = options.events,\n      events = _options$events2 === void 0 ? 'click' : _options$events2,\n      _options$toggle2 = options.toggle,\n      toggle = _options$toggle2 === void 0 ? false : _options$toggle2,\n      _options$cls2 = options.cls,\n      cls = _options$cls2 === void 0 ? 'opened' : _options$cls2;\n    events.split(' ').forEach(function (event) {\n      items.forEach(function (item) {\n        item.addEventListener(event, function (e) {\n          var _this2 = this;\n          e.stopPropagation();\n          items.forEach(function (other) {\n            return other !== _this2 && other.classList.remove(cls);\n          });\n          this.classList.contains(cls) || this.classList[toggle ? 'toggle' : 'add'](cls);\n        });\n      });\n    });\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (driveSlide);\nvar up = driveSlide.up,\n  down = driveSlide.down,\n  toggle = driveSlide.toggle,\n  accordion = driveSlide.accordion,\n  accordionSimple = driveSlide.accordionSimple;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLENBQUNwQixHQUFHLENBQUM7VUFBQSxFQUFDO1VBQ3ZFLElBQUksQ0FBQ21CLFNBQVMsQ0FBQ1EsUUFBUSxDQUFDM0IsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDbUIsU0FBUyxDQUFFeEIsTUFBTSxHQUFHLFFBQVEsR0FBRyxLQUFLLENBQUUsQ0FBQ0ssR0FBRyxDQUFDO1FBQ2pGLENBQUMsQ0FBQztNQUNILENBQUMsQ0FBQztJQUNILENBQUMsQ0FBQztFQUNIO0FBQ0QsQ0FBQztBQUVELGlFQUFlaEQsVUFBVSxFQUFDO0FBQ25CLElBQVFDLEVBQUUsR0FBK0NELFVBQVUsQ0FBM0RDLEVBQUU7RUFBRWlDLElBQUksR0FBeUNsQyxVQUFVLENBQXZEa0MsSUFBSTtFQUFFUyxNQUFNLEdBQWlDM0MsVUFBVSxDQUFqRDJDLE1BQU07RUFBRUUsU0FBUyxHQUFzQjdDLFVBQVUsQ0FBekM2QyxTQUFTO0VBQUV5QixlQUFlLEdBQUt0RSxVQUFVLENBQTlCc0UsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2d1bHAtc2Nzcy1zdGFydGVyLy4vc3JjL2pzL2xpYnMvZHJpdmVTbGlkZS5qcz9lYzgwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRyaXZlU2xpZGUgPSB7XHJcblxyXG5cdHVwKGVsLCB7IGR1cmF0aW9uID0gNTAwLCBvcGFjaXR5ID0gZmFsc2UsIGNhbGxiYWNrIH0gPSB7fSkge1xyXG5cdFx0aWYgKGVsLnRpbWVvdXQgfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpc3BsYXkgPT09ICdub25lJykgcmV0dXJuO1xyXG5cdFx0ZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcblx0XHRcdFx0XHJcblx0XHRPYmplY3QuYXNzaWduKGVsLnN0eWxlLCB7XHJcblx0XHRcdHRyYW5zaXRpb25Qcm9wZXJ0eTogJ2hlaWdodCwgbWFyZ2luLCBwYWRkaW5nLCBvcGFjaXR5JyxcclxuXHRcdFx0dHJhbnNpdGlvbkR1cmF0aW9uOiBkdXJhdGlvbiArICdtcycsXHJcblx0XHRcdGhlaWdodDogZWwub2Zmc2V0SGVpZ2h0ICsgJ3B4JyxcclxuXHRcdFx0Ym94U2l6aW5nOiAnYm9yZGVyLWJveCcsXHJcblx0XHRcdG9wYWNpdHk6IDEsXHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG5cdFx0XHRlbC5vZmZzZXRIZWlnaHQ7XHJcblx0XHRcdE9iamVjdC5hc3NpZ24oZWwuc3R5bGUsIHtcclxuXHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXHJcblx0XHRcdFx0cGFkZGluZ0JvdHRvbTogMCxcclxuXHRcdFx0XHRtYXJnaW5Cb3R0b206IDAsXHJcblx0XHRcdFx0cGFkZGluZ1RvcDogMCxcclxuXHRcdFx0XHRtYXJnaW5Ub3A6IDAsXHJcblx0XHRcdFx0aGVpZ2h0OiAwLFxyXG5cdFx0XHRcdC4uLm9wYWNpdHkgJiYgeyBvcGFjaXR5OiAwIH1cclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcclxuXHRcdGVsLnRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuXHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHRcdFx0Y2FsbGJhY2s/LmNhbGwoZWwpO1xyXG5cdFx0XHRkZWxldGUgZWwudGltZW91dDtcclxuXHRcdH0sIGR1cmF0aW9uKTtcclxuXHR9LFxyXG5cclxuXHJcblx0ZG93bihlbCwgeyBkdXJhdGlvbiA9IDUwMCwgb3BhY2l0eSA9IGZhbHNlLCBjYWxsYmFjayB9ID0ge30pIHtcclxuXHRcdGlmIChlbC50aW1lb3V0IHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5kaXNwbGF5ICE9PSAnbm9uZScpIHJldHVybjtcclxuXHRcdGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG5cclxuXHRcdGNvbnN0IGhlaWdodCA9IGVsLm9mZnNldEhlaWdodCArICdweCc7XHJcblx0XHRjb25zdCBhbmltYXRlUHJvcHMgPSBbJ3BhZGRpbmctYm90dG9tJywgJ21hcmdpbi1ib3R0b20nLCAncGFkZGluZy10b3AnLCAnbWFyZ2luLXRvcCddO1xyXG5cdFx0Y29uc3QgcmVzZXRQcm9wcyA9IFtcclxuXHRcdFx0J3RyYW5zaXRpb24tZHVyYXRpb24nLFxyXG5cdFx0XHQndHJhbnNpdGlvbi1wcm9wZXJ0eScsXHJcblx0XHRcdCdib3gtc2l6aW5nJyxcclxuXHRcdFx0J292ZXJmbG93JyxcclxuXHRcdFx0J29wYWNpdHknLFxyXG5cdFx0XHQnaGVpZ2h0JyxcclxuXHRcdF07XHJcblx0XHJcblx0XHRPYmplY3QuYXNzaWduKGVsLnN0eWxlLCB7XHJcblx0XHRcdHRyYW5zaXRpb25Qcm9wZXJ0eTogJ2hlaWdodCwgbWFyZ2luLCBwYWRkaW5nLCBvcGFjaXR5JyxcclxuXHRcdFx0Ym94U2l6aW5nOiAnYm9yZGVyLWJveCcsXHJcblx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcclxuXHRcdFx0cGFkZGluZ0JvdHRvbTogMCxcclxuXHRcdFx0bWFyZ2luQm90dG9tOiAwLFxyXG5cdFx0XHRwYWRkaW5nVG9wOiAwLFxyXG5cdFx0XHRtYXJnaW5Ub3A6IDAsXHJcblx0XHRcdGhlaWdodDogMCxcclxuXHRcdFx0Li4ub3BhY2l0eSAmJiB7IG9wYWNpdHk6IDAgfVxyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcblx0XHRcdGVsLm9mZnNldEhlaWdodDtcclxuXHRcdFx0T2JqZWN0LmFzc2lnbihlbC5zdHlsZSwge1xyXG5cdFx0XHRcdHRyYW5zaXRpb25EdXJhdGlvbjogZHVyYXRpb24gKyAnbXMnLFxyXG5cdFx0XHRcdG9wYWNpdHk6IDEsXHJcblx0XHRcdFx0aGVpZ2h0LFxyXG5cdFx0XHR9KTtcclxuXHRcdFxyXG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG5cdFx0XHRcdGFuaW1hdGVQcm9wcy5mb3JFYWNoKHByID0+IGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHJcblx0XHRlbC50aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRyZXNldFByb3BzLmZvckVhY2gocHIgPT4gZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkocHIpKTtcclxuXHRcdFx0Y2FsbGJhY2s/LmNhbGwoZWwpO1xyXG5cdFx0XHRkZWxldGUgZWwudGltZW91dDtcclxuXHRcdH0sIGR1cmF0aW9uKTtcclxuXHR9LFxyXG5cclxuXHJcblx0dG9nZ2xlKGVsLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpc3BsYXkgPT09ICdub25lJ1xyXG5cdFx0XHQ/ICh0aGlzLmRvd24oZWwsIG9wdGlvbnMpLCB0cnVlKVxyXG5cdFx0XHQ6ICh0aGlzLnVwKGVsLCBvcHRpb25zKSwgZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cclxuXHRhY2NvcmRpb24oaXRlbXMsIG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRjbHMgPSAnb3BlbmVkJyxcclxuXHRcdFx0ZXZlbnRzID0gJ2NsaWNrJyxcclxuXHRcdFx0ZHVyYXRpb24gPSA0MDAsXHJcblx0XHRcdHRvZ2dsZSA9IGZhbHNlXHJcblx0XHR9ID0gb3B0aW9ucztcclxuXHRcclxuXHRcdGNvbnN0IHNsaWRlID0gdGhpcztcclxuXHRcdFxyXG5cdFx0ZXZlbnRzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChldmVudCA9PiB7XHJcblx0XHRcdGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGl0ZW0ubmV4dEVsZW1lbnRTaWJsaW5nO1xyXG5cdFx0XHRcdGNvbnN0IHBhcmVudCA9IGl0ZW0ucGFyZW50Tm9kZTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpdGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5sb2NrKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0aXRlbXMuZm9yRWFjaChvdGhlciA9PiB7XHJcblx0XHRcdFx0XHRcdGlmIChvdGhlciAhPSB0aGlzKSB7XHJcblx0XHRcdFx0XHRcdFx0c2xpZGUudXAob3RoZXIubmV4dEVsZW1lbnRTaWJsaW5nLCB7IGR1cmF0aW9uIH0pO1xyXG5cdFx0XHRcdFx0XHRcdG90aGVyLnBhcmVudE5vZGUuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcclxuXHRcdFx0XHRcdGlmICh0b2dnbGUpIHtcclxuXHRcdFx0XHRcdFx0cGFyZW50LmNsYXNzTGlzdC50b2dnbGUoY2xzLCBzbGlkZS50b2dnbGUoY29udGVudCwgeyBkdXJhdGlvbiB9KSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRzbGlkZS5kb3duKGNvbnRlbnQsIHsgZHVyYXRpb24gfSk7XHJcblx0XHRcdFx0XHRcdHBhcmVudC5jbGFzc0xpc3QuYWRkKGNscyk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b3B0aW9ucy5sb2NrID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgb3B0aW9ucy5sb2NrO1xyXG5cdFx0XHRcdFx0fSwgZHVyYXRpb24pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cclxuXHRhY2NvcmRpb25TaW1wbGUoaXRlbXMsIG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRldmVudHMgPSAnY2xpY2snLFxyXG5cdFx0XHR0b2dnbGUgPSBmYWxzZSxcclxuXHRcdFx0Y2xzID0gJ29wZW5lZCdcclxuXHRcdH0gPSBvcHRpb25zO1xyXG5cclxuXHRcdGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xyXG5cdFx0XHRpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG5cdFx0XHRcdGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdFx0XHRpdGVtcy5mb3JFYWNoKG90aGVyID0+IChvdGhlciAhPT0gdGhpcykgJiYgb3RoZXIuY2xhc3NMaXN0LnJlbW92ZShjbHMpKTtcclxuXHRcdFx0XHRcdHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGNscykgfHwgdGhpcy5jbGFzc0xpc3RbKHRvZ2dsZSA/ICd0b2dnbGUnIDogJ2FkZCcpXShjbHMpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGRyaXZlU2xpZGU7XHJcbmV4cG9ydCBjb25zdCB7IHVwLCBkb3duLCB0b2dnbGUsIGFjY29yZGlvbiwgYWNjb3JkaW9uU2ltcGxlIH0gPSBkcml2ZVNsaWRlOyJdLCJuYW1lcyI6WyJkcml2ZVNsaWRlIiwidXAiLCJlbCIsIl9yZWYiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJfcmVmJGR1cmF0aW9uIiwiZHVyYXRpb24iLCJfcmVmJG9wYWNpdHkiLCJvcGFjaXR5IiwiY2FsbGJhY2siLCJ0aW1lb3V0Iiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImRpc3BsYXkiLCJzdHlsZSIsIk9iamVjdCIsImFzc2lnbiIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb25EdXJhdGlvbiIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsImJveFNpemluZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9vYmplY3RTcHJlYWQiLCJvdmVyZmxvdyIsInBhZGRpbmdCb3R0b20iLCJtYXJnaW5Cb3R0b20iLCJwYWRkaW5nVG9wIiwibWFyZ2luVG9wIiwic2V0VGltZW91dCIsInJlbW92ZUF0dHJpYnV0ZSIsImNhbGwiLCJkb3duIiwiX3JlZjIiLCJfcmVmMiRkdXJhdGlvbiIsIl9yZWYyJG9wYWNpdHkiLCJhbmltYXRlUHJvcHMiLCJyZXNldFByb3BzIiwiZm9yRWFjaCIsInByIiwicmVtb3ZlUHJvcGVydHkiLCJ0b2dnbGUiLCJvcHRpb25zIiwiYWNjb3JkaW9uIiwiaXRlbXMiLCJfb3B0aW9ucyRjbHMiLCJjbHMiLCJfb3B0aW9ucyRldmVudHMiLCJldmVudHMiLCJfb3B0aW9ucyRkdXJhdGlvbiIsIl9vcHRpb25zJHRvZ2dsZSIsInNsaWRlIiwic3BsaXQiLCJldmVudCIsIml0ZW0iLCJjb250ZW50IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwicGFyZW50IiwicGFyZW50Tm9kZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiX3RoaXMiLCJzdG9wUHJvcGFnYXRpb24iLCJsb2NrIiwib3RoZXIiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJhZGQiLCJhY2NvcmRpb25TaW1wbGUiLCJfb3B0aW9ucyRldmVudHMyIiwiX29wdGlvbnMkdG9nZ2xlMiIsIl9vcHRpb25zJGNsczIiLCJfdGhpczIiLCJjb250YWlucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/libs/driveSlide.js\n");

/***/ }),

/***/ "./src/js/libs/fieldValidate.js":
/*!**************************************!*\
  !*** ./src/js/libs/fieldValidate.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fieldValidate: () => (/* binding */ fieldValidate)\n/* harmony export */ });\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n/*\r\n* Валидация поля формы по data-атрибуту data-rules\r\n* \r\n* @типичная разметка\r\n* <input data-rules=\"req,email,min:8\">\r\n* \r\n* Поддерживаемые правила:\r\n* - req — обязательное поле\r\n* - email — проверка email\r\n* - phone — номер телефона\r\n* - name — имя (буквы, дефис, пробел)\r\n* - num — только цифры\r\n* - min:8 — минимальная длина\r\n* \r\n* @типичное исползование\r\n* \r\nimport { fieldValidate } from \"../../js/libs/fieldValidate\";\r\n\r\n(() => {\r\n\tconst form = document.querySelector('form.form__inner');\r\n\tif (! form) return;\r\n\r\n\tconst inputs = form.querySelectorAll('.form__field input');\r\n\r\n\tconst validate = function(input) {\r\n\t\tconst check = fieldValidate(input, 'en');\r\n\t\tinput.parentNode.classList.toggle('error', !check.valid);\r\n\t\tinput.parentNode.querySelector('.form__error').innerText = check.message ?? '';\r\n\t}\r\n\r\n\tinputs.forEach(input => {\r\n\t\t['change', 'blur'].forEach(event => {\r\n\t\t\tinput.addEventListener(event, e => validate(input));\r\n\t\t});\r\n\t});\r\n\r\n\tform.addEventListener('submit', e => {\r\n\t\te.preventDefault();\r\n\t\tinputs.forEach(input => validate(input));\r\n\t});\r\n\r\n})();\r\n* \r\n*/\n\nvar messages = {\n  ru: {\n    omit: 'Это поле должно быть пустым',\n    req: 'Поле обязательно для заполнения',\n    email: 'Введите корректный email',\n    phone: 'Введите корректный номер телефона',\n    name: 'Имя содержит недопустимые символы',\n    num: 'Поле должно содержать только цифры',\n    url: 'Введите корректный URL',\n    login: 'Логин должен содержать только латинские буквы, цифры, дефис или подчёркивание',\n    password: 'Пароль должен содержать минимум одну букву и цифру',\n    min: function min(n) {\n      return \"\\u041C\\u0438\\u043D\\u0438\\u043C\\u0443\\u043C \".concat(n, \" \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u043E\\u0432\");\n    },\n    max: function max(n) {\n      return \"\\u041C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0443\\u043C \".concat(n, \" \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u043E\\u0432\");\n    },\n    exact: function exact(n) {\n      return \"\\u0414\\u043E\\u043B\\u0436\\u043D\\u043E \\u0431\\u044B\\u0442\\u044C \\u0440\\u043E\\u0432\\u043D\\u043E \".concat(n, \" \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u043E\\u0432\");\n    },\n    unknown: function unknown(rule) {\n      return \"\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430 \\u0432\\u0430\\u043B\\u0438\\u0434\\u0430\\u0446\\u0438\\u0438: \".concat(rule);\n    }\n  },\n  en: {\n    omit: 'This field must be left blank',\n    req: 'This field is required',\n    email: 'Enter a valid email address',\n    phone: 'Enter a valid phone number',\n    name: 'Name contains invalid characters',\n    num: 'Only digits are allowed',\n    url: 'Enter a valid URL',\n    login: 'Login may contain only Latin letters, numbers, dashes or underscores',\n    password: 'Password must contain at least one letter and one digit',\n    min: function min(n) {\n      return \"Minimum \".concat(n, \" characters\");\n    },\n    max: function max(n) {\n      return \"Maximum \".concat(n, \" characters\");\n    },\n    exact: function exact(n) {\n      return \"Must be exactly \".concat(n, \" characters\");\n    },\n    unknown: function unknown(rule) {\n      return \"Validation error: \".concat(rule);\n    }\n  }\n};\nvar fieldValidate = function fieldValidate(input) {\n  var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ru';\n  if (!input || !input.dataset.rules) {\n    var _messages$lang;\n    return {\n      valid: false,\n      message: ((_messages$lang = messages[lang]) === null || _messages$lang === void 0 ? void 0 : _messages$lang.unknown('input')) || 'Validation error'\n    };\n  }\n  var value = input.value.trim();\n  var rules = input.dataset.rules.split(',').map(function (r) {\n    return r.trim();\n  }).filter(Boolean);\n  var patterns = {\n    req: /.+/,\n    num: /^\\d*$/,\n    omit: /^$/,\n    name: /^[a-zA-Zа-яА-ЯёЁ\\s-]+$/,\n    phone: /^\\+?\\d{1,4}[-\\d()\\s]{5,20}$/,\n    email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\n    url: /^(https?:\\/\\/)?([\\w.-]+)\\.([a-z]{2,})(\\/[\\w\\-._~:/?#[\\]@!$&'()*+,;=]*)?$/i,\n    password: /^(?=.*[A-Za-z])(?=.*\\d).{6,}$/,\n    login: /^[a-zA-Z0-9_-]+$/\n  };\n  var _iterator = _createForOfIteratorHelper(rules),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var rule = _step.value;\n      if (rule.startsWith('min:')) {\n        var _messages$lang2;\n        var len = +rule.slice(4);\n        if (value.length < len) return {\n          valid: false,\n          message: (_messages$lang2 = messages[lang]) === null || _messages$lang2 === void 0 ? void 0 : _messages$lang2.min(len)\n        };\n        continue;\n      }\n      if (rule.startsWith('max:')) {\n        var _messages$lang3;\n        var _len = +rule.slice(4);\n        if (value.length > _len) return {\n          valid: false,\n          message: (_messages$lang3 = messages[lang]) === null || _messages$lang3 === void 0 ? void 0 : _messages$lang3.max(_len)\n        };\n        continue;\n      }\n      if (rule.startsWith('exact:')) {\n        var _messages$lang4;\n        var _len2 = +rule.slice(6);\n        if (value.length !== _len2) return {\n          valid: false,\n          message: (_messages$lang4 = messages[lang]) === null || _messages$lang4 === void 0 ? void 0 : _messages$lang4.exact(_len2)\n        };\n        continue;\n      }\n      if (patterns[rule]) {\n        var _messages$lang5;\n        if (!patterns[rule].test(value)) return {\n          valid: false,\n          message: (_messages$lang5 = messages[lang]) === null || _messages$lang5 === void 0 ? void 0 : _messages$lang5[rule]\n        };\n        continue;\n      }\n      if (!rule.includes(':')) {\n        var _messages$lang6;\n        console.warn(\"\\u041D\\u0435\\u0438\\u0437\\u0432\\u0435\\u0441\\u0442\\u043D\\u043E\\u0435 \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u043E: \".concat(rule));\n        return {\n          valid: false,\n          message: (_messages$lang6 = messages[lang]) === null || _messages$lang6 === void 0 ? void 0 : _messages$lang6.unknown(rule)\n        };\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    valid: true\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3FCLElBQUksQ0FBQyxjQUFBNEIsZUFBQSx1QkFBZEEsZUFBQSxDQUFpQmhDLElBQUk7UUFBRSxDQUFDO1FBQ3pGO01BQ0Q7TUFDQSxJQUFJLENBQUNBLElBQUksQ0FBQ2tDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUFBLElBQUFDLGVBQUE7UUFDeEJDLE9BQU8sQ0FBQ0MsSUFBSSxtSEFBQXpDLE1BQUEsQ0FBeUJJLElBQUksQ0FBRSxDQUFDO1FBQzVDLE9BQU87VUFBRVcsS0FBSyxFQUFFLEtBQUs7VUFBRUMsT0FBTyxHQUFBdUIsZUFBQSxHQUFFcEQsUUFBUSxDQUFDcUIsSUFBSSxDQUFDLGNBQUErQixlQUFBLHVCQUFkQSxlQUFBLENBQWdCcEMsT0FBTyxDQUFDQyxJQUFJO1FBQUUsQ0FBQztNQUNoRTtJQUNEO0VBQUMsU0FBQXNDLEdBQUE7SUFBQWpCLFNBQUEsQ0FBQWtCLENBQUEsQ0FBQUQsR0FBQTtFQUFBO0lBQUFqQixTQUFBLENBQUFtQixDQUFBO0VBQUE7RUFFRCxPQUFPO0lBQUU3QixLQUFLLEVBQUU7RUFBSyxDQUFDO0FBQ3ZCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndWxwLXNjc3Mtc3RhcnRlci8uL3NyYy9qcy9saWJzL2ZpZWxkVmFsaWRhdGUuanM/OWNlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4qINCS0LDQu9C40LTQsNGG0LjRjyDQv9C+0LvRjyDRhNC+0YDQvNGLINC/0L4gZGF0YS3QsNGC0YDQuNCx0YPRgtGDIGRhdGEtcnVsZXNcclxuKiBcclxuKiBA0YLQuNC/0LjRh9C90LDRjyDRgNCw0LfQvNC10YLQutCwXHJcbiogPGlucHV0IGRhdGEtcnVsZXM9XCJyZXEsZW1haWwsbWluOjhcIj5cclxuKiBcclxuKiDQn9C+0LTQtNC10YDQttC40LLQsNC10LzRi9C1INC/0YDQsNCy0LjQu9CwOlxyXG4qIC0gcmVxIOKAlCDQvtCx0Y/Qt9Cw0YLQtdC70YzQvdC+0LUg0L/QvtC70LVcclxuKiAtIGVtYWlsIOKAlCDQv9GA0L7QstC10YDQutCwIGVtYWlsXHJcbiogLSBwaG9uZSDigJQg0L3QvtC80LXRgCDRgtC10LvQtdGE0L7QvdCwXHJcbiogLSBuYW1lIOKAlCDQuNC80Y8gKNCx0YPQutCy0YssINC00LXRhNC40YEsINC/0YDQvtCx0LXQuylcclxuKiAtIG51bSDigJQg0YLQvtC70YzQutC+INGG0LjRhNGA0YtcclxuKiAtIG1pbjo4IOKAlCDQvNC40L3QuNC80LDQu9GM0L3QsNGPINC00LvQuNC90LBcclxuKiBcclxuKiBA0YLQuNC/0LjRh9C90L7QtSDQuNGB0L/QvtC70LfQvtCy0LDQvdC40LVcclxuKiBcclxuaW1wb3J0IHsgZmllbGRWYWxpZGF0ZSB9IGZyb20gXCIuLi8uLi9qcy9saWJzL2ZpZWxkVmFsaWRhdGVcIjtcclxuXHJcbigoKSA9PiB7XHJcblx0Y29uc3QgZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Zvcm0uZm9ybV9faW5uZXInKTtcclxuXHRpZiAoISBmb3JtKSByZXR1cm47XHJcblxyXG5cdGNvbnN0IGlucHV0cyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbCgnLmZvcm1fX2ZpZWxkIGlucHV0Jyk7XHJcblxyXG5cdGNvbnN0IHZhbGlkYXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcclxuXHRcdGNvbnN0IGNoZWNrID0gZmllbGRWYWxpZGF0ZShpbnB1dCwgJ2VuJyk7XHJcblx0XHRpbnB1dC5wYXJlbnROb2RlLmNsYXNzTGlzdC50b2dnbGUoJ2Vycm9yJywgIWNoZWNrLnZhbGlkKTtcclxuXHRcdGlucHV0LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcignLmZvcm1fX2Vycm9yJykuaW5uZXJUZXh0ID0gY2hlY2subWVzc2FnZSA/PyAnJztcclxuXHR9XHJcblxyXG5cdGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcclxuXHRcdFsnY2hhbmdlJywgJ2JsdXInXS5mb3JFYWNoKGV2ZW50ID0+IHtcclxuXHRcdFx0aW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZSA9PiB2YWxpZGF0ZShpbnB1dCkpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgZSA9PiB7XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB2YWxpZGF0ZShpbnB1dCkpO1xyXG5cdH0pO1xyXG5cclxufSkoKTtcclxuKiBcclxuKi9cclxuXHJcbmNvbnN0IG1lc3NhZ2VzID0ge1xyXG5cdHJ1OiB7XHJcblx0XHRvbWl0OiAn0K3RgtC+INC/0L7Qu9C1INC00L7Qu9C20L3QviDQsdGL0YLRjCDQv9GD0YHRgtGL0LwnLFxyXG5cdFx0cmVxOiAn0J/QvtC70LUg0L7QsdGP0LfQsNGC0LXQu9GM0L3QviDQtNC70Y8g0LfQsNC/0L7Qu9C90LXQvdC40Y8nLFxyXG5cdFx0ZW1haWw6ICfQktCy0LXQtNC40YLQtSDQutC+0YDRgNC10LrRgtC90YvQuSBlbWFpbCcsXHJcblx0XHRwaG9uZTogJ9CS0LLQtdC00LjRgtC1INC60L7RgNGA0LXQutGC0L3Ri9C5INC90L7QvNC10YAg0YLQtdC70LXRhNC+0L3QsCcsXHJcblx0XHRuYW1lOiAn0JjQvNGPINGB0L7QtNC10YDQttC40YIg0L3QtdC00L7Qv9GD0YHRgtC40LzRi9C1INGB0LjQvNCy0L7Qu9GLJyxcclxuXHRcdG51bTogJ9Cf0L7Qu9C1INC00L7Qu9C20L3QviDRgdC+0LTQtdGA0LbQsNGC0Ywg0YLQvtC70YzQutC+INGG0LjRhNGA0YsnLFxyXG5cdFx0dXJsOiAn0JLQstC10LTQuNGC0LUg0LrQvtGA0YDQtdC60YLQvdGL0LkgVVJMJyxcclxuXHRcdGxvZ2luOiAn0JvQvtCz0LjQvSDQtNC+0LvQttC10L0g0YHQvtC00LXRgNC20LDRgtGMINGC0L7Qu9GM0LrQviDQu9Cw0YLQuNC90YHQutC40LUg0LHRg9C60LLRiywg0YbQuNGE0YDRiywg0LTQtdGE0LjRgSDQuNC70Lgg0L/QvtC00YfRkdGA0LrQuNCy0LDQvdC40LUnLFxyXG5cdFx0cGFzc3dvcmQ6ICfQn9Cw0YDQvtC70Ywg0LTQvtC70LbQtdC9INGB0L7QtNC10YDQttCw0YLRjCDQvNC40L3QuNC80YPQvCDQvtC00L3RgyDQsdGD0LrQstGDINC4INGG0LjRhNGA0YMnLFxyXG5cdFx0bWluOiAobikgPT4gYNCc0LjQvdC40LzRg9C8ICR7bn0g0YHQuNC80LLQvtC70L7QsmAsXHJcblx0XHRtYXg6IChuKSA9PiBg0JzQsNC60YHQuNC80YPQvCAke259INGB0LjQvNCy0L7Qu9C+0LJgLFxyXG5cdFx0ZXhhY3Q6IChuKSA9PiBg0JTQvtC70LbQvdC+INCx0YvRgtGMINGA0L7QstC90L4gJHtufSDRgdC40LzQstC+0LvQvtCyYCxcclxuXHRcdHVua25vd246IChydWxlKSA9PiBg0J7RiNC40LHQutCwINCy0LDQu9C40LTQsNGG0LjQuDogJHtydWxlfWAsXHJcblx0fSxcclxuXHRlbjoge1xyXG5cdFx0b21pdDogJ1RoaXMgZmllbGQgbXVzdCBiZSBsZWZ0IGJsYW5rJyxcclxuXHRcdHJlcTogJ1RoaXMgZmllbGQgaXMgcmVxdWlyZWQnLFxyXG5cdFx0ZW1haWw6ICdFbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MnLFxyXG5cdFx0cGhvbmU6ICdFbnRlciBhIHZhbGlkIHBob25lIG51bWJlcicsXHJcblx0XHRuYW1lOiAnTmFtZSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMnLFxyXG5cdFx0bnVtOiAnT25seSBkaWdpdHMgYXJlIGFsbG93ZWQnLFxyXG5cdFx0dXJsOiAnRW50ZXIgYSB2YWxpZCBVUkwnLFxyXG5cdFx0bG9naW46ICdMb2dpbiBtYXkgY29udGFpbiBvbmx5IExhdGluIGxldHRlcnMsIG51bWJlcnMsIGRhc2hlcyBvciB1bmRlcnNjb3JlcycsXHJcblx0XHRwYXNzd29yZDogJ1Bhc3N3b3JkIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgbGV0dGVyIGFuZCBvbmUgZGlnaXQnLFxyXG5cdFx0bWluOiAobikgPT4gYE1pbmltdW0gJHtufSBjaGFyYWN0ZXJzYCxcclxuXHRcdG1heDogKG4pID0+IGBNYXhpbXVtICR7bn0gY2hhcmFjdGVyc2AsXHJcblx0XHRleGFjdDogKG4pID0+IGBNdXN0IGJlIGV4YWN0bHkgJHtufSBjaGFyYWN0ZXJzYCxcclxuXHRcdHVua25vd246IChydWxlKSA9PiBgVmFsaWRhdGlvbiBlcnJvcjogJHtydWxlfWAsXHJcblx0fVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBmaWVsZFZhbGlkYXRlID0gKGlucHV0LCBsYW5nID0gJ3J1JykgPT4ge1xyXG5cdGlmICghaW5wdXQgfHwgIWlucHV0LmRhdGFzZXQucnVsZXMpIHtcclxuXHRcdHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogbWVzc2FnZXNbbGFuZ10/LnVua25vd24oJ2lucHV0JykgfHwgJ1ZhbGlkYXRpb24gZXJyb3InIH07XHJcblx0fVxyXG5cclxuXHRjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlLnRyaW0oKTtcclxuXHRjb25zdCBydWxlcyA9IGlucHV0LmRhdGFzZXQucnVsZXMuc3BsaXQoJywnKS5tYXAociA9PiByLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuXHRjb25zdCBwYXR0ZXJucyA9IHtcclxuXHRcdHJlcTogLy4rLyxcclxuXHRcdG51bTogL15cXGQqJC8sXHJcblx0XHRvbWl0OiAvXiQvLFxyXG5cdFx0bmFtZTogL15bYS16QS1a0LAt0Y/QkC3Qr9GR0IFcXHMtXSskLyxcclxuXHRcdHBob25lOiAvXlxcKz9cXGR7MSw0fVstXFxkKClcXHNdezUsMjB9JC8sXHJcblx0XHRlbWFpbDogL15bYS16QS1aMC05Ll8lKy1dK0BbYS16QS1aMC05Li1dK1xcLlthLXpBLVpdezIsfSQvLFxyXG5cdFx0dXJsOiAvXihodHRwcz86XFwvXFwvKT8oW1xcdy4tXSspXFwuKFthLXpdezIsfSkoXFwvW1xcd1xcLS5ffjovPyNbXFxdQCEkJicoKSorLDs9XSopPyQvaSxcclxuXHRcdHBhc3N3b3JkOiAvXig/PS4qW0EtWmEtel0pKD89LipcXGQpLns2LH0kLyxcclxuXHRcdGxvZ2luOiAvXlthLXpBLVowLTlfLV0rJC8sXHJcblx0fTtcclxuXHJcblx0Zm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XHJcblx0XHRpZiAocnVsZS5zdGFydHNXaXRoKCdtaW46JykpIHtcclxuXHRcdFx0Y29uc3QgbGVuID0gK3J1bGUuc2xpY2UoNCk7XHJcblx0XHRcdGlmICh2YWx1ZS5sZW5ndGggPCBsZW4pIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogbWVzc2FnZXNbbGFuZ10/Lm1pbihsZW4pIH07XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHJ1bGUuc3RhcnRzV2l0aCgnbWF4OicpKSB7XHJcblx0XHRcdGNvbnN0IGxlbiA9ICtydWxlLnNsaWNlKDQpO1xyXG5cdFx0XHRpZiAodmFsdWUubGVuZ3RoID4gbGVuKSByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lc3NhZ2U6IG1lc3NhZ2VzW2xhbmddPy5tYXgobGVuKSB9O1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChydWxlLnN0YXJ0c1dpdGgoJ2V4YWN0OicpKSB7XHJcblx0XHRcdGNvbnN0IGxlbiA9ICtydWxlLnNsaWNlKDYpO1xyXG5cdFx0XHRpZiAodmFsdWUubGVuZ3RoICE9PSBsZW4pIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogbWVzc2FnZXNbbGFuZ10/LmV4YWN0KGxlbikgfTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAocGF0dGVybnNbcnVsZV0pIHtcclxuXHRcdFx0aWYgKCFwYXR0ZXJuc1tydWxlXS50ZXN0KHZhbHVlKSkgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBtZXNzYWdlc1tsYW5nXT8uW3J1bGVdIH07XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFydWxlLmluY2x1ZGVzKCc6JykpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKGDQndC10LjQt9Cy0LXRgdGC0L3QvtC1INC/0YDQsNCy0LjQu9C+OiAke3J1bGV9YCk7XHJcblx0XHRcdHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZTogbWVzc2FnZXNbbGFuZ10/LnVua25vd24ocnVsZSkgfTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB7IHZhbGlkOiB0cnVlIH07XHJcbn07Il0sIm5hbWVzIjpbIm1lc3NhZ2VzIiwicnUiLCJvbWl0IiwicmVxIiwiZW1haWwiLCJwaG9uZSIsIm5hbWUiLCJudW0iLCJ1cmwiLCJsb2dpbiIsInBhc3N3b3JkIiwibWluIiwibiIsImNvbmNhdCIsIm1heCIsImV4YWN0IiwidW5rbm93biIsInJ1bGUiLCJlbiIsImZpZWxkVmFsaWRhdGUiLCJpbnB1dCIsImxhbmciLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJkYXRhc2V0IiwicnVsZXMiLCJfbWVzc2FnZXMkbGFuZyIsInZhbGlkIiwibWVzc2FnZSIsInZhbHVlIiwidHJpbSIsInNwbGl0IiwibWFwIiwiciIsImZpbHRlciIsIkJvb2xlYW4iLCJwYXR0ZXJucyIsIl9pdGVyYXRvciIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiX3N0ZXAiLCJzIiwiZG9uZSIsInN0YXJ0c1dpdGgiLCJfbWVzc2FnZXMkbGFuZzIiLCJsZW4iLCJzbGljZSIsIl9tZXNzYWdlcyRsYW5nMyIsIl9tZXNzYWdlcyRsYW5nNCIsIl9tZXNzYWdlcyRsYW5nNSIsInRlc3QiLCJpbmNsdWRlcyIsIl9tZXNzYWdlcyRsYW5nNiIsImNvbnNvbGUiLCJ3YXJuIiwiZXJyIiwiZSIsImYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/libs/fieldValidate.js\n");

/***/ }),

/***/ "./src/js/libs/makeModal.js":
/*!**********************************!*\
  !*** ./src/js/libs/makeModal.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeModal: () => (/* binding */ makeModal),\n/* harmony export */   playbutton: () => (/* binding */ playbutton),\n/* harmony export */   slideshow: () => (/* binding */ slideshow),\n/* harmony export */   thumbnails: () => (/* binding */ thumbnails)\n/* harmony export */ });\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\n/* \r\n* Простое модальное окно. Слушает элементы имеющие data-атрибут с именем \r\n* укзанным в параметре class при вызове (по умолчанию 'modal'). Выборка элементов \r\n* для прослушиваения, может уточняться параметром select при вызове. \r\n* \r\n* <a href=\"./\" data-modal>some content..</a>:\r\n* если нет значения - берет свое содержимое (some content..)\r\n* \r\n* <a href=\"./\" data-modal=\"#someblock\"></a>:\r\n* если начинается с \"#\", то находит элемент с id=\"someblock\"\r\n* \r\n* <a href=\"./\" data-modal=\"./images/somepicture.png\"></a>:\r\n* если значение есть, но НЕ начинается с \"#\" - создает элемент img, в src указывает значение data-modal\r\n* \r\n* <a href=\"./\" data-modal=\"./images/somepicture.png\" rel=\"gallery\"></a>: \r\n* если значение есть, но НЕ начинается с \"#\", а так-же имеет не пустой атрибут \"rel\" - создает элемент img, \r\n* в src указывает значение data-modal и создает галерею, из всех найденных, с таким же \"rel\"\r\n* \r\n* <a href=\"./\" data-modal rel=\"gallery\"><img src=\"./images/somepicture.png\" alt=\"\" /></a>:\r\n* если нет занчения, но есть не пустой атрибут \"rel\" - не создает img, а использует содержимое, как элемент галереи\r\n* \r\n* \r\n* @элемент для прослушивания:\r\n* <span class=\"somebutton\" data-modal=\"#someblock\"></span>\r\n* \r\n* @вызов:\r\n* \r\nimport { makeModal, slideshow, playbutton, thumbnails } from \"../../js/libs/makeModal\";\r\nimport { disablePageScroll, enablePageScroll } from '@fluejs/noscroll';\r\nimport Inputmask from \"inputmask\";\r\n\r\nmakeModal({ \r\n\tclass: 'modal', \r\n\tpreserve: true,\r\n\tclassActive: 'active'\r\n\tselect: '.somebutton', \r\n\tmodules: [ slideshow, playbutton, thumbnails ],\r\n\tslideshow: {\r\n\t\t// navigation: false\r\n\t},\r\n\tinit(underlay) {\r\n\r\n\t},\r\n\topen(modal, button) {\r\n\t\tdisablePageScroll();\r\n\t\t\r\n\t\tInputmask({ \r\n\t\t\t\"mask\": \"+7 (999) 999-99-99\", \r\n\t\t\tshowMaskOnHover: false \r\n\t\t}).mask(this.querySelectorAll('input[type=\"tel\"]'));\r\n\r\n\t\tif (modal.slideshow) {\r\n\t\t\tthis.addEventListener('click', (e) => modal.move());\r\n\t\t}\r\n\t},\r\n\tclose() {\r\n\t\tenablePageScroll();\r\n\t},\r\n\tmove(modal) {\r\n\t\t// работает только если подключен slideshow\r\n\t}\r\n});\r\n* \r\n* @типичная структура html для создания галлереи:\r\n* \r\n<div data-modal=\"./images/someimage-big-1.png\" rel=\"gallery\">\r\n\t<img src=\"./images/someimage-1.png\" alt=\"\" />\r\n</div>\r\n<div data-modal=\"./images/someimage-big-2.png\" rel=\"gallery\">\r\n\t<img src=\"./images/someimage-2.png\" alt=\"\" />\r\n</div>\r\n<div data-modal=\"./images/someimage-big-3.png\" rel=\"gallery\">\r\n\t<img src=\"./images/someimage-3.png\" alt=\"\" />\r\n</div>\r\n* \r\n* @типичные стили для thumbnails:\r\n* \r\n&__thumbs {\r\n\toverflow: hidden;\r\n\r\n\t&-wrapper {\r\n\t\twill-change: transform;\r\n\t\ttouch-action: pan-y;\r\n\t\tdisplay: flex;\r\n\t\tgap: 16px;\r\n\t}\r\n\r\n\t&-slide {\r\n\t\taspect-ratio: 2;\r\n\t\tbackground-size: cover;\r\n\r\n\t\t&.active {\r\n\t\t\toutline: 2px solid orange;\r\n\t\t\toutline-offset: -2px;\r\n\t\t}\r\n\t}\r\n}\r\n* \r\n*/\n\nvar makeModal = function makeModal() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _Modal_brand = /*#__PURE__*/new WeakSet();\n  var Modal = /*#__PURE__*/function () {\n    function Modal(props) {\n      var _this$props$select;\n      _classCallCheck(this, Modal);\n      _classPrivateMethodInitSpec(this, _Modal_brand);\n      this.props = _objectSpread({\n        modules: [],\n        \"class\": 'modal',\n        preserve: false,\n        classActive: 'active'\n      }, props);\n      this.select = (_this$props$select = this.props.select) !== null && _this$props$select !== void 0 ? _this$props$select : \"[data-\".concat(this.props[\"class\"], \"]\");\n      this.modal = document.querySelector(\"#\".concat(this.props[\"class\"], \"__underlay\"));\n      this.body = document.querySelector(\".\".concat(this.props[\"class\"], \"__body\"));\n      this.content = document.querySelector(\".\".concat(this.props[\"class\"], \"__content\"));\n      this._hooks = {\n        open: [],\n        close: []\n      };\n      this.detached = null;\n      _assertClassBrand(_Modal_brand, this, _init).call(this);\n    }\n    return _createClass(Modal, [{\n      key: \"open\",\n      value: function open(source) {\n        var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.open;\n        if (!source) return;\n        this.props.preserve && this.restore();\n        var isData = source.hasAttribute(\"data-\".concat(this.props[\"class\"]));\n        var data = source.dataset[this.props[\"class\"]];\n        var content = null;\n        var mod = 'self';\n        if (source instanceof HTMLElement && !isData) {\n          // Прямо переданный целевой блок\n          mod = 'custom';\n          if (this.props.preserve) {\n            content = source;\n            this.detached = {\n              node: content,\n              parent: content.parentNode,\n              next: content.nextSibling\n            };\n          } else {\n            content = source.cloneNode(true);\n          }\n        } else {\n          // Обычный режим — кнопка с data-modal\n          if (isData && !data) {\n            content = source.innerHTML;\n          } else if (data.startsWith('#')) {\n            var node = document.querySelector(data);\n            mod = data.slice(1);\n            if (this.props.preserve && node) {\n              this.detached = {\n                node: node,\n                parent: node.parentNode,\n                next: node.nextSibling\n              };\n              content = node;\n            } else {\n              content = node === null || node === void 0 ? void 0 : node.innerHTML;\n            }\n          } else {\n            content = document.createElement('img');\n            content.src = data;\n          }\n        }\n        this.modal.className = this.props[\"class\"];\n        this.modal.classList.add(\"\".concat(this.props[\"class\"], \"_\").concat(mod));\n        this.modal.style.display = \"block\";\n        this.content.innerHTML = '';\n        this.content.className = \"\".concat(this.props[\"class\"], \"__content\");\n        this.content['insertAdjacent' + (typeof content === 'string' ? 'HTML' : 'Element')]('beforeend', content !== null && content !== void 0 ? content : '');\n\n        // вызов хука open у плагинов\n        this._hooks.open.forEach(function (open) {\n          return open(source);\n        });\n        cb === null || cb === void 0 || cb.call(this.content, this, source);\n        return true;\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.close;\n        this.modal.className = \"\".concat(this.props[\"class\"]);\n        this.modal.style.display = \"none\";\n        this.buttons(false);\n        this.content.className = \"\".concat(this.props[\"class\"], \"__content\");\n        this.content.innerHTML = '';\n        this.props.preserve && this.restore();\n\n        // вызов хука close у плагинов\n        this._hooks.close.forEach(function (close) {\n          return close();\n        });\n        cb === null || cb === void 0 || cb.call(this.content, this);\n        return false;\n      }\n    }, {\n      key: \"restore\",\n      value: function restore() {\n        if (!this.detached) return;\n        var _this$detached = this.detached,\n          node = _this$detached.node,\n          parent = _this$detached.parent,\n          next = _this$detached.next;\n        ((next === null || next === void 0 ? void 0 : next.parentNode) === parent ? parent.insertBefore : parent.appendChild).call(parent, node, next);\n        this.detached = null;\n      }\n    }, {\n      key: \"buttons\",\n      value: function buttons() {\n        var build = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        if (build) {\n          this.prev = document.createElement('button');\n          this.next = document.createElement('button');\n          this.prev.className = \"\".concat(this.props[\"class\"], \"__button \").concat(this.props[\"class\"], \"__button_prev\");\n          this.next.className = \"\".concat(this.props[\"class\"], \"__button \").concat(this.props[\"class\"], \"__button_next\");\n          this.body.append(this.prev);\n          this.body.append(this.next);\n        } else {\n          var _this$prev, _this$next;\n          (_this$prev = this.prev) === null || _this$prev === void 0 || _this$prev.remove();\n          (_this$next = this.next) === null || _this$next === void 0 || _this$next.remove();\n        }\n      }\n    }]);\n  }();\n  function _underlay() {\n    if (!this.modal) {\n      var underlay = document.createElement('div');\n      var body = document.createElement('div');\n      var close = document.createElement('button');\n      var content = document.createElement('div');\n      underlay.className = \"\".concat(this.props[\"class\"]);\n      underlay.id = \"\".concat(this.props[\"class\"], \"__underlay\");\n      body.className = \"\".concat(this.props[\"class\"], \"__body\");\n      close.className = \"\".concat(this.props[\"class\"], \"__close\");\n      content.className = \"\".concat(this.props[\"class\"], \"__content\");\n      body.append(close);\n      body.append(content);\n      underlay.append(body);\n      document.body.append(underlay);\n      this.modal = underlay;\n      this.body = body;\n      this.content = content;\n    }\n  }\n  function _init() {\n    var _this = this,\n      _this$props$init;\n    _assertClassBrand(_Modal_brand, this, _underlay).call(this);\n\n    // инициализация плагинов и их хуков\n    this.props.modules.forEach(function (plugin) {\n      if (plugin && _typeof(plugin) === 'object') {\n        var _plugin$init;\n        (_plugin$init = plugin.init) === null || _plugin$init === void 0 || _plugin$init.call(plugin, _this, _this.props[plugin.name]);\n        Object.keys(_this._hooks).forEach(function (hook) {\n          if (typeof plugin[hook] === 'function') {\n            _this._hooks[hook].push(plugin[hook].bind(plugin, _this));\n          }\n        });\n      }\n    });\n    document.addEventListener('click', function (e) {\n      var el = e.target.closest(_this.select);\n      if (el && el.hasAttribute(\"data-\".concat(_this.props[\"class\"]))) {\n        e.preventDefault();\n        _this.open(el);\n      }\n      if (e.target == _this.modal || e.target.classList.contains(\"\".concat(_this.props[\"class\"], \"__close\"))) {\n        e.preventDefault();\n        _this.close();\n      }\n    });\n    document.addEventListener('keydown', function (e) {\n      if (_this.modal.style.display === 'block' && (e.key === \"Escape\" || e.key === \"Esc\")) _this.close();\n    });\n    (_this$props$init = this.props.init) === null || _this$props$init === void 0 || _this$props$init.call(this, this.modal);\n  }\n  return new Modal(props);\n};\n\n// плагин галлереи\nvar slideshow = {\n  name: 'slideshow',\n  init: function init(modal) {\n    var _modal$_hooks;\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.props = _objectSpread({\n      navigation: true,\n      classMod: 'gallery'\n    }, props);\n    this.setupSlideshow = function (modal, el) {\n      var _el$attributes$rel,\n        _this2 = this;\n      var rel = (_el$attributes$rel = el.attributes.rel) === null || _el$attributes$rel === void 0 ? void 0 : _el$attributes$rel.value;\n      if (!rel) return;\n      var current = modal.content.querySelector('img, video');\n      var append = false;\n      var counter = 0;\n      _toConsumableArray(document.querySelectorAll(\"[rel=\\\"\".concat(rel, \"\\\"]\"))).forEach(function (item, i) {\n        var source = item.querySelector('img, video');\n        var data = item.dataset[modal.props[\"class\"]];\n        var child = data ? Object.assign(document.createElement('img'), {\n          src: data\n        }) : source.cloneNode();\n        if (child.src === current.src) {\n          Object.assign(current.dataset, source.dataset);\n          append = true;\n          return;\n        }\n        modal.content[append ? 'appendChild' : 'insertBefore'](child, append ? null : current);\n        Object.assign(child.dataset, source.dataset);\n        counter++;\n      });\n      modal.content.classList.add(\"\".concat(modal.props[\"class\"], \"__content_\").concat(this.props.classMod));\n      current.classList.add(\"\".concat(modal.props.classActive));\n      if (counter > 1) {\n        modal.slideshow = modal.content.querySelectorAll('img, video');\n        modal.cnt = _toConsumableArray(modal.slideshow).findIndex(function (item) {\n          return item.classList.contains(modal.props.classActive);\n        });\n        if (this.props.navigation) {\n          modal.buttons();\n          modal.prev.addEventListener('click', function () {\n            return _this2.slideshowMove(-1);\n          });\n          modal.next.addEventListener('click', function () {\n            return _this2.slideshowMove();\n          });\n        }\n      }\n    };\n    this.slideshowMove = function () {\n      var _modal$props$move;\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var isIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var slides = modal.slideshow;\n      slides[modal.cnt].classList.remove(modal.props.classActive);\n      modal.cnt = isIndex ? (value + slides.length) % slides.length : (modal.cnt + value + slides.length) % slides.length;\n      slides[modal.cnt].classList.add(modal.props.classActive);\n      modal._hooks.move.forEach(function (move) {\n        return move();\n      });\n      (_modal$props$move = modal.props.move) === null || _modal$props$move === void 0 || _modal$props$move.call(modal.content, modal);\n    };\n\n    // Добавить новый хук в базовый класс\n    (_modal$_hooks = modal._hooks).move || (_modal$_hooks.move = []);\n\n    // Добавить новый метод в базовый класс\n    modal.move = this.slideshowMove.bind(this);\n  },\n  open: function open(modal, el) {\n    var data = el.dataset[\"\".concat(modal.props[\"class\"])];\n    !!data && data.startsWith('#') || this.setupSlideshow(modal, el);\n  },\n  close: function close(modal) {\n    delete modal.cnt;\n    delete modal.slideshow;\n    delete modal.slideshow;\n  }\n};\n\n// плагин кнопки для воспроизведения видео\nvar playbutton = {\n  name: 'playbutton',\n  init: function init(modal) {\n    this.setPlayButton = function (content, video) {\n      var play = content.querySelector('.modal__play');\n      if (!!(video !== null && video !== void 0 && video.canPlayType)) {\n        video.controls = true;\n        play || (play = document.createElement('button'));\n        play.className = 'modal__play';\n        play.addEventListener('click', function (e) {\n          return video.play();\n        });\n        content.append(play);\n        ['pause', 'ended', 'playing'].forEach(function (event) {\n          video.addEventListener(event, function (e) {\n            play.classList.toggle('playing', !(video.paused || video.ended));\n          });\n        });\n      } else {\n        var _play;\n        content.querySelectorAll('video').forEach(function (video) {\n          return video.pause();\n        });\n        (_play = play) === null || _play === void 0 || _play.remove();\n      }\n    };\n  },\n  open: function open(modal, el) {\n    var content = modal.content,\n      slideshow = modal.slideshow,\n      props = modal.props;\n    var active = slideshow ? \".\".concat(props.classActive) : '';\n    this.setPlayButton(content, content.querySelector(\"video\".concat(active)));\n  },\n  move: function move(modal) {\n    var content = modal.content,\n      props = modal.props;\n    var active = \".\".concat(props.classActive);\n    this.setPlayButton(content, content.querySelector(\"video\".concat(active)));\n  }\n};\n\n// плагин миниатюр для навигации в галерее\nvar thumbnails = {\n  name: 'thumbnails',\n  init: function init(modal) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.props = _objectSpread({\n      count: 4,\n      // сколько миниатюр видно одновременно\n      maxSkip: 3,\n      duration: 0.3,\n      dragThreshold: 5\n    }, props);\n    this.isDragging = false;\n    this.modal = modal;\n    this.index = 0;\n    this._boundOnMove = this.onDrag.bind(this);\n    this._boundOnUp = this.onUp.bind(this);\n  },\n  get slideSize() {\n    return this.slideWidth + this.gap;\n  },\n  get offset() {\n    // на сколько нужно сдвинуть wrapper, чтобы отображалось count слайдов, начиная с нужного индекса\n    return this.index * this.slideSize;\n  },\n  get maxIndex() {\n    // максимально возможный индекс до которого можно прокрутить, чтобы во контейнере было ровно count слайдов\n    return Math.max(0, this.slides.length - this.props.count);\n  },\n  open: function open(modal) {\n    var _this3 = this;\n    if (!modal.slideshow) return;\n\n    // Создаем обертку для миниатюр\n    this.container = document.createElement('div');\n    this.container.className = \"\".concat(modal.props[\"class\"], \"__thumbs\");\n    this.wrapper = document.createElement('div');\n    this.wrapper.className = \"\".concat(modal.props[\"class\"], \"__thumbs-wrapper\");\n\n    // Добавляем миниатюры\n    this.slides = Array.from(modal.slideshow, function (item, i) {\n      var slide = document.createElement('span');\n      slide.className = \"\".concat(modal.props[\"class\"], \"__thumbs-slide\");\n      slide.style.backgroundImage = \"url('\".concat(item.poster || item.src, \"')\");\n      slide.addEventListener('click', function () {\n        return _this3.isDragging || _this3.modal.move(i, true);\n      });\n      _this3.wrapper.appendChild(slide);\n      return slide;\n    });\n\n    // Строим структуру\n    this.container.appendChild(this.wrapper);\n    modal.body.appendChild(this.container);\n    this.setupThumbSizes();\n    this.bindEvents();\n    this.updateActiveThumb();\n\n    // Подписка на переключение слайдов\n    modal._hooks.move.push(this.updateActiveThumb.bind(this));\n  },\n  setupThumbSizes: function setupThumbSizes() {\n    var _this4 = this;\n    var styles = getComputedStyle(this.wrapper);\n    this.gap = parseFloat(styles.gap) || 0;\n    this.slideWidth = (this.container.clientWidth - this.gap * (this.props.count - 1)) / this.props.count;\n    this.slides.forEach(function (slide) {\n      return slide.style.flex = \"0 0 \".concat(_this4.slideWidth, \"px\");\n    });\n    this.movingThumbs(this.index);\n  },\n  onDrag: function onDrag(e) {\n    var dx = e.clientX - this.startX;\n    var total = this.slideSize * this.slides.length - this.gap;\n    var limit = total - this.container.clientWidth + this.slideSize;\n    var offset = Math.max(-limit, Math.min(this.startOffset + dx, this.slideSize));\n    this.wrapper.style.transform = \"translateX(\".concat(offset, \"px)\");\n    this.isDragging || (this.isDragging = Math.abs(dx) > this.props.dragThreshold);\n  },\n  onUp: function onUp(e) {\n    // длина свайпа\n    var dx = e.clientX - this.startX;\n    window.removeEventListener('pointerup', this._boundOnUp);\n    window.removeEventListener('pointermove', this._boundOnMove);\n    window.removeEventListener('pointercancel', this._boundOnUp);\n\n    // сколько слайдов сдвинуть на основе длины свайпа, но не больше, чем разрешено (maxSkip)\n    var movedSlides = Math.min(this.props.maxSkip, Math.round(Math.abs(dx) / this.slideSize));\n\n    // смещение к актуальному индексу\n    movedSlides > 0 ? this.movingThumbs(this.index - Math.sign(dx) * movedSlides) : this.movingThumbs(this.index);\n  },\n  bindEvents: function bindEvents() {\n    var _this5 = this;\n    this.wrapper.addEventListener('pointerdown', function (e) {\n      e.preventDefault();\n      _this5.wrapper.style.transition = 'none';\n      _this5.isDragging = false;\n      _this5.startX = e.clientX;\n      _this5.startOffset = -_this5.index * (_this5.slideWidth + _this5.gap);\n      window.addEventListener('pointerup', _this5._boundOnUp);\n      window.addEventListener('pointermove', _this5._boundOnMove);\n      window.addEventListener('pointercancel', _this5._boundOnUp);\n    }, {\n      passive: false\n    });\n    this.wrapper.querySelectorAll('*').forEach(function (el) {\n      el.addEventListener('click', function (e) {\n        return _this5.isDragging && e.preventDefault();\n      });\n    });\n    window.addEventListener('resize', function () {\n      return _this5.setupThumbSizes();\n    });\n  },\n  movingThumbs: function movingThumbs(i) {\n    this.index = Math.max(0, Math.min(i, this.maxIndex));\n    this.wrapper.style.transition = \"transform \".concat(this.props.duration, \"s\");\n    this.wrapper.style.transform = \"translateX(-\".concat(this.offset, \"px)\");\n  },\n  updateActiveThumb: function updateActiveThumb() {\n    var _this$slides;\n    if (!((_this$slides = this.slides) !== null && _this$slides !== void 0 && _this$slides.length)) return;\n    this.slides.forEach(function (slide) {\n      return slide.classList.remove('active');\n    });\n    this.slides[this.modal.cnt].classList.add('active');\n    this.scrollToActiveThumb();\n  },\n  scrollToActiveThumb: function scrollToActiveThumb() {\n    // Если активный слайд вышел за пределы видимости — подстраиваем индекс\n    if (this.modal.cnt < this.index) {\n      this.movingThumbs(this.modal.cnt);\n    } else if (this.modal.cnt >= this.index + this.props.count) {\n      this.movingThumbs(this.modal.cnt - this.props.count + 1);\n    }\n  },\n  close: function close(modal) {\n    var _this$container;\n    (_this$container = this.container) === null || _this$container === void 0 || _this$container.remove();\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RyxJQUFJLElBQUksQ0FBQzBCLEtBQUssR0FBRyxJQUFJLENBQUNwSSxLQUFLLENBQUMrSCxLQUFLLEVBQUU7TUFDM0QsSUFBSSxDQUFDa0MsWUFBWSxDQUFDLElBQUksQ0FBQ2pKLEtBQUssQ0FBQzBGLEdBQUcsR0FBRyxJQUFJLENBQUMxRyxLQUFLLENBQUMrSCxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ3pEO0VBQ0QsQ0FBQztFQUVEeEcsS0FBSyxXQUFMQSxLQUFLQSxDQUFDUCxLQUFLLEVBQUU7SUFBQSxJQUFBcUssZUFBQTtJQUNaLENBQUFBLGVBQUEsT0FBSSxDQUFDcEMsU0FBUyxjQUFBb0MsZUFBQSxlQUFkQSxlQUFBLENBQWdCbkgsTUFBTSxDQUFDLENBQUM7RUFDekI7QUFDRCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvanMvbGlicy9tYWtlTW9kYWwuanM/YzE4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBcclxuKiDQn9GA0L7RgdGC0L7QtSDQvNC+0LTQsNC70YzQvdC+0LUg0L7QutC90L4uINCh0LvRg9GI0LDQtdGCINGN0LvQtdC80LXQvdGC0Ysg0LjQvNC10Y7RidC40LUgZGF0YS3QsNGC0YDQuNCx0YPRgiDRgSDQuNC80LXQvdC10LwgXHJcbiog0YPQutC30LDQvdC90YvQvCDQsiDQv9Cw0YDQsNC80LXRgtGA0LUgY2xhc3Mg0L/RgNC4INCy0YvQt9C+0LLQtSAo0L/QviDRg9C80L7Qu9GH0LDQvdC40Y4gJ21vZGFsJykuINCS0YvQsdC+0YDQutCwINGN0LvQtdC80LXQvdGC0L7QsiBcclxuKiDQtNC70Y8g0L/RgNC+0YHQu9GD0YjQuNCy0LDQtdC90LjRjywg0LzQvtC20LXRgiDRg9GC0L7Rh9C90Y/RgtGM0YHRjyDQv9Cw0YDQsNC80LXRgtGA0L7QvCBzZWxlY3Qg0L/RgNC4INCy0YvQt9C+0LLQtS4gXHJcbiogXHJcbiogPGEgaHJlZj1cIi4vXCIgZGF0YS1tb2RhbD5zb21lIGNvbnRlbnQuLjwvYT46XHJcbiog0LXRgdC70Lgg0L3QtdGCINC30L3QsNGH0LXQvdC40Y8gLSDQsdC10YDQtdGCINGB0LLQvtC1INGB0L7QtNC10YDQttC40LzQvtC1IChzb21lIGNvbnRlbnQuLilcclxuKiBcclxuKiA8YSBocmVmPVwiLi9cIiBkYXRhLW1vZGFsPVwiI3NvbWVibG9ja1wiPjwvYT46XHJcbiog0LXRgdC70Lgg0L3QsNGH0LjQvdCw0LXRgtGB0Y8g0YEgXCIjXCIsINGC0L4g0L3QsNGF0L7QtNC40YIg0Y3Qu9C10LzQtdC90YIg0YEgaWQ9XCJzb21lYmxvY2tcIlxyXG4qIFxyXG4qIDxhIGhyZWY9XCIuL1wiIGRhdGEtbW9kYWw9XCIuL2ltYWdlcy9zb21lcGljdHVyZS5wbmdcIj48L2E+OlxyXG4qINC10YHQu9C4INC30L3QsNGH0LXQvdC40LUg0LXRgdGC0YwsINC90L4g0J3QlSDQvdCw0YfQuNC90LDQtdGC0YHRjyDRgSBcIiNcIiAtINGB0L7Qt9C00LDQtdGCINGN0LvQtdC80LXQvdGCIGltZywg0LIgc3JjINGD0LrQsNC30YvQstCw0LXRgiDQt9C90LDRh9C10L3QuNC1IGRhdGEtbW9kYWxcclxuKiBcclxuKiA8YSBocmVmPVwiLi9cIiBkYXRhLW1vZGFsPVwiLi9pbWFnZXMvc29tZXBpY3R1cmUucG5nXCIgcmVsPVwiZ2FsbGVyeVwiPjwvYT46IFxyXG4qINC10YHQu9C4INC30L3QsNGH0LXQvdC40LUg0LXRgdGC0YwsINC90L4g0J3QlSDQvdCw0YfQuNC90LDQtdGC0YHRjyDRgSBcIiNcIiwg0LAg0YLQsNC6LdC20LUg0LjQvNC10LXRgiDQvdC1INC/0YPRgdGC0L7QuSDQsNGC0YDQuNCx0YPRgiBcInJlbFwiIC0g0YHQvtC30LTQsNC10YIg0Y3Qu9C10LzQtdC90YIgaW1nLCBcclxuKiDQsiBzcmMg0YPQutCw0LfRi9Cy0LDQtdGCINC30L3QsNGH0LXQvdC40LUgZGF0YS1tb2RhbCDQuCDRgdC+0LfQtNCw0LXRgiDQs9Cw0LvQtdGA0LXRjiwg0LjQtyDQstGB0LXRhSDQvdCw0LnQtNC10L3QvdGL0YUsINGBINGC0LDQutC40Lwg0LbQtSBcInJlbFwiXHJcbiogXHJcbiogPGEgaHJlZj1cIi4vXCIgZGF0YS1tb2RhbCByZWw9XCJnYWxsZXJ5XCI+PGltZyBzcmM9XCIuL2ltYWdlcy9zb21lcGljdHVyZS5wbmdcIiBhbHQ9XCJcIiAvPjwvYT46XHJcbiog0LXRgdC70Lgg0L3QtdGCINC30LDQvdGH0LXQvdC40Y8sINC90L4g0LXRgdGC0Ywg0L3QtSDQv9GD0YHRgtC+0Lkg0LDRgtGA0LjQsdGD0YIgXCJyZWxcIiAtINC90LUg0YHQvtC30LTQsNC10YIgaW1nLCDQsCDQuNGB0L/QvtC70YzQt9GD0LXRgiDRgdC+0LTQtdGA0LbQuNC80L7QtSwg0LrQsNC6INGN0LvQtdC80LXQvdGCINCz0LDQu9C10YDQtdC4XHJcbiogXHJcbiogXHJcbiogQNGN0LvQtdC80LXQvdGCINC00LvRjyDQv9GA0L7RgdC70YPRiNC40LLQsNC90LjRjzpcclxuKiA8c3BhbiBjbGFzcz1cInNvbWVidXR0b25cIiBkYXRhLW1vZGFsPVwiI3NvbWVibG9ja1wiPjwvc3Bhbj5cclxuKiBcclxuKiBA0LLRi9C30L7QsjpcclxuKiBcclxuaW1wb3J0IHsgbWFrZU1vZGFsLCBzbGlkZXNob3csIHBsYXlidXR0b24sIHRodW1ibmFpbHMgfSBmcm9tIFwiLi4vLi4vanMvbGlicy9tYWtlTW9kYWxcIjtcclxuaW1wb3J0IHsgZGlzYWJsZVBhZ2VTY3JvbGwsIGVuYWJsZVBhZ2VTY3JvbGwgfSBmcm9tICdAZmx1ZWpzL25vc2Nyb2xsJztcclxuaW1wb3J0IElucHV0bWFzayBmcm9tIFwiaW5wdXRtYXNrXCI7XHJcblxyXG5tYWtlTW9kYWwoeyBcclxuXHRjbGFzczogJ21vZGFsJywgXHJcblx0cHJlc2VydmU6IHRydWUsXHJcblx0Y2xhc3NBY3RpdmU6ICdhY3RpdmUnXHJcblx0c2VsZWN0OiAnLnNvbWVidXR0b24nLCBcclxuXHRtb2R1bGVzOiBbIHNsaWRlc2hvdywgcGxheWJ1dHRvbiwgdGh1bWJuYWlscyBdLFxyXG5cdHNsaWRlc2hvdzoge1xyXG5cdFx0Ly8gbmF2aWdhdGlvbjogZmFsc2VcclxuXHR9LFxyXG5cdGluaXQodW5kZXJsYXkpIHtcclxuXHJcblx0fSxcclxuXHRvcGVuKG1vZGFsLCBidXR0b24pIHtcclxuXHRcdGRpc2FibGVQYWdlU2Nyb2xsKCk7XHJcblx0XHRcclxuXHRcdElucHV0bWFzayh7IFxyXG5cdFx0XHRcIm1hc2tcIjogXCIrNyAoOTk5KSA5OTktOTktOTlcIiwgXHJcblx0XHRcdHNob3dNYXNrT25Ib3ZlcjogZmFsc2UgXHJcblx0XHR9KS5tYXNrKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInRlbFwiXScpKTtcclxuXHJcblx0XHRpZiAobW9kYWwuc2xpZGVzaG93KSB7XHJcblx0XHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4gbW9kYWwubW92ZSgpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGNsb3NlKCkge1xyXG5cdFx0ZW5hYmxlUGFnZVNjcm9sbCgpO1xyXG5cdH0sXHJcblx0bW92ZShtb2RhbCkge1xyXG5cdFx0Ly8g0YDQsNCx0L7RgtCw0LXRgiDRgtC+0LvRjNC60L4g0LXRgdC70Lgg0L/QvtC00LrQu9GO0YfQtdC9IHNsaWRlc2hvd1xyXG5cdH1cclxufSk7XHJcbiogXHJcbiogQNGC0LjQv9C40YfQvdCw0Y8g0YHRgtGA0YPQutGC0YPRgNCwIGh0bWwg0LTQu9GPINGB0L7Qt9C00LDQvdC40Y8g0LPQsNC70LvQtdGA0LXQuDpcclxuKiBcclxuPGRpdiBkYXRhLW1vZGFsPVwiLi9pbWFnZXMvc29tZWltYWdlLWJpZy0xLnBuZ1wiIHJlbD1cImdhbGxlcnlcIj5cclxuXHQ8aW1nIHNyYz1cIi4vaW1hZ2VzL3NvbWVpbWFnZS0xLnBuZ1wiIGFsdD1cIlwiIC8+XHJcbjwvZGl2PlxyXG48ZGl2IGRhdGEtbW9kYWw9XCIuL2ltYWdlcy9zb21laW1hZ2UtYmlnLTIucG5nXCIgcmVsPVwiZ2FsbGVyeVwiPlxyXG5cdDxpbWcgc3JjPVwiLi9pbWFnZXMvc29tZWltYWdlLTIucG5nXCIgYWx0PVwiXCIgLz5cclxuPC9kaXY+XHJcbjxkaXYgZGF0YS1tb2RhbD1cIi4vaW1hZ2VzL3NvbWVpbWFnZS1iaWctMy5wbmdcIiByZWw9XCJnYWxsZXJ5XCI+XHJcblx0PGltZyBzcmM9XCIuL2ltYWdlcy9zb21laW1hZ2UtMy5wbmdcIiBhbHQ9XCJcIiAvPlxyXG48L2Rpdj5cclxuKiBcclxuKiBA0YLQuNC/0LjRh9C90YvQtSDRgdGC0LjQu9C4INC00LvRjyB0aHVtYm5haWxzOlxyXG4qIFxyXG4mX190aHVtYnMge1xyXG5cdG92ZXJmbG93OiBoaWRkZW47XHJcblxyXG5cdCYtd3JhcHBlciB7XHJcblx0XHR3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xyXG5cdFx0dG91Y2gtYWN0aW9uOiBwYW4teTtcclxuXHRcdGRpc3BsYXk6IGZsZXg7XHJcblx0XHRnYXA6IDE2cHg7XHJcblx0fVxyXG5cclxuXHQmLXNsaWRlIHtcclxuXHRcdGFzcGVjdC1yYXRpbzogMjtcclxuXHRcdGJhY2tncm91bmQtc2l6ZTogY292ZXI7XHJcblxyXG5cdFx0Ji5hY3RpdmUge1xyXG5cdFx0XHRvdXRsaW5lOiAycHggc29saWQgb3JhbmdlO1xyXG5cdFx0XHRvdXRsaW5lLW9mZnNldDogLTJweDtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuKiBcclxuKi9cclxuXHJcbmV4cG9ydCBjb25zdCBtYWtlTW9kYWwgPSBmdW5jdGlvbihwcm9wcyA9IHt9KSB7XHJcblx0Y2xhc3MgTW9kYWwge1xyXG5cdFx0Y29uc3RydWN0b3IocHJvcHMpIHtcclxuXHRcdFx0dGhpcy5wcm9wcyA9IHtcclxuXHRcdFx0XHRtb2R1bGVzOiBbXSxcclxuXHRcdFx0XHRjbGFzczogJ21vZGFsJyxcclxuXHRcdFx0XHRwcmVzZXJ2ZTogZmFsc2UsXHJcblx0XHRcdFx0Y2xhc3NBY3RpdmU6ICdhY3RpdmUnLFxyXG5cdFx0XHRcdC4uLnByb3BzXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR0aGlzLnNlbGVjdCA9IHRoaXMucHJvcHMuc2VsZWN0ID8/IGBbZGF0YS0ke3RoaXMucHJvcHMuY2xhc3N9XWA7XHJcblx0XHRcdHRoaXMubW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHt0aGlzLnByb3BzLmNsYXNzfV9fdW5kZXJsYXlgKTtcclxuXHRcdFx0dGhpcy5ib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5wcm9wcy5jbGFzc31fX2JvZHlgKTtcclxuXHRcdFx0dGhpcy5jb250ZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5wcm9wcy5jbGFzc31fX2NvbnRlbnRgKTtcclxuXHRcdFx0dGhpcy5faG9va3MgPSB7IG9wZW46IFtdLCBjbG9zZTogW10gfTtcclxuXHRcdFx0dGhpcy5kZXRhY2hlZCA9IG51bGw7XHJcblxyXG5cdFx0XHR0aGlzLiNpbml0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0b3Blbihzb3VyY2UsIGNiID0gdGhpcy5wcm9wcy5vcGVuKSB7XHJcblx0XHRcdGlmICghIHNvdXJjZSkgcmV0dXJuO1xyXG5cdFx0XHR0aGlzLnByb3BzLnByZXNlcnZlICYmIHRoaXMucmVzdG9yZSgpO1xyXG5cclxuXHRcdFx0Y29uc3QgaXNEYXRhID0gc291cmNlLmhhc0F0dHJpYnV0ZShgZGF0YS0ke3RoaXMucHJvcHMuY2xhc3N9YCk7XHJcblx0XHRcdGNvbnN0IGRhdGEgPSBzb3VyY2UuZGF0YXNldFt0aGlzLnByb3BzLmNsYXNzXTtcclxuXHRcdFx0bGV0IGNvbnRlbnQgPSBudWxsO1xyXG5cdFx0XHRsZXQgbW9kID0gJ3NlbGYnO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmICFpc0RhdGEpIHtcclxuXHRcdFx0XHQvLyDQn9GA0Y/QvNC+INC/0LXRgNC10LTQsNC90L3Ri9C5INGG0LXQu9C10LLQvtC5INCx0LvQvtC6XHJcblx0XHRcdFx0bW9kID0gJ2N1c3RvbSc7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKHRoaXMucHJvcHMucHJlc2VydmUpIHtcclxuXHRcdFx0XHRcdGNvbnRlbnQgPSBzb3VyY2U7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5kZXRhY2hlZCA9IHsgXHJcblx0XHRcdFx0XHRcdG5vZGU6IGNvbnRlbnQsIFxyXG5cdFx0XHRcdFx0XHRwYXJlbnQ6IGNvbnRlbnQucGFyZW50Tm9kZSwgXHJcblx0XHRcdFx0XHRcdG5leHQ6IGNvbnRlbnQubmV4dFNpYmxpbmcgXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnRlbnQgPSBzb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyDQntCx0YvRh9C90YvQuSDRgNC10LbQuNC8IOKAlCDQutC90L7Qv9C60LAg0YEgZGF0YS1tb2RhbFxyXG5cdFx0XHRcdGlmIChpc0RhdGEgJiYgIWRhdGEpIHtcclxuXHRcdFx0XHRcdGNvbnRlbnQgPSBzb3VyY2UuaW5uZXJIVE1MO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKGRhdGEuc3RhcnRzV2l0aCgnIycpKSB7XHJcblx0XHRcdFx0XHRjb25zdCBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihkYXRhKTtcclxuXHRcdFx0XHRcdG1vZCA9IGRhdGEuc2xpY2UoMSk7XHJcblx0XHRcclxuXHRcdFx0XHRcdGlmICh0aGlzLnByb3BzLnByZXNlcnZlICYmIG5vZGUpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5kZXRhY2hlZCA9IHsgbm9kZSwgcGFyZW50OiBub2RlLnBhcmVudE5vZGUsIG5leHQ6IG5vZGUubmV4dFNpYmxpbmcgfTtcclxuXHRcdFx0XHRcdFx0Y29udGVudCA9IG5vZGU7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Y29udGVudCA9IG5vZGU/LmlubmVySFRNTDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdFx0XHRcdGNvbnRlbnQuc3JjID0gZGF0YTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFxyXG5cdFx0XHR0aGlzLm1vZGFsLmNsYXNzTmFtZSA9IHRoaXMucHJvcHMuY2xhc3M7XHJcblx0XHRcdHRoaXMubW9kYWwuY2xhc3NMaXN0LmFkZChgJHt0aGlzLnByb3BzLmNsYXNzfV8ke21vZH1gKTtcclxuXHRcdFx0dGhpcy5tb2RhbC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5jb250ZW50LmlubmVySFRNTCA9ICcnO1xyXG5cdFx0XHR0aGlzLmNvbnRlbnQuY2xhc3NOYW1lID0gYCR7dGhpcy5wcm9wcy5jbGFzc31fX2NvbnRlbnRgO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5jb250ZW50WydpbnNlcnRBZGphY2VudCcgKyAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnID8gJ0hUTUwnIDogJ0VsZW1lbnQnKV0oJ2JlZm9yZWVuZCcsIGNvbnRlbnQgPz8gJycpO1xyXG5cdFx0XHJcblx0XHRcdC8vINCy0YvQt9C+0LIg0YXRg9C60LAgb3BlbiDRgyDQv9C70LDQs9C40L3QvtCyXHJcblx0XHRcdHRoaXMuX2hvb2tzLm9wZW4uZm9yRWFjaChvcGVuID0+IG9wZW4oc291cmNlKSk7XHJcblx0XHRcdGNiPy5jYWxsKHRoaXMuY29udGVudCwgdGhpcywgc291cmNlKTtcclxuXHRcdFxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRjbG9zZShjYiA9IHRoaXMucHJvcHMuY2xvc2UpIHtcclxuXHRcdFx0dGhpcy5tb2RhbC5jbGFzc05hbWUgPSBgJHt0aGlzLnByb3BzLmNsYXNzfWA7XHJcblx0XHRcdHRoaXMubW9kYWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5cdFx0XHR0aGlzLmJ1dHRvbnMoZmFsc2UpO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5jb250ZW50LmNsYXNzTmFtZSA9IGAke3RoaXMucHJvcHMuY2xhc3N9X19jb250ZW50YDtcclxuXHRcdFx0dGhpcy5jb250ZW50LmlubmVySFRNTCA9ICcnO1xyXG5cdFx0XHR0aGlzLnByb3BzLnByZXNlcnZlICYmIHRoaXMucmVzdG9yZSgpO1xyXG5cclxuXHRcdFx0Ly8g0LLRi9C30L7QsiDRhdGD0LrQsCBjbG9zZSDRgyDQv9C70LDQs9C40L3QvtCyXHJcblx0XHRcdHRoaXMuX2hvb2tzLmNsb3NlLmZvckVhY2goY2xvc2UgPT4gY2xvc2UoKSk7XHJcblx0XHRcdGNiPy5jYWxsKHRoaXMuY29udGVudCwgdGhpcyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmVzdG9yZSgpIHtcclxuXHRcdFx0aWYgKCEgdGhpcy5kZXRhY2hlZCkgcmV0dXJuO1xyXG5cdFx0XHRjb25zdCB7IG5vZGUsIHBhcmVudCwgbmV4dCB9ID0gdGhpcy5kZXRhY2hlZDtcclxuXHJcblx0XHRcdChuZXh0Py5wYXJlbnROb2RlID09PSBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlIDogcGFyZW50LmFwcGVuZENoaWxkKS5jYWxsKHBhcmVudCwgbm9kZSwgbmV4dCk7XHJcblx0XHRcdHRoaXMuZGV0YWNoZWQgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGJ1dHRvbnMoYnVpbGQgPSB0cnVlKSB7XHJcblx0XHRcdGlmIChidWlsZCkge1xyXG5cdFx0XHRcdHRoaXMucHJldiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG5cdFx0XHRcdHRoaXMubmV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG5cclxuXHRcdFx0XHR0aGlzLnByZXYuY2xhc3NOYW1lID0gYCR7dGhpcy5wcm9wcy5jbGFzc31fX2J1dHRvbiAke3RoaXMucHJvcHMuY2xhc3N9X19idXR0b25fcHJldmA7XHJcblx0XHRcdFx0dGhpcy5uZXh0LmNsYXNzTmFtZSA9IGAke3RoaXMucHJvcHMuY2xhc3N9X19idXR0b24gJHt0aGlzLnByb3BzLmNsYXNzfV9fYnV0dG9uX25leHRgO1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvZHkuYXBwZW5kKHRoaXMucHJldik7XHJcblx0XHRcdFx0dGhpcy5ib2R5LmFwcGVuZCh0aGlzLm5leHQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMucHJldj8ucmVtb3ZlKCk7XHJcblx0XHRcdFx0dGhpcy5uZXh0Py5yZW1vdmUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdCN1bmRlcmxheSgpIHtcclxuXHRcdFx0aWYgKCEgdGhpcy5tb2RhbCkge1xyXG5cdFx0XHRcdGNvbnN0IHVuZGVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRcdFx0Y29uc3QgYm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0XHRcdGNvbnN0IGNsb3NlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHVuZGVybGF5LmNsYXNzTmFtZSA9IGAke3RoaXMucHJvcHMuY2xhc3N9YDtcclxuXHRcdFx0XHR1bmRlcmxheS5pZCA9IGAke3RoaXMucHJvcHMuY2xhc3N9X191bmRlcmxheWA7XHJcblx0XHJcblx0XHRcdFx0Ym9keS5jbGFzc05hbWUgPSBgJHt0aGlzLnByb3BzLmNsYXNzfV9fYm9keWA7XHJcblx0XHRcdFx0Y2xvc2UuY2xhc3NOYW1lID0gYCR7dGhpcy5wcm9wcy5jbGFzc31fX2Nsb3NlYDtcclxuXHRcdFx0XHRjb250ZW50LmNsYXNzTmFtZSA9IGAke3RoaXMucHJvcHMuY2xhc3N9X19jb250ZW50YDtcclxuXHRcdFxyXG5cdFx0XHRcdGJvZHkuYXBwZW5kKGNsb3NlKTtcclxuXHRcdFx0XHRib2R5LmFwcGVuZChjb250ZW50KTtcclxuXHRcdFx0XHR1bmRlcmxheS5hcHBlbmQoYm9keSk7XHJcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmQodW5kZXJsYXkpO1xyXG5cdFxyXG5cdFx0XHRcdHRoaXMubW9kYWwgPSB1bmRlcmxheTtcclxuXHRcdFx0XHR0aGlzLmJvZHkgPSBib2R5O1xyXG5cdFx0XHRcdHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQjaW5pdCgpIHtcclxuXHRcdFx0dGhpcy4jdW5kZXJsYXkoKTtcclxuXHJcblx0XHRcdC8vINC40L3QuNGG0LjQsNC70LjQt9Cw0YbQuNGPINC/0LvQsNCz0LjQvdC+0LIg0Lgg0LjRhSDRhdGD0LrQvtCyXHJcblx0XHRcdHRoaXMucHJvcHMubW9kdWxlcy5mb3JFYWNoKHBsdWdpbiA9PiB7XHJcblx0XHRcdFx0aWYgKHBsdWdpbiAmJiB0eXBlb2YgcGx1Z2luID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdFx0cGx1Z2luLmluaXQ/Lih0aGlzLCB0aGlzLnByb3BzW3BsdWdpbi5uYW1lXSk7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKHRoaXMuX2hvb2tzKS5mb3JFYWNoKGhvb2sgPT4ge1xyXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHBsdWdpbltob29rXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2hvb2tzW2hvb2tdLnB1c2gocGx1Z2luW2hvb2tdLmJpbmQocGx1Z2luLCB0aGlzKSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcblx0XHRcdFx0bGV0IGVsID0gZS50YXJnZXQuY2xvc2VzdCh0aGlzLnNlbGVjdCk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKGVsICYmIGVsLmhhc0F0dHJpYnV0ZShgZGF0YS0ke3RoaXMucHJvcHMuY2xhc3N9YCkpIHtcclxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdHRoaXMub3BlbihlbCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZS50YXJnZXQgPT0gdGhpcy5tb2RhbCB8fCBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoYCR7dGhpcy5wcm9wcy5jbGFzc31fX2Nsb3NlYCkpIHtcclxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdHRoaXMuY2xvc2UoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRcclxuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XHJcblx0XHRcdFx0aWYgKHRoaXMubW9kYWwuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJyAmJiAoZS5rZXkgPT09IFwiRXNjYXBlXCIgfHwgZS5rZXkgPT09IFwiRXNjXCIpKVxyXG5cdFx0XHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMucHJvcHMuaW5pdD8uY2FsbCh0aGlzLCB0aGlzLm1vZGFsKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgTW9kYWwocHJvcHMpO1xyXG59O1xyXG5cclxuLy8g0L/Qu9Cw0LPQuNC9INCz0LDQu9C70LXRgNC10LhcclxuZXhwb3J0IGNvbnN0IHNsaWRlc2hvdyA9IHtcclxuXHRuYW1lOiAnc2xpZGVzaG93JyxcclxuXHJcblx0aW5pdChtb2RhbCwgcHJvcHMgPSB7fSkge1xyXG5cdFx0dGhpcy5wcm9wcyA9IHtcclxuXHRcdFx0bmF2aWdhdGlvbjogdHJ1ZSxcclxuXHRcdFx0Y2xhc3NNb2Q6ICdnYWxsZXJ5JyxcclxuXHRcdFx0Li4ucHJvcHNcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5zZXR1cFNsaWRlc2hvdyA9IGZ1bmN0aW9uKG1vZGFsLCBlbCkge1xyXG5cdFx0XHRjb25zdCByZWwgPSBlbC5hdHRyaWJ1dGVzLnJlbD8udmFsdWU7XHJcblx0XHRcdGlmICghcmVsKSByZXR1cm47XHJcblxyXG5cdFx0XHRjb25zdCBjdXJyZW50ID0gbW9kYWwuY29udGVudC5xdWVyeVNlbGVjdG9yKCdpbWcsIHZpZGVvJyk7XHJcblx0XHRcdGxldCBhcHBlbmQgPSBmYWxzZTtcclxuXHRcdFx0bGV0IGNvdW50ZXIgPSAwO1xyXG5cclxuXHRcdFx0Wy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtyZWw9XCIke3JlbH1cIl1gKV0uZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHNvdXJjZSA9IGl0ZW0ucXVlcnlTZWxlY3RvcignaW1nLCB2aWRlbycpO1xyXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBpdGVtLmRhdGFzZXRbbW9kYWwucHJvcHMuY2xhc3NdO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gZGF0YSBcclxuXHRcdFx0XHRcdD8gT2JqZWN0LmFzc2lnbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKSwgeyBzcmM6IGRhdGEgfSlcclxuXHRcdFx0XHRcdDogc291cmNlLmNsb25lTm9kZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoY2hpbGQuc3JjID09PSBjdXJyZW50LnNyYykge1xyXG5cdFx0XHRcdFx0T2JqZWN0LmFzc2lnbihjdXJyZW50LmRhdGFzZXQsIHNvdXJjZS5kYXRhc2V0KTtcclxuXHRcdFx0XHRcdGFwcGVuZCA9IHRydWU7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtb2RhbC5jb250ZW50W2FwcGVuZCA/ICdhcHBlbmRDaGlsZCcgOiAnaW5zZXJ0QmVmb3JlJ10oY2hpbGQsIGFwcGVuZCA/IG51bGwgOiBjdXJyZW50KTtcdFx0XHJcblx0XHRcdFx0T2JqZWN0LmFzc2lnbihjaGlsZC5kYXRhc2V0LCBzb3VyY2UuZGF0YXNldCk7XHJcblx0XHRcdFx0Y291bnRlcisrO1x0XHRcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRtb2RhbC5jb250ZW50LmNsYXNzTGlzdC5hZGQoYCR7bW9kYWwucHJvcHMuY2xhc3N9X19jb250ZW50XyR7dGhpcy5wcm9wcy5jbGFzc01vZH1gKTtcclxuXHRcdFx0Y3VycmVudC5jbGFzc0xpc3QuYWRkKGAke21vZGFsLnByb3BzLmNsYXNzQWN0aXZlfWApO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGNvdW50ZXIgPiAxKSB7XHJcblx0XHRcdFx0bW9kYWwuc2xpZGVzaG93ID0gbW9kYWwuY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbWcsIHZpZGVvJyk7XHJcblx0XHRcdFx0bW9kYWwuY250ID0gWy4uLm1vZGFsLnNsaWRlc2hvd10uZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5jbGFzc0xpc3QuY29udGFpbnMobW9kYWwucHJvcHMuY2xhc3NBY3RpdmUpKTtcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMucHJvcHMubmF2aWdhdGlvbikge1xyXG5cdFx0XHRcdFx0bW9kYWwuYnV0dG9ucygpO1xyXG5cdFx0XHRcdFx0bW9kYWwucHJldi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuc2xpZGVzaG93TW92ZSgtMSkpO1xyXG5cdFx0XHRcdFx0bW9kYWwubmV4dC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuc2xpZGVzaG93TW92ZSgpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5zbGlkZXNob3dNb3ZlID0gZnVuY3Rpb24odmFsdWUgPSAxLCBpc0luZGV4ID0gZmFsc2UpIHtcclxuXHRcdFx0Y29uc3Qgc2xpZGVzID0gbW9kYWwuc2xpZGVzaG93O1xyXG5cdFx0XHJcblx0XHRcdHNsaWRlc1ttb2RhbC5jbnRdLmNsYXNzTGlzdC5yZW1vdmUobW9kYWwucHJvcHMuY2xhc3NBY3RpdmUpO1xyXG5cdFx0XHRtb2RhbC5jbnQgPSBpc0luZGV4XHJcblx0XHRcdFx0PyAodmFsdWUgKyBzbGlkZXMubGVuZ3RoKSAlIHNsaWRlcy5sZW5ndGhcclxuXHRcdFx0XHQ6IChtb2RhbC5jbnQgKyB2YWx1ZSArIHNsaWRlcy5sZW5ndGgpICUgc2xpZGVzLmxlbmd0aDtcclxuXHRcdFx0c2xpZGVzW21vZGFsLmNudF0uY2xhc3NMaXN0LmFkZChtb2RhbC5wcm9wcy5jbGFzc0FjdGl2ZSk7XHJcblx0XHRcclxuXHRcdFx0bW9kYWwuX2hvb2tzLm1vdmUuZm9yRWFjaChtb3ZlID0+IG1vdmUoKSk7XHJcblx0XHRcdG1vZGFsLnByb3BzLm1vdmU/LmNhbGwobW9kYWwuY29udGVudCwgbW9kYWwpO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyDQlNC+0LHQsNCy0LjRgtGMINC90L7QstGL0Lkg0YXRg9C6INCyINCx0LDQt9C+0LLRi9C5INC60LvQsNGB0YFcclxuXHRcdG1vZGFsLl9ob29rcy5tb3ZlIHx8PSBbXTtcclxuXHRcdFxyXG5cdFx0Ly8g0JTQvtCx0LDQstC40YLRjCDQvdC+0LLRi9C5INC80LXRgtC+0LQg0LIg0LHQsNC30L7QstGL0Lkg0LrQu9Cw0YHRgVxyXG5cdFx0bW9kYWwubW92ZSA9IHRoaXMuc2xpZGVzaG93TW92ZS5iaW5kKHRoaXMpO1xyXG5cdH0sXHJcblx0XHJcblx0b3Blbihtb2RhbCwgZWwpIHtcclxuXHRcdGNvbnN0IGRhdGEgPSBlbC5kYXRhc2V0W2Ake21vZGFsLnByb3BzLmNsYXNzfWBdO1xyXG5cdFx0KCEhZGF0YSAmJiBkYXRhLnN0YXJ0c1dpdGgoJyMnKSkgfHwgdGhpcy5zZXR1cFNsaWRlc2hvdyhtb2RhbCwgZWwpO1xyXG5cdH0sXHJcblx0XHJcblx0Y2xvc2UobW9kYWwpIHtcclxuXHRcdGRlbGV0ZSBtb2RhbC5jbnQ7XHJcblx0XHRkZWxldGUgbW9kYWwuc2xpZGVzaG93O1xyXG5cdFx0ZGVsZXRlIG1vZGFsLnNsaWRlc2hvdztcclxuXHR9XHJcbn07XHJcblxyXG4vLyDQv9C70LDQs9C40L0g0LrQvdC+0L/QutC4INC00LvRjyDQstC+0YHQv9GA0L7QuNC30LLQtdC00LXQvdC40Y8g0LLQuNC00LXQvlxyXG5leHBvcnQgY29uc3QgcGxheWJ1dHRvbiA9IHtcclxuXHRuYW1lOiAncGxheWJ1dHRvbicsXHJcblxyXG5cdGluaXQobW9kYWwpIHtcclxuXHRcdHRoaXMuc2V0UGxheUJ1dHRvbiA9IChjb250ZW50LCB2aWRlbykgPT4ge1xyXG5cdFx0XHRsZXQgcGxheSA9IGNvbnRlbnQucXVlcnlTZWxlY3RvcignLm1vZGFsX19wbGF5Jyk7XHJcblx0XHJcblx0XHRcdGlmICghISB2aWRlbz8uY2FuUGxheVR5cGUpIHtcclxuXHRcdFx0XHR2aWRlby5jb250cm9scyA9IHRydWU7XHJcblx0XHRcdFx0cGxheSB8fD0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcblx0XHRcdFx0cGxheS5jbGFzc05hbWUgPSAnbW9kYWxfX3BsYXknO1xyXG5cdFx0XHRcdHBsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4gdmlkZW8ucGxheSgpKTtcclxuXHRcdFx0XHRjb250ZW50LmFwcGVuZChwbGF5KTtcclxuXHRcclxuXHRcdFx0XHRbJ3BhdXNlJywgJ2VuZGVkJywgJ3BsYXlpbmcnXS5mb3JFYWNoKChldmVudCkgPT4ge1xyXG5cdFx0XHRcdFx0dmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgKGUpID0+IHtcclxuXHRcdFx0XHRcdFx0cGxheS5jbGFzc0xpc3QudG9nZ2xlKCdwbGF5aW5nJywgISh2aWRlby5wYXVzZWQgfHwgdmlkZW8uZW5kZWQpKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgndmlkZW8nKS5mb3JFYWNoKCh2aWRlbykgPT4gdmlkZW8ucGF1c2UoKSk7XHJcblx0XHRcdFx0cGxheT8ucmVtb3ZlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cdFxyXG5cdG9wZW4obW9kYWwsIGVsKSB7XHJcblx0XHRjb25zdCB7IGNvbnRlbnQsIHNsaWRlc2hvdywgcHJvcHMgfSA9IG1vZGFsO1xyXG5cdFx0Y29uc3QgYWN0aXZlID0gc2xpZGVzaG93ID8gYC4ke3Byb3BzLmNsYXNzQWN0aXZlfWAgOiAnJztcclxuXHRcdFxyXG5cdFx0dGhpcy5zZXRQbGF5QnV0dG9uKGNvbnRlbnQsIGNvbnRlbnQucXVlcnlTZWxlY3RvcihgdmlkZW8ke2FjdGl2ZX1gKSk7XHJcblx0fSxcclxuXHRcclxuXHRtb3ZlKG1vZGFsKSB7XHJcblx0XHRjb25zdCB7IGNvbnRlbnQsIHByb3BzIH0gPSBtb2RhbDtcclxuXHRcdGNvbnN0IGFjdGl2ZSA9IGAuJHtwcm9wcy5jbGFzc0FjdGl2ZX1gO1xyXG5cdFx0XHJcblx0XHR0aGlzLnNldFBsYXlCdXR0b24oY29udGVudCwgY29udGVudC5xdWVyeVNlbGVjdG9yKGB2aWRlbyR7YWN0aXZlfWApKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyDQv9C70LDQs9C40L0g0LzQuNC90LjQsNGC0Y7RgCDQtNC70Y8g0L3QsNCy0LjQs9Cw0YbQuNC4INCyINCz0LDQu9C10YDQtdC1XHJcbmV4cG9ydCBjb25zdCB0aHVtYm5haWxzID0ge1xyXG5cdG5hbWU6ICd0aHVtYm5haWxzJyxcclxuXHJcblx0aW5pdChtb2RhbCwgcHJvcHMgPSB7fSkge1xyXG5cdFx0dGhpcy5wcm9wcyA9IHtcclxuXHRcdFx0Y291bnQ6IDQsIC8vINGB0LrQvtC70YzQutC+INC80LjQvdC40LDRgtGO0YAg0LLQuNC00L3QviDQvtC00L3QvtCy0YDQtdC80LXQvdC90L5cclxuXHRcdFx0bWF4U2tpcDogMyxcclxuXHRcdFx0ZHVyYXRpb246IDAuMyxcclxuXHRcdFx0ZHJhZ1RocmVzaG9sZDogNSxcclxuXHRcdFx0Li4ucHJvcHNcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLm1vZGFsID0gbW9kYWw7XHJcblx0XHR0aGlzLmluZGV4ID0gMDtcclxuXHJcblx0XHR0aGlzLl9ib3VuZE9uTW92ZSA9IHRoaXMub25EcmFnLmJpbmQodGhpcyk7XHJcblx0XHR0aGlzLl9ib3VuZE9uVXAgPSB0aGlzLm9uVXAuYmluZCh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRnZXQgc2xpZGVTaXplKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2xpZGVXaWR0aCArIHRoaXMuZ2FwO1xyXG5cdH0sXHJcblxyXG5cdGdldCBvZmZzZXQoKSB7XHJcblx0XHQvLyDQvdCwINGB0LrQvtC70YzQutC+INC90YPQttC90L4g0YHQtNCy0LjQvdGD0YLRjCB3cmFwcGVyLCDRh9GC0L7QsdGLINC+0YLQvtCx0YDQsNC20LDQu9C+0YHRjCBjb3VudCDRgdC70LDQudC00L7Qsiwg0L3QsNGH0LjQvdCw0Y8g0YEg0L3Rg9C20L3QvtCz0L4g0LjQvdC00LXQutGB0LBcclxuXHRcdHJldHVybiB0aGlzLmluZGV4ICogdGhpcy5zbGlkZVNpemU7XHJcblx0fSxcclxuXHJcblx0Z2V0IG1heEluZGV4KCkge1xyXG5cdFx0Ly8g0LzQsNC60YHQuNC80LDQu9GM0L3QviDQstC+0LfQvNC+0LbQvdGL0Lkg0LjQvdC00LXQutGBINC00L4g0LrQvtGC0L7RgNC+0LPQviDQvNC+0LbQvdC+INC/0YDQvtC60YDRg9GC0LjRgtGMLCDRh9GC0L7QsdGLINCy0L4g0LrQvtC90YLQtdC50L3QtdGA0LUg0LHRi9C70L4g0YDQvtCy0L3QviBjb3VudCDRgdC70LDQudC00L7QslxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KDAsIHRoaXMuc2xpZGVzLmxlbmd0aCAtIHRoaXMucHJvcHMuY291bnQpO1xyXG5cdH0sXHJcblxyXG5cdG9wZW4obW9kYWwpIHtcclxuXHRcdGlmICghbW9kYWwuc2xpZGVzaG93KSByZXR1cm47XHJcblxyXG5cdFx0Ly8g0KHQvtC30LTQsNC10Lwg0L7QsdC10YDRgtC60YMg0LTQu9GPINC80LjQvdC40LDRgtGO0YBcclxuXHRcdHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHR0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBgJHttb2RhbC5wcm9wcy5jbGFzc31fX3RodW1ic2A7XHJcblxyXG5cdFx0dGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHR0aGlzLndyYXBwZXIuY2xhc3NOYW1lID0gYCR7bW9kYWwucHJvcHMuY2xhc3N9X190aHVtYnMtd3JhcHBlcmA7XHJcblxyXG5cdFx0Ly8g0JTQvtCx0LDQstC70Y/QtdC8INC80LjQvdC40LDRgtGO0YDRi1xyXG5cdFx0dGhpcy5zbGlkZXMgPSBBcnJheS5mcm9tKG1vZGFsLnNsaWRlc2hvdywgKGl0ZW0sIGkpID0+IHtcclxuXHRcdFx0Y29uc3Qgc2xpZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblxyXG5cdFx0XHRzbGlkZS5jbGFzc05hbWUgPSBgJHttb2RhbC5wcm9wcy5jbGFzc31fX3RodW1icy1zbGlkZWA7XHJcblx0XHRcdHNsaWRlLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJyR7aXRlbS5wb3N0ZXIgfHwgaXRlbS5zcmN9JylgO1xyXG5cdFx0XHRzbGlkZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuaXNEcmFnZ2luZyB8fCB0aGlzLm1vZGFsLm1vdmUoaSwgdHJ1ZSkpO1xyXG5cdFx0XHR0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoc2xpZGUpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHNsaWRlO1xyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdC8vINCh0YLRgNC+0LjQvCDRgdGC0YDRg9C60YLRg9GA0YNcclxuXHRcdHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik7XHJcblx0XHRtb2RhbC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcclxuXHJcblx0XHR0aGlzLnNldHVwVGh1bWJTaXplcygpO1xyXG5cdFx0dGhpcy5iaW5kRXZlbnRzKCk7XHJcblx0XHR0aGlzLnVwZGF0ZUFjdGl2ZVRodW1iKCk7XHJcblxyXG5cdFx0Ly8g0J/QvtC00L/QuNGB0LrQsCDQvdCwINC/0LXRgNC10LrQu9GO0YfQtdC90LjQtSDRgdC70LDQudC00L7QslxyXG5cdFx0bW9kYWwuX2hvb2tzLm1vdmUucHVzaCh0aGlzLnVwZGF0ZUFjdGl2ZVRodW1iLmJpbmQodGhpcykpO1xyXG5cdH0sXHJcblxyXG5cdHNldHVwVGh1bWJTaXplcygpIHtcclxuXHRcdGNvbnN0IHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUodGhpcy53cmFwcGVyKTtcclxuXHJcblx0XHR0aGlzLmdhcCA9IHBhcnNlRmxvYXQoc3R5bGVzLmdhcCkgfHwgMDtcclxuXHRcdHRoaXMuc2xpZGVXaWR0aCA9ICh0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCAtIHRoaXMuZ2FwICogKHRoaXMucHJvcHMuY291bnQgLSAxKSkgLyB0aGlzLnByb3BzLmNvdW50O1xyXG5cclxuXHRcdHRoaXMuc2xpZGVzLmZvckVhY2goc2xpZGUgPT4gc2xpZGUuc3R5bGUuZmxleCA9IGAwIDAgJHt0aGlzLnNsaWRlV2lkdGh9cHhgKTtcclxuXHRcdHRoaXMubW92aW5nVGh1bWJzKHRoaXMuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdG9uRHJhZyhlKSB7XHJcblx0XHRjb25zdCBkeCA9IGUuY2xpZW50WCAtIHRoaXMuc3RhcnRYO1xyXG5cdFx0Y29uc3QgdG90YWwgPSB0aGlzLnNsaWRlU2l6ZSAqIHRoaXMuc2xpZGVzLmxlbmd0aCAtIHRoaXMuZ2FwO1xyXG5cdFx0Y29uc3QgbGltaXQgPSB0b3RhbCAtIHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoICsgdGhpcy5zbGlkZVNpemU7XHJcblx0XHJcblx0XHRjb25zdCBvZmZzZXQgPSBNYXRoLm1heCgtbGltaXQsIE1hdGgubWluKHRoaXMuc3RhcnRPZmZzZXQgKyBkeCwgdGhpcy5zbGlkZVNpemUpKTtcclxuXHRcclxuXHRcdHRoaXMud3JhcHBlci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke29mZnNldH1weClgO1xyXG5cdFx0dGhpcy5pc0RyYWdnaW5nIHx8PSBNYXRoLmFicyhkeCkgPiB0aGlzLnByb3BzLmRyYWdUaHJlc2hvbGQ7XHJcblx0fSxcclxuXHJcblx0b25VcChlKSB7XHJcblx0XHQvLyDQtNC70LjQvdCwINGB0LLQsNC50L/QsFxyXG5cdFx0Y29uc3QgZHggPSBlLmNsaWVudFggLSB0aGlzLnN0YXJ0WDtcclxuXHJcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5fYm91bmRPblVwKTtcclxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMuX2JvdW5kT25Nb3ZlKTtcclxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5fYm91bmRPblVwKTtcclxuXHJcblx0XHQvLyDRgdC60L7Qu9GM0LrQviDRgdC70LDQudC00L7QsiDRgdC00LLQuNC90YPRgtGMINC90LAg0L7RgdC90L7QstC1INC00LvQuNC90Ysg0YHQstCw0LnQv9CwLCDQvdC+INC90LUg0LHQvtC70YzRiNC1LCDRh9C10Lwg0YDQsNC30YDQtdGI0LXQvdC+IChtYXhTa2lwKVxyXG5cdFx0Y29uc3QgbW92ZWRTbGlkZXMgPSBNYXRoLm1pbih0aGlzLnByb3BzLm1heFNraXAsIE1hdGgucm91bmQoTWF0aC5hYnMoZHgpIC8gdGhpcy5zbGlkZVNpemUpKTtcclxuXHJcblx0XHQvLyDRgdC80LXRidC10L3QuNC1INC6INCw0LrRgtGD0LDQu9GM0L3QvtC80YMg0LjQvdC00LXQutGB0YNcclxuXHRcdG1vdmVkU2xpZGVzID4gMFxyXG5cdFx0XHQ/IHRoaXMubW92aW5nVGh1bWJzKHRoaXMuaW5kZXggLSBNYXRoLnNpZ24oZHgpICogbW92ZWRTbGlkZXMpXHJcblx0XHRcdDogdGhpcy5tb3ZpbmdUaHVtYnModGhpcy5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0YmluZEV2ZW50cygpIHtcclxuXHRcdHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIChlKSA9PiB7XHJcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcclxuXHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XHJcblx0XHRcdHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0dGhpcy5zdGFydFggPSBlLmNsaWVudFg7XHJcblx0XHRcdHRoaXMuc3RhcnRPZmZzZXQgPSAtdGhpcy5pbmRleCAqICh0aGlzLnNsaWRlV2lkdGggKyB0aGlzLmdhcCk7XHJcblxyXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5fYm91bmRPblVwKTtcclxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdGhpcy5fYm91bmRPbk1vdmUpO1xyXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMuX2JvdW5kT25VcCk7XHJcblx0XHR9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG5cdFxyXG5cdFx0dGhpcy53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKS5mb3JFYWNoKGVsID0+IHtcclxuXHRcdFx0ZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4gdGhpcy5pc0RyYWdnaW5nICYmIGUucHJldmVudERlZmF1bHQoKSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4gdGhpcy5zZXR1cFRodW1iU2l6ZXMoKSk7XHJcblx0fSxcclxuXHJcblx0bW92aW5nVGh1bWJzKGkpIHtcclxuXHRcdHRoaXMuaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpLCB0aGlzLm1heEluZGV4KSk7XHJcblx0ICBcclxuXHRcdHRoaXMud3JhcHBlci5zdHlsZS50cmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke3RoaXMucHJvcHMuZHVyYXRpb259c2A7XHJcblx0XHR0aGlzLndyYXBwZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoLSR7dGhpcy5vZmZzZXR9cHgpYDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBY3RpdmVUaHVtYigpIHtcclxuXHRcdGlmICghdGhpcy5zbGlkZXM/Lmxlbmd0aCkgcmV0dXJuO1xyXG5cdFx0dGhpcy5zbGlkZXMuZm9yRWFjaChzbGlkZSA9PiBzbGlkZS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKSk7XHJcblx0XHR0aGlzLnNsaWRlc1t0aGlzLm1vZGFsLmNudF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5zY3JvbGxUb0FjdGl2ZVRodW1iKCk7XHJcblx0fSxcclxuXHJcblx0c2Nyb2xsVG9BY3RpdmVUaHVtYigpIHtcclxuXHRcdC8vINCV0YHQu9C4INCw0LrRgtC40LLQvdGL0Lkg0YHQu9Cw0LnQtCDQstGL0YjQtdC7INC30LAg0L/RgNC10LTQtdC70Ysg0LLQuNC00LjQvNC+0YHRgtC4IOKAlCDQv9C+0LTRgdGC0YDQsNC40LLQsNC10Lwg0LjQvdC00LXQutGBXHJcblx0XHRpZiAodGhpcy5tb2RhbC5jbnQgPCB0aGlzLmluZGV4KSB7XHJcblx0XHRcdHRoaXMubW92aW5nVGh1bWJzKHRoaXMubW9kYWwuY250KTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5tb2RhbC5jbnQgPj0gdGhpcy5pbmRleCArIHRoaXMucHJvcHMuY291bnQpIHtcclxuXHRcdFx0dGhpcy5tb3ZpbmdUaHVtYnModGhpcy5tb2RhbC5jbnQgLSB0aGlzLnByb3BzLmNvdW50ICsgMSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y2xvc2UobW9kYWwpIHtcclxuXHRcdHRoaXMuY29udGFpbmVyPy5yZW1vdmUoKTtcclxuXHR9XHJcbn07Il0sIm5hbWVzIjpbIm1ha2VNb2RhbCIsInByb3BzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiX01vZGFsX2JyYW5kIiwiV2Vha1NldCIsIk1vZGFsIiwiX3RoaXMkcHJvcHMkc2VsZWN0IiwiX2NsYXNzQ2FsbENoZWNrIiwiX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjIiwiX29iamVjdFNwcmVhZCIsIm1vZHVsZXMiLCJwcmVzZXJ2ZSIsImNsYXNzQWN0aXZlIiwic2VsZWN0IiwiY29uY2F0IiwibW9kYWwiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJib2R5IiwiY29udGVudCIsIl9ob29rcyIsIm9wZW4iLCJjbG9zZSIsImRldGFjaGVkIiwiX2Fzc2VydENsYXNzQnJhbmQiLCJfaW5pdCIsImNhbGwiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJ2YWx1ZSIsInNvdXJjZSIsImNiIiwicmVzdG9yZSIsImlzRGF0YSIsImhhc0F0dHJpYnV0ZSIsImRhdGEiLCJkYXRhc2V0IiwibW9kIiwiSFRNTEVsZW1lbnQiLCJub2RlIiwicGFyZW50IiwicGFyZW50Tm9kZSIsIm5leHQiLCJuZXh0U2libGluZyIsImNsb25lTm9kZSIsImlubmVySFRNTCIsInN0YXJ0c1dpdGgiLCJzbGljZSIsImNyZWF0ZUVsZW1lbnQiLCJzcmMiLCJjbGFzc05hbWUiLCJjbGFzc0xpc3QiLCJhZGQiLCJzdHlsZSIsImRpc3BsYXkiLCJmb3JFYWNoIiwiYnV0dG9ucyIsIl90aGlzJGRldGFjaGVkIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJidWlsZCIsInByZXYiLCJhcHBlbmQiLCJfdGhpcyRwcmV2IiwiX3RoaXMkbmV4dCIsInJlbW92ZSIsIl91bmRlcmxheSIsInVuZGVybGF5IiwiaWQiLCJfdGhpcyIsIl90aGlzJHByb3BzJGluaXQiLCJwbHVnaW4iLCJfdHlwZW9mIiwiX3BsdWdpbiRpbml0IiwiaW5pdCIsIm5hbWUiLCJPYmplY3QiLCJrZXlzIiwiaG9vayIsInB1c2giLCJiaW5kIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJlbCIsInRhcmdldCIsImNsb3Nlc3QiLCJwcmV2ZW50RGVmYXVsdCIsImNvbnRhaW5zIiwic2xpZGVzaG93IiwiX21vZGFsJF9ob29rcyIsIm5hdmlnYXRpb24iLCJjbGFzc01vZCIsInNldHVwU2xpZGVzaG93IiwiX2VsJGF0dHJpYnV0ZXMkcmVsIiwiX3RoaXMyIiwicmVsIiwiYXR0cmlidXRlcyIsImN1cnJlbnQiLCJjb3VudGVyIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwicXVlcnlTZWxlY3RvckFsbCIsIml0ZW0iLCJpIiwiY2hpbGQiLCJhc3NpZ24iLCJjbnQiLCJmaW5kSW5kZXgiLCJzbGlkZXNob3dNb3ZlIiwiX21vZGFsJHByb3BzJG1vdmUiLCJpc0luZGV4Iiwic2xpZGVzIiwibW92ZSIsInBsYXlidXR0b24iLCJzZXRQbGF5QnV0dG9uIiwidmlkZW8iLCJwbGF5IiwiY2FuUGxheVR5cGUiLCJjb250cm9scyIsImV2ZW50IiwidG9nZ2xlIiwicGF1c2VkIiwiZW5kZWQiLCJfcGxheSIsInBhdXNlIiwiYWN0aXZlIiwidGh1bWJuYWlscyIsImNvdW50IiwibWF4U2tpcCIsImR1cmF0aW9uIiwiZHJhZ1RocmVzaG9sZCIsImlzRHJhZ2dpbmciLCJpbmRleCIsIl9ib3VuZE9uTW92ZSIsIm9uRHJhZyIsIl9ib3VuZE9uVXAiLCJvblVwIiwic2xpZGVTaXplIiwic2xpZGVXaWR0aCIsImdhcCIsIm9mZnNldCIsIm1heEluZGV4IiwiTWF0aCIsIm1heCIsIl90aGlzMyIsImNvbnRhaW5lciIsIndyYXBwZXIiLCJBcnJheSIsImZyb20iLCJzbGlkZSIsImJhY2tncm91bmRJbWFnZSIsInBvc3RlciIsInNldHVwVGh1bWJTaXplcyIsImJpbmRFdmVudHMiLCJ1cGRhdGVBY3RpdmVUaHVtYiIsIl90aGlzNCIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJwYXJzZUZsb2F0IiwiY2xpZW50V2lkdGgiLCJmbGV4IiwibW92aW5nVGh1bWJzIiwiZHgiLCJjbGllbnRYIiwic3RhcnRYIiwidG90YWwiLCJsaW1pdCIsIm1pbiIsInN0YXJ0T2Zmc2V0IiwidHJhbnNmb3JtIiwiYWJzIiwid2luZG93IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1vdmVkU2xpZGVzIiwicm91bmQiLCJzaWduIiwiX3RoaXM1IiwidHJhbnNpdGlvbiIsInBhc3NpdmUiLCJfdGhpcyRzbGlkZXMiLCJzY3JvbGxUb0FjdGl2ZVRodW1iIiwiX3RoaXMkY29udGFpbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/libs/makeModal.js\n");

/***/ }),

/***/ "./src/js/libs/tweakerRangeDouble.js":
/*!*******************************************!*\
  !*** ./src/js/libs/tweakerRangeDouble.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tweakerRangeDouble: () => (/* binding */ tweakerRangeDouble)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\n/* \r\n* В качестве исходной разметки, используется пара инпутов с типом \"range\",\r\n* в обертке с любым классом или идентификатором. В результате создается \r\n* структура из двух полей с типом \"range\" и двух полей с типом \"number\", \r\n* связанных в соответствии с заданными опциями. А так-же элемента span, \r\n* ширина которого зависит от значений заданных движками или полями ввода.\r\n* Стилизацию структуры, нужно производить самостоятельно.\r\n* \r\n* @исходная разметка:\r\n* \r\n<div class=\"someblock\">\r\n\t<input type=\"range\">\r\n\t<input type=\"range\">\r\n</div>\r\n* \r\n* @результирующая разметка:\r\n* \r\n<div class=\"someblock range\">\r\n\t<div class=\"range__values\">\r\n\t\t<input type=\"number\">\r\n\t\t<input type=\"number\">\r\n\t</div>\r\n\t<div class=\"range__slider\" data-range-start-min=\"0\" data-range-start-max=\"7500\" data-range-max=\"10000\">\r\n\t\t<input type=\"range\" min=\"0\" max=\"10000\" step=\"100\">\r\n\t\t<input type=\"range\" min=\"0\" max=\"10000\" step=\"100\">\r\n\t\t<span style=\"left: 25%; right: 25%;\"></span>\r\n\t</div>\r\n</div>\r\n* \r\n* @вызов:\r\n* \r\nimport { tweakerRangeDouble } from \"../../js/libs/tweakerRangeDouble\";\r\ntweakerRangeDouble(document.querySelector('.someblock'), {\r\n\trangeMax: 10000,\r\n\trangeStartMin: 2500,\r\n\trangeStartMax: 7500,\r\n\trangeStep: 100,\r\n\trangeGap: 1000,\r\n\tinput: false\r\n});\r\n*/\n\nvar tweakerRangeDouble = function tweakerRangeDouble(item) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _Range_brand = /*#__PURE__*/new WeakSet();\n  var Range = /*#__PURE__*/function () {\n    function Range(item, options) {\n      var _item$dataset, _item$dataset2, _item$dataset3, _item$dataset4, _item$dataset5;\n      _classCallCheck(this, Range);\n      _classPrivateMethodInitSpec(this, _Range_brand);\n      if (!(item instanceof Element)) return;\n      this.options = _objectSpread({\n        \"class\": 'range',\n        startMin: +((_item$dataset = item.dataset) === null || _item$dataset === void 0 ? void 0 : _item$dataset.rangeStartMin) || 1000,\n        startMax: +((_item$dataset2 = item.dataset) === null || _item$dataset2 === void 0 ? void 0 : _item$dataset2.rangeStartMax) || 7500,\n        maxPrice: +((_item$dataset3 = item.dataset) === null || _item$dataset3 === void 0 ? void 0 : _item$dataset3.rangeMax) || 10000,\n        step: +((_item$dataset4 = item.dataset) === null || _item$dataset4 === void 0 ? void 0 : _item$dataset4.rangeStep) || 100,\n        gap: +((_item$dataset5 = item.dataset) === null || _item$dataset5 === void 0 ? void 0 : _item$dataset5.rangeGap) || 1000,\n        input: true\n      }, options);\n      this.$wrapper = item;\n      this.$prices = [];\n      this.$controls = _toConsumableArray(item.children).filter(function (child) {\n        return child.type === 'range';\n      });\n      this.$progress = document.createElement('span');\n      this.$slider = document.createElement('div');\n      this.$top = document.createElement('div');\n      this.render();\n      this.init();\n    }\n    return _createClass(Range, [{\n      key: \"render\",\n      value: function render() {\n        var _this = this;\n        if (!this.$controls || this.$controls.length !== 2) return;\n        this.$wrapper.classList.add(this.options[\"class\"]);\n        this.$top.classList.add(\"\".concat(this.options[\"class\"], \"__values\"));\n        this.$slider.classList.add(\"\".concat(this.options[\"class\"], \"__slider\"));\n        this.$controls.forEach(function (control, i) {\n          var value = i ? _this.options.startMax : _this.options.startMin;\n          _this.$prices[i] = document.createElement('input');\n          _this.$prices[i].disabled = !_this.options.input;\n          _this.$prices[i].type = 'number';\n          _this.$prices[i].value = value;\n          control.min = 0;\n          control.max = _this.options.maxPrice;\n          control.step = _this.options.step;\n          control.value = value;\n          _this.$top.append(_this.$prices[i]);\n          _this.$slider.append(control);\n        });\n        this.$slider.append(this.$progress);\n        this.$wrapper.append(this.$top, this.$slider);\n      }\n    }, {\n      key: \"setControls\",\n      value: function setControls(e) {\n        var _assertClassBrand2;\n        var current = (e === null || e === void 0 ? void 0 : e.currentTarget) === this.$controls[0] ? 'min' : 'max';\n        var min = +this.$controls[0].value;\n        var max = +this.$controls[1].value;\n        (_assertClassBrand2 = _assertClassBrand(_Range_brand, this, _updateValues)).call.apply(_assertClassBrand2, [this].concat(_toConsumableArray(_assertClassBrand(_Range_brand, this, _clampPrices).call(this, min, max, current))));\n      }\n    }, {\n      key: \"setPrices\",\n      value: function setPrices(e) {\n        var _assertClassBrand3;\n        var current = (e === null || e === void 0 ? void 0 : e.currentTarget) === this.$prices[0] ? 'min' : 'max';\n        var min = +this.$prices[0].value;\n        var max = +this.$prices[1].value;\n        (_assertClassBrand3 = _assertClassBrand(_Range_brand, this, _updateValues)).call.apply(_assertClassBrand3, [this].concat(_toConsumableArray(_assertClassBrand(_Range_brand, this, _clampPrices).call(this, min, max, current))));\n      }\n    }, {\n      key: \"init\",\n      value: function init() {\n        var _this2 = this;\n        this.$controls.forEach(function (control) {\n          control.addEventListener(\"input\", _this2.setControls.bind(_this2));\n        });\n        this.options.input && this.$prices.forEach(function (price) {\n          price.addEventListener(\"input\", _this2.setPrices.bind(_this2));\n          price.addEventListener(\"change\", _this2.setPrices.bind(_this2));\n        });\n        this.setControls();\n      }\n    }]);\n  }();\n  function _clampPrices(min, max) {\n    var current = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'min';\n    var _this$options = this.options,\n      gap = _this$options.gap,\n      maxPrice = _this$options.maxPrice;\n    min = Math.min(Math.max(0, min), maxPrice);\n    max = Math.min(Math.max(0, max), maxPrice);\n    if (max - min < gap) {\n      if (current === 'min') {\n        max = Math.min(maxPrice, min + gap);\n        min = max - gap;\n      } else {\n        min = Math.max(0, max - gap);\n        max = min + gap;\n      }\n    }\n    return [min, max];\n  }\n  function _updateValues(min, max) {\n    this.$prices[0].value = min;\n    this.$prices[1].value = max;\n    this.$controls[0].value = min;\n    this.$controls[1].value = max;\n    this.$progress.style.left = min / this.options.maxPrice * 100 + \"%\";\n    this.$progress.style.right = 100 - max / this.options.maxPrice * 100 + \"%\";\n  }\n  return new Range(item, options);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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NkIsR0FBRyxHQUFHQyxHQUFHLEdBQUc5QixHQUFHO01BQ2hCLENBQUMsTUFBTTtRQUNONkIsR0FBRyxHQUFHb0IsSUFBSSxDQUFDbkIsR0FBRyxDQUFDLENBQUMsRUFBRUEsR0FBRyxHQUFHOUIsR0FBRyxDQUFDO1FBQzVCOEIsR0FBRyxHQUFHRCxHQUFHLEdBQUc3QixHQUFHO01BQ2hCO0lBQ0Q7SUFFQSxPQUFPLENBQUM2QixHQUFHLEVBQUVDLEdBQUcsQ0FBQztFQUNsQjtFQUFDLFNBQUFRLGNBRWFULEdBQUcsRUFBRUMsR0FBRyxFQUFFO0lBQ3ZCLElBQUksQ0FBQzFCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQ2dCLEtBQUssR0FBR1MsR0FBRztJQUMzQixJQUFJLENBQUN6QixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUNnQixLQUFLLEdBQUdVLEdBQUc7SUFDM0IsSUFBSSxDQUFDekIsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDZSxLQUFLLEdBQUdTLEdBQUc7SUFDN0IsSUFBSSxDQUFDeEIsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDZSxLQUFLLEdBQUdVLEdBQUc7SUFFN0IsSUFBSSxDQUFDbkIsU0FBUyxDQUFDdUMsS0FBSyxDQUFDQyxJQUFJLEdBQUl0QixHQUFHLEdBQUcsSUFBSSxDQUFDdEQsT0FBTyxDQUFDcUIsUUFBUSxHQUFHLEdBQUcsR0FBSSxHQUFHO0lBQ3JFLElBQUksQ0FBQ2UsU0FBUyxDQUFDdUMsS0FBSyxDQUFDRSxLQUFLLEdBQUksR0FBRyxHQUFHdEIsR0FBRyxHQUFHLElBQUksQ0FBQ3ZELE9BQU8sQ0FBQ3FCLFFBQVEsR0FBRyxHQUFHLEdBQUksR0FBRztFQUM3RTtFQStCRCxPQUFPLElBQUlmLEtBQUssQ0FBQ1AsSUFBSSxFQUFFQyxPQUFPLENBQUM7QUFDaEMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2d1bHAtc2Nzcy1zdGFydGVyLy4vc3JjL2pzL2xpYnMvdHdlYWtlclJhbmdlRG91YmxlLmpzP2VjZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogXHJcbiog0JIg0LrQsNGH0LXRgdGC0LLQtSDQuNGB0YXQvtC00L3QvtC5INGA0LDQt9C80LXRgtC60LgsINC40YHQv9C+0LvRjNC30YPQtdGC0YHRjyDQv9Cw0YDQsCDQuNC90L/Rg9GC0L7QsiDRgSDRgtC40L/QvtC8IFwicmFuZ2VcIixcclxuKiDQsiDQvtCx0LXRgNGC0LrQtSDRgSDQu9GO0LHRi9C8INC60LvQsNGB0YHQvtC8INC40LvQuCDQuNC00LXQvdGC0LjRhNC40LrQsNGC0L7RgNC+0LwuINCSINGA0LXQt9GD0LvRjNGC0LDRgtC1INGB0L7Qt9C00LDQtdGC0YHRjyBcclxuKiDRgdGC0YDRg9C60YLRg9GA0LAg0LjQtyDQtNCy0YPRhSDQv9C+0LvQtdC5INGBINGC0LjQv9C+0LwgXCJyYW5nZVwiINC4INC00LLRg9GFINC/0L7Qu9C10Lkg0YEg0YLQuNC/0L7QvCBcIm51bWJlclwiLCBcclxuKiDRgdCy0Y/Qt9Cw0L3QvdGL0YUg0LIg0YHQvtC+0YLQstC10YLRgdGC0LLQuNC4INGBINC30LDQtNCw0L3QvdGL0LzQuCDQvtC/0YbQuNGP0LzQuC4g0JAg0YLQsNC6LdC20LUg0Y3Qu9C10LzQtdC90YLQsCBzcGFuLCBcclxuKiDRiNC40YDQuNC90LAg0LrQvtGC0L7RgNC+0LPQviDQt9Cw0LLQuNGB0LjRgiDQvtGCINC30L3QsNGH0LXQvdC40Lkg0LfQsNC00LDQvdC90YvRhSDQtNCy0LjQttC60LDQvNC4INC40LvQuCDQv9C+0LvRj9C80Lgg0LLQstC+0LTQsC5cclxuKiDQodGC0LjQu9C40LfQsNGG0LjRjiDRgdGC0YDRg9C60YLRg9GA0YssINC90YPQttC90L4g0L/RgNC+0LjQt9Cy0L7QtNC40YLRjCDRgdCw0LzQvtGB0YLQvtGP0YLQtdC70YzQvdC+LlxyXG4qIFxyXG4qIEDQuNGB0YXQvtC00L3QsNGPINGA0LDQt9C80LXRgtC60LA6XHJcbiogXHJcbjxkaXYgY2xhc3M9XCJzb21lYmxvY2tcIj5cclxuXHQ8aW5wdXQgdHlwZT1cInJhbmdlXCI+XHJcblx0PGlucHV0IHR5cGU9XCJyYW5nZVwiPlxyXG48L2Rpdj5cclxuKiBcclxuKiBA0YDQtdC30YPQu9GM0YLQuNGA0YPRjtGJ0LDRjyDRgNCw0LfQvNC10YLQutCwOlxyXG4qIFxyXG48ZGl2IGNsYXNzPVwic29tZWJsb2NrIHJhbmdlXCI+XHJcblx0PGRpdiBjbGFzcz1cInJhbmdlX192YWx1ZXNcIj5cclxuXHRcdDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+XHJcblx0XHQ8aW5wdXQgdHlwZT1cIm51bWJlclwiPlxyXG5cdDwvZGl2PlxyXG5cdDxkaXYgY2xhc3M9XCJyYW5nZV9fc2xpZGVyXCIgZGF0YS1yYW5nZS1zdGFydC1taW49XCIwXCIgZGF0YS1yYW5nZS1zdGFydC1tYXg9XCI3NTAwXCIgZGF0YS1yYW5nZS1tYXg9XCIxMDAwMFwiPlxyXG5cdFx0PGlucHV0IHR5cGU9XCJyYW5nZVwiIG1pbj1cIjBcIiBtYXg9XCIxMDAwMFwiIHN0ZXA9XCIxMDBcIj5cclxuXHRcdDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBtaW49XCIwXCIgbWF4PVwiMTAwMDBcIiBzdGVwPVwiMTAwXCI+XHJcblx0XHQ8c3BhbiBzdHlsZT1cImxlZnQ6IDI1JTsgcmlnaHQ6IDI1JTtcIj48L3NwYW4+XHJcblx0PC9kaXY+XHJcbjwvZGl2PlxyXG4qIFxyXG4qIEDQstGL0LfQvtCyOlxyXG4qIFxyXG5pbXBvcnQgeyB0d2Vha2VyUmFuZ2VEb3VibGUgfSBmcm9tIFwiLi4vLi4vanMvbGlicy90d2Vha2VyUmFuZ2VEb3VibGVcIjtcclxudHdlYWtlclJhbmdlRG91YmxlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zb21lYmxvY2snKSwge1xyXG5cdHJhbmdlTWF4OiAxMDAwMCxcclxuXHRyYW5nZVN0YXJ0TWluOiAyNTAwLFxyXG5cdHJhbmdlU3RhcnRNYXg6IDc1MDAsXHJcblx0cmFuZ2VTdGVwOiAxMDAsXHJcblx0cmFuZ2VHYXA6IDEwMDAsXHJcblx0aW5wdXQ6IGZhbHNlXHJcbn0pO1xyXG4qL1xyXG5cclxuZXhwb3J0IGNvbnN0IHR3ZWFrZXJSYW5nZURvdWJsZSA9IChpdGVtLCBvcHRpb25zID0ge30pID0+IHtcclxuXHRcdFxyXG5cdGNsYXNzIFJhbmdlIHtcclxuXHRcdGNvbnN0cnVjdG9yKGl0ZW0sIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYoISAoaXRlbSBpbnN0YW5jZW9mIEVsZW1lbnQpKSByZXR1cm47XHJcblxyXG5cdFx0XHR0aGlzLm9wdGlvbnMgPSB7XHJcblx0XHRcdFx0Y2xhc3M6ICdyYW5nZScsXHJcblx0XHRcdFx0c3RhcnRNaW46ICtpdGVtLmRhdGFzZXQ/LnJhbmdlU3RhcnRNaW4gfHwgMTAwMCxcclxuXHRcdFx0XHRzdGFydE1heDogK2l0ZW0uZGF0YXNldD8ucmFuZ2VTdGFydE1heCB8fCA3NTAwLFxyXG5cdFx0XHRcdG1heFByaWNlOiAraXRlbS5kYXRhc2V0Py5yYW5nZU1heCB8fCAxMDAwMCxcclxuXHRcdFx0XHRzdGVwOiAraXRlbS5kYXRhc2V0Py5yYW5nZVN0ZXAgfHwgMTAwLFxyXG5cdFx0XHRcdGdhcDogK2l0ZW0uZGF0YXNldD8ucmFuZ2VHYXAgfHwgMTAwMCxcclxuXHRcdFx0XHRpbnB1dDogdHJ1ZSxcclxuXHRcdFx0XHQuLi5vcHRpb25zXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR0aGlzLiR3cmFwcGVyID0gaXRlbTtcclxuXHRcdFx0dGhpcy4kcHJpY2VzID0gW107XHJcblx0XHRcdHRoaXMuJGNvbnRyb2xzID0gWy4uLml0ZW0uY2hpbGRyZW5dLmZpbHRlcihjaGlsZCA9PiBjaGlsZC50eXBlID09PSAncmFuZ2UnKTtcclxuXHRcdFx0dGhpcy4kcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRcdHRoaXMuJHNsaWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0XHR0aGlzLiR0b3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdFx0dGhpcy5yZW5kZXIoKTtcclxuXHRcdFx0dGhpcy5pbml0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmVuZGVyKCkge1xyXG5cdFx0XHRpZiAoISB0aGlzLiRjb250cm9scyB8fCB0aGlzLiRjb250cm9scy5sZW5ndGggIT09IDIpIHJldHVybjtcclxuXHJcblx0XHRcdHRoaXMuJHdyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY2xhc3MpO1xyXG5cdFx0XHR0aGlzLiR0b3AuY2xhc3NMaXN0LmFkZChgJHt0aGlzLm9wdGlvbnMuY2xhc3N9X192YWx1ZXNgKTtcclxuXHRcdFx0dGhpcy4kc2xpZGVyLmNsYXNzTGlzdC5hZGQoYCR7dGhpcy5vcHRpb25zLmNsYXNzfV9fc2xpZGVyYCk7XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLiRjb250cm9scy5mb3JFYWNoKChjb250cm9sLCBpKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBpID8gdGhpcy5vcHRpb25zLnN0YXJ0TWF4IDogdGhpcy5vcHRpb25zLnN0YXJ0TWluO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHRoaXMuJHByaWNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdFx0dGhpcy4kcHJpY2VzW2ldLmRpc2FibGVkID0gIXRoaXMub3B0aW9ucy5pbnB1dDtcclxuXHRcdFx0XHR0aGlzLiRwcmljZXNbaV0udHlwZSA9ICdudW1iZXInO1xyXG5cdFx0XHRcdHRoaXMuJHByaWNlc1tpXS52YWx1ZSA9IHZhbHVlO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGNvbnRyb2wubWluID0gMDtcclxuXHRcdFx0XHRjb250cm9sLm1heCA9IHRoaXMub3B0aW9ucy5tYXhQcmljZTtcclxuXHRcdFx0XHRjb250cm9sLnN0ZXAgPSB0aGlzLm9wdGlvbnMuc3RlcDtcclxuXHRcdFx0XHRjb250cm9sLnZhbHVlID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdHRoaXMuJHRvcC5hcHBlbmQodGhpcy4kcHJpY2VzW2ldKTtcclxuXHRcdFx0XHR0aGlzLiRzbGlkZXIuYXBwZW5kKGNvbnRyb2wpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuJHNsaWRlci5hcHBlbmQodGhpcy4kcHJvZ3Jlc3MpO1xyXG5cdFx0XHR0aGlzLiR3cmFwcGVyLmFwcGVuZCh0aGlzLiR0b3AsIHRoaXMuJHNsaWRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0I2NsYW1wUHJpY2VzKG1pbiwgbWF4LCBjdXJyZW50ID0gJ21pbicpIHtcclxuXHRcdFx0Y29uc3QgeyBnYXAsIG1heFByaWNlIH0gPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0XHRtaW4gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBtaW4pLCBtYXhQcmljZSk7XHJcblx0XHRcdG1heCA9IE1hdGgubWluKE1hdGgubWF4KDAsIG1heCksIG1heFByaWNlKTtcclxuXHJcblx0XHRcdGlmIChtYXggLSBtaW4gPCBnYXApIHtcclxuXHRcdFx0XHRpZiAoY3VycmVudCA9PT0gJ21pbicpIHtcclxuXHRcdFx0XHRcdG1heCA9IE1hdGgubWluKG1heFByaWNlLCBtaW4gKyBnYXApO1xyXG5cdFx0XHRcdFx0bWluID0gbWF4IC0gZ2FwO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRtaW4gPSBNYXRoLm1heCgwLCBtYXggLSBnYXApO1xyXG5cdFx0XHRcdFx0bWF4ID0gbWluICsgZ2FwO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIFttaW4sIG1heF07XHJcblx0XHR9XHJcblxyXG5cdFx0I3VwZGF0ZVZhbHVlcyhtaW4sIG1heCkge1xyXG5cdFx0XHR0aGlzLiRwcmljZXNbMF0udmFsdWUgPSBtaW47XHJcblx0XHRcdHRoaXMuJHByaWNlc1sxXS52YWx1ZSA9IG1heDtcclxuXHRcdFx0dGhpcy4kY29udHJvbHNbMF0udmFsdWUgPSBtaW47XHJcblx0XHRcdHRoaXMuJGNvbnRyb2xzWzFdLnZhbHVlID0gbWF4O1xyXG5cclxuXHRcdFx0dGhpcy4kcHJvZ3Jlc3Muc3R5bGUubGVmdCA9IChtaW4gLyB0aGlzLm9wdGlvbnMubWF4UHJpY2UgKiAxMDApICsgXCIlXCI7XHJcblx0XHRcdHRoaXMuJHByb2dyZXNzLnN0eWxlLnJpZ2h0ID0gKDEwMCAtIG1heCAvIHRoaXMub3B0aW9ucy5tYXhQcmljZSAqIDEwMCkgKyBcIiVcIjtcclxuXHRcdH1cclxuXHJcblx0XHRzZXRDb250cm9scyhlKSB7XHJcblx0XHRcdGNvbnN0IGN1cnJlbnQgPSBlPy5jdXJyZW50VGFyZ2V0ID09PSB0aGlzLiRjb250cm9sc1swXSA/ICdtaW4nIDogJ21heCc7XHJcblx0XHRcdGxldCBtaW4gPSArdGhpcy4kY29udHJvbHNbMF0udmFsdWU7XHJcblx0XHRcdGxldCBtYXggPSArdGhpcy4kY29udHJvbHNbMV0udmFsdWU7XHJcblxyXG5cdFx0XHR0aGlzLiN1cGRhdGVWYWx1ZXMoLi4udGhpcy4jY2xhbXBQcmljZXMobWluLCBtYXgsIGN1cnJlbnQpKTtcclxuXHRcdH1cclxuXHJcblx0XHRzZXRQcmljZXMoZSkge1xyXG5cdFx0XHRjb25zdCBjdXJyZW50ID0gZT8uY3VycmVudFRhcmdldCA9PT0gdGhpcy4kcHJpY2VzWzBdID8gJ21pbicgOiAnbWF4JztcclxuXHRcdFx0bGV0IG1pbiA9ICt0aGlzLiRwcmljZXNbMF0udmFsdWU7XHJcblx0XHRcdGxldCBtYXggPSArdGhpcy4kcHJpY2VzWzFdLnZhbHVlO1xyXG5cclxuXHRcdFx0dGhpcy4jdXBkYXRlVmFsdWVzKC4uLnRoaXMuI2NsYW1wUHJpY2VzKG1pbiwgbWF4LCBjdXJyZW50KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aW5pdCgpIHtcclxuXHRcdFx0dGhpcy4kY29udHJvbHMuZm9yRWFjaChjb250cm9sID0+IHtcclxuXHRcdFx0XHRjb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLnNldENvbnRyb2xzLmJpbmQodGhpcykpO1xyXG5cdFx0XHR9KTtcdFxyXG5cdFx0XHJcblx0XHRcdHRoaXMub3B0aW9ucy5pbnB1dCAmJiB0aGlzLiRwcmljZXMuZm9yRWFjaChwcmljZSA9PiB7XHJcblx0XHRcdFx0cHJpY2UuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuc2V0UHJpY2VzLmJpbmQodGhpcykpO1xyXG5cdFx0XHRcdHByaWNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5zZXRQcmljZXMuYmluZCh0aGlzKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5zZXRDb250cm9scygpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFJhbmdlKGl0ZW0sIG9wdGlvbnMpO1xyXG59Il0sIm5hbWVzIjpbInR3ZWFrZXJSYW5nZURvdWJsZSIsIml0ZW0iLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiX1JhbmdlX2JyYW5kIiwiV2Vha1NldCIsIlJhbmdlIiwiX2l0ZW0kZGF0YXNldCIsIl9pdGVtJGRhdGFzZXQyIiwiX2l0ZW0kZGF0YXNldDMiLCJfaXRlbSRkYXRhc2V0NCIsIl9pdGVtJGRhdGFzZXQ1IiwiX2NsYXNzQ2FsbENoZWNrIiwiX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjIiwiRWxlbWVudCIsIl9vYmplY3RTcHJlYWQiLCJzdGFydE1pbiIsImRhdGFzZXQiLCJyYW5nZVN0YXJ0TWluIiwic3RhcnRNYXgiLCJyYW5nZVN0YXJ0TWF4IiwibWF4UHJpY2UiLCJyYW5nZU1heCIsInN0ZXAiLCJyYW5nZVN0ZXAiLCJnYXAiLCJyYW5nZUdhcCIsImlucHV0IiwiJHdyYXBwZXIiLCIkcHJpY2VzIiwiJGNvbnRyb2xzIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJjaGlsZCIsInR5cGUiLCIkcHJvZ3Jlc3MiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCIkc2xpZGVyIiwiJHRvcCIsInJlbmRlciIsImluaXQiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJ2YWx1ZSIsIl90aGlzIiwiY2xhc3NMaXN0IiwiYWRkIiwiY29uY2F0IiwiZm9yRWFjaCIsImNvbnRyb2wiLCJpIiwiZGlzYWJsZWQiLCJtaW4iLCJtYXgiLCJhcHBlbmQiLCJzZXRDb250cm9scyIsImUiLCJfYXNzZXJ0Q2xhc3NCcmFuZDIiLCJjdXJyZW50IiwiY3VycmVudFRhcmdldCIsIl9hc3NlcnRDbGFzc0JyYW5kIiwiX3VwZGF0ZVZhbHVlcyIsImNhbGwiLCJhcHBseSIsIl9jbGFtcFByaWNlcyIsInNldFByaWNlcyIsIl9hc3NlcnRDbGFzc0JyYW5kMyIsIl90aGlzMiIsImFkZEV2ZW50TGlzdGVuZXIiLCJiaW5kIiwicHJpY2UiLCJfdGhpcyRvcHRpb25zIiwiTWF0aCIsInN0eWxlIiwibGVmdCIsInJpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/libs/tweakerRangeDouble.js\n");

/***/ }),

/***/ "./src/js/libs/tweakerRangeSingle.js":
/*!*******************************************!*\
  !*** ./src/js/libs/tweakerRangeSingle.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tweakerRangeSingle: () => (/* binding */ tweakerRangeSingle)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nvar tweakerRangeSingle = function tweakerRangeSingle(item) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _Range_brand = /*#__PURE__*/new WeakSet();\n  var Range = /*#__PURE__*/function () {\n    function Range(item, options) {\n      _classCallCheck(this, Range);\n      _classPrivateMethodInitSpec(this, _Range_brand);\n      if (!item || !item instanceof Element) return;\n      this.options = _objectSpread({\n        \"class\": 'range',\n        min: item.min || 0,\n        max: item.max || 100,\n        current: item.value || 50\n      }, options);\n      this.$range = item;\n      this.$outer = document.createElement('div');\n      this.$progress = document.createElement('span');\n      this.$wrapperRange = document.createElement('div');\n      this.$wrapperNumber = document.createElement('div');\n      this.$number = document.createElement('input');\n      _assertClassBrand(_Range_brand, this, _render).call(this);\n      _assertClassBrand(_Range_brand, this, _progress).call(this);\n      this.init();\n    }\n    return _createClass(Range, [{\n      key: \"init\",\n      value: function init() {\n        var _this = this;\n        this.$range.addEventListener('input', function (e) {\n          _this.$number.value = Math.min(+(e === null || e === void 0 ? void 0 : e.currentTarget.value), _this.options.max);\n          _assertClassBrand(_Range_brand, _this, _progress).call(_this);\n        });\n        this.$number.addEventListener('input', function (e) {\n          var value = Math.min(Math.max(_this.options.min, +(e === null || e === void 0 ? void 0 : e.currentTarget.value)), _this.options.max);\n          _this.$range.value = _this.$number.value = value;\n          _assertClassBrand(_Range_brand, _this, _progress).call(_this);\n        });\n      }\n    }]);\n  }();\n  function _render() {\n    var _this2 = this;\n    if (this.$range.type !== 'range') return;\n    this.$outer.className = \"\".concat(this.$range.className, \" \").concat(this.options[\"class\"]);\n    Object.assign(this.$outer.dataset, this.$range.dataset);\n    Object.keys(this.$range.dataset).forEach(function (dataKey) {\n      delete _this2.$range.dataset[dataKey];\n    });\n    this.$range.removeAttribute('class');\n    this.$number.type = 'number';\n    this.$number.value = this.options.current;\n    this.$range.parentNode.insertBefore(this.$outer, this.$range.nextSibling || null);\n    this.$wrapperNumber.className = \"\".concat(this.options[\"class\"], \"__value\");\n    this.$wrapperRange.className = \"\".concat(this.options[\"class\"], \"__slider\");\n    this.$wrapperNumber.append(this.$number);\n    this.$wrapperRange.append(this.$range, this.$progress);\n    this.$outer.append(this.$wrapperNumber, this.$wrapperRange);\n  }\n  function _progress() {\n    var val = Math.min(this.$range.value, this.options.max);\n    var offset = ((val - this.options.min) / (this.options.max - this.options.min) * 100).toFixed(2);\n    this.$outer.style.setProperty(\"--progress\", \"\".concat(offset));\n  }\n  return new Range(item, options);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZXMiOlsid2VicGFjazovL2d1bHAtc2Nzcy1zdGFydGVyLy4vc3JjL2pzL2xpYnMvdHdlYWtlclJhbmdlU2luZ2xlLmpzPzQxNDkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHR3ZWFrZXJSYW5nZVNpbmdsZSA9IChpdGVtLCBvcHRpb25zID0ge30pID0+IHtcclxuXHRcdFxyXG5cdGNsYXNzIFJhbmdlIHtcclxuXHRcdGNvbnN0cnVjdG9yKGl0ZW0sIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYoIWl0ZW0gfHwgIWl0ZW0gaW5zdGFuY2VvZiBFbGVtZW50KSByZXR1cm47XHJcblxyXG5cdFx0XHR0aGlzLm9wdGlvbnMgPSB7XHJcblx0XHRcdFx0Y2xhc3M6ICdyYW5nZScsXHJcblx0XHRcdFx0bWluOiBpdGVtLm1pbiB8fCAwLFxyXG5cdFx0XHRcdG1heDogaXRlbS5tYXggfHwgMTAwLFxyXG5cdFx0XHRcdGN1cnJlbnQ6IGl0ZW0udmFsdWUgfHwgNTAsXHJcblx0XHRcdFx0Li4ub3B0aW9uc1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dGhpcy4kcmFuZ2UgPSBpdGVtO1xyXG5cdFx0XHR0aGlzLiRvdXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0XHR0aGlzLiRwcm9ncmVzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdFx0dGhpcy4kd3JhcHBlclJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRcdHRoaXMuJHdyYXBwZXJOdW1iZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdFx0dGhpcy4kbnVtYmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuI3JlbmRlcigpO1xyXG5cdFx0XHR0aGlzLiNwcm9ncmVzcygpO1xyXG5cdFx0XHR0aGlzLmluaXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQjcmVuZGVyKCkge1xyXG5cdFx0XHRpZiAodGhpcy4kcmFuZ2UudHlwZSAhPT0gJ3JhbmdlJykgcmV0dXJuO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy4kb3V0ZXIuY2xhc3NOYW1lID0gYCR7dGhpcy4kcmFuZ2UuY2xhc3NOYW1lfSAke3RoaXMub3B0aW9ucy5jbGFzc31gO1xyXG5cdFx0XHRPYmplY3QuYXNzaWduKHRoaXMuJG91dGVyLmRhdGFzZXQsIHRoaXMuJHJhbmdlLmRhdGFzZXQpO1xyXG5cclxuXHRcdFx0T2JqZWN0LmtleXModGhpcy4kcmFuZ2UuZGF0YXNldCkuZm9yRWFjaChkYXRhS2V5ID0+IHtcclxuXHRcdFx0XHRkZWxldGUgdGhpcy4kcmFuZ2UuZGF0YXNldFtkYXRhS2V5XTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR0aGlzLiRyYW5nZS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcblx0XHRcdHRoaXMuJG51bWJlci50eXBlID0gJ251bWJlcic7XHJcblx0XHRcdHRoaXMuJG51bWJlci52YWx1ZSA9IHRoaXMub3B0aW9ucy5jdXJyZW50O1xyXG5cdFx0XHR0aGlzLiRyYW5nZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLiRvdXRlciwgdGhpcy4kcmFuZ2UubmV4dFNpYmxpbmcgfHwgbnVsbCk7XHJcblxyXG5cdFx0XHR0aGlzLiR3cmFwcGVyTnVtYmVyLmNsYXNzTmFtZSA9IGAke3RoaXMub3B0aW9ucy5jbGFzc31fX3ZhbHVlYDtcclxuXHRcdFx0dGhpcy4kd3JhcHBlclJhbmdlLmNsYXNzTmFtZSA9IGAke3RoaXMub3B0aW9ucy5jbGFzc31fX3NsaWRlcmA7XHJcblxyXG5cdFx0XHR0aGlzLiR3cmFwcGVyTnVtYmVyLmFwcGVuZCh0aGlzLiRudW1iZXIpO1xyXG5cdFx0XHR0aGlzLiR3cmFwcGVyUmFuZ2UuYXBwZW5kKHRoaXMuJHJhbmdlLCB0aGlzLiRwcm9ncmVzcyk7XHJcblx0XHRcdHRoaXMuJG91dGVyLmFwcGVuZCh0aGlzLiR3cmFwcGVyTnVtYmVyLCB0aGlzLiR3cmFwcGVyUmFuZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCNwcm9ncmVzcygpIHtcclxuXHRcdFx0Y29uc3QgdmFsID0gTWF0aC5taW4odGhpcy4kcmFuZ2UudmFsdWUsIHRoaXMub3B0aW9ucy5tYXgpO1xyXG5cdFx0XHRjb25zdCBvZmZzZXQgPSAoKHZhbCAtIHRoaXMub3B0aW9ucy5taW4pIC8gKHRoaXMub3B0aW9ucy5tYXggLSB0aGlzLm9wdGlvbnMubWluKSAqIDEwMCkudG9GaXhlZCgyKTtcclxuXHRcdFx0dGhpcy4kb3V0ZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLXByb2dyZXNzXCIsIGAke29mZnNldH1gKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aW5pdCgpIHtcclxuXHRcdFx0dGhpcy4kcmFuZ2UuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZSkgPT4ge1xyXG5cdFx0XHRcdHRoaXMuJG51bWJlci52YWx1ZSA9IE1hdGgubWluKCtlPy5jdXJyZW50VGFyZ2V0LnZhbHVlLCB0aGlzLm9wdGlvbnMubWF4KTtcclxuXHRcdFx0XHR0aGlzLiNwcm9ncmVzcy5jYWxsKHRoaXMpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRoaXMuJG51bWJlci5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLm9wdGlvbnMubWluLCArZT8uY3VycmVudFRhcmdldC52YWx1ZSksIHRoaXMub3B0aW9ucy5tYXgpO1xyXG5cdFx0XHRcdHRoaXMuJHJhbmdlLnZhbHVlID0gdGhpcy4kbnVtYmVyLnZhbHVlID0gdmFsdWU7XHJcblx0XHRcdFx0dGhpcy4jcHJvZ3Jlc3MuY2FsbCh0aGlzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBuZXcgUmFuZ2UoaXRlbSwgb3B0aW9ucyk7XHJcbn0iXSwibmFtZXMiOlsidHdlYWtlclJhbmdlU2luZ2xlIiwiaXRlbSIsIm9wdGlvbnMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJfUmFuZ2VfYnJhbmQiLCJXZWFrU2V0IiwiUmFuZ2UiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMiLCJFbGVtZW50IiwiX29iamVjdFNwcmVhZCIsIm1pbiIsIm1heCIsImN1cnJlbnQiLCJ2YWx1ZSIsIiRyYW5nZSIsIiRvdXRlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIiRwcm9ncmVzcyIsIiR3cmFwcGVyUmFuZ2UiLCIkd3JhcHBlck51bWJlciIsIiRudW1iZXIiLCJfYXNzZXJ0Q2xhc3NCcmFuZCIsIl9yZW5kZXIiLCJjYWxsIiwiX3Byb2dyZXNzIiwiaW5pdCIsIl9jcmVhdGVDbGFzcyIsImtleSIsIl90aGlzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJNYXRoIiwiY3VycmVudFRhcmdldCIsIl90aGlzMiIsInR5cGUiLCJjbGFzc05hbWUiLCJjb25jYXQiLCJPYmplY3QiLCJhc3NpZ24iLCJkYXRhc2V0Iiwia2V5cyIsImZvckVhY2giLCJkYXRhS2V5IiwicmVtb3ZlQXR0cmlidXRlIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwiYXBwZW5kIiwidmFsIiwib2Zmc2V0IiwidG9GaXhlZCIsInN0eWxlIiwic2V0UHJvcGVydHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/libs/tweakerRangeSingle.js\n");

/***/ }),

/***/ "./src/js/libs/tweakerSelect.js":
/*!**************************************!*\
  !*** ./src/js/libs/tweakerSelect.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tweakerSelect: () => (/* binding */ tweakerSelect)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\n/* \r\n* Подменяет стантартный малоуправляемый html тег select \r\n* на более управляемую структуру, сохраняя функциональность селекта\r\n* \r\n* @исходная разметка:\r\n* \r\n<select class=\"someblock__select\">\r\n\t<option value=\"0\">consectetur</option>\r\n\t<option value=\"1\">adipisicing</option>\r\n\t<option value=\"2\">expedita</option>\r\n</select>\r\n* \r\n* @результирующая разметка:\r\n* \r\n* <div class=\"someblock__select select\">\r\n* \t<select style=\"display: none;\">\r\n* \t\t<option value=\"0\">consectetur</option>\r\n* \t\t<option value=\"1\">adipisicing</option>\r\n* \t\t<option value=\"2\">expedita</option>\r\n* \t</select>\r\n* \t<div class=\"select__head\">consectetur</div>\r\n* \t\t<ul class=\"select__list\">\r\n* \t\t\t<li class=\"select__item\" data-value=\"0\">consectetur</li>\r\n* \t\t\t<li class=\"select__item\" data-value=\"1\">adipisicing</li>\r\n* \t\t\t<li class=\"select__item\" data-value=\"2\">expedita</li>\r\n* \t\t</ul>\r\n* \t</div>\r\n* </div>\r\n* \r\n* @вызов:\r\n* \r\nimport { selectTweaker } from \"../../js/libs/selectTweaker\";\r\nconst select = selectTweaker(document.querySelector('.someblock__select'), {\r\n\tname: 'select',\r\n\tselect: function(i) {\r\n\t\tconsole.log(this, i);\r\n\t}\r\n});\r\n*/\n\nvar tweakerSelect = function tweakerSelect(items) {\n  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _Select_brand = /*#__PURE__*/new WeakSet();\n  var _update = /*#__PURE__*/new WeakMap();\n  var Select = /*#__PURE__*/_createClass(function Select(select, props) {\n    var _this = this;\n    _classCallCheck(this, Select);\n    _classPrivateMethodInitSpec(this, _Select_brand);\n    _classPrivateFieldInitSpec(this, _update, function (i, e) {\n      var _this$props$select;\n      e === null || e === void 0 || e.preventDefault();\n      _this.wrapper.classList.remove(_this.openClassName, _this.flipClassName);\n      _this.head.textContent = _this.items[i].textContent;\n      _assertClassBrand(_Select_brand, _this, _dataset).call(_this, _this.items[i], _this.head, false);\n      _this.select.value = _this.items[i].getAttribute('data-value');\n      _this.items.forEach(function (item) {\n        return item.classList.remove(_this.currentClass);\n      });\n      _this.items[i].classList.add(_this.currentClass);\n      e && _this.select.dispatchEvent(new Event(\"change\"));\n      e && ((_this$props$select = _this.props.select) === null || _this$props$select === void 0 ? void 0 : _this$props$select.call(_this.wrapper, i));\n    });\n    if (!select || select.tagName !== 'SELECT') return;\n    this.props = _objectSpread({\n      name: 'select'\n    }, props);\n    this.select = select;\n    this.options = select.querySelectorAll('option');\n    this.currentClass = \"\".concat(this.props.name, \"__item_current\");\n    this.selectedIndex = _toConsumableArray(this.options).findIndex(function (opt) {\n      return opt.selected;\n    });\n    this.wrapper = document.createElement('div');\n    this.head = document.createElement('div');\n    this.body = document.createElement('div');\n    this.list = document.createElement('ul');\n    this.wrapper.className = \"\".concat(select.className, \" \").concat(this.props.name);\n    this.head.className = \"\".concat(this.props.name, \"__head\");\n    this.body.className = \"\".concat(this.props.name, \"__body\");\n    this.list.className = \"\".concat(this.props.name, \"__list\");\n    this.openClassName = \"\".concat(this.props.name, \"_opened\");\n    this.flipClassName = \"\".concat(this.props.name, \"_flipped\");\n    _assertClassBrand(_Select_brand, this, _init).call(this);\n  });\n  function _dataset(from, to) {\n    var remove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var omit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'value';\n    var omits = omit && omit.split(',').map(function (i) {\n      return i.trim();\n    }) || [];\n    for (var data in from.dataset) {\n      if (omits.includes(data)) continue;\n      to.dataset[\"\".concat(data)] = from.dataset[data];\n      remove && from.removeAttribute(\"data-\".concat(data));\n    }\n  }\n  function _render() {\n    var _this2 = this;\n    _assertClassBrand(_Select_brand, this, _dataset).call(this, this.select, this.wrapper);\n    this.select.parentNode.insertBefore(this.wrapper, this.select.nextSibling || null);\n    this.body.append(this.list);\n    this.wrapper.append(this.select, this.head, this.body);\n    this.head.textContent = this.options[this.selectedIndex].textContent;\n    _assertClassBrand(_Select_brand, this, _dataset).call(this, this.options[this.selectedIndex], this.head, false);\n    this.select.removeAttribute('class');\n    this.select.style.display = 'none';\n    _toConsumableArray(this.options).forEach(function (opt) {\n      var item = document.createElement('li');\n      item.className = \"\".concat(_this2.props.name, \"__item\");\n      item.dataset.value = opt.value;\n      item.innerText = opt.text;\n      _assertClassBrand(_Select_brand, _this2, _dataset).call(_this2, opt, item);\n      _this2.list.append(item);\n    });\n    this.items = _toConsumableArray(this.list.children);\n    this.items[this.selectedIndex].classList.add(this.currentClass);\n  }\n  function _init() {\n    var _this3 = this;\n    _assertClassBrand(_Select_brand, this, _render).call(this);\n    this.head.addEventListener('click', function () {\n      _this3.wrapper.classList.toggle(_this3.openClassName);\n      _this3.wrapper.classList.contains(_this3.openClassName) ? requestAnimationFrame(function () {\n        return _this3.wrapper.classList.toggle(_this3.flipClassName, _this3.body.getBoundingClientRect().bottom > window.innerHeight);\n      }) : _this3.wrapper.classList.remove(_this3.flipClassName);\n    });\n    this.options.forEach(function (option, i) {\n      return option.addEventListener('click', function () {\n        return _classPrivateFieldGet(_update, _this3).call(_this3, i);\n      });\n    });\n    this.items.forEach(function (item, i) {\n      return item.addEventListener('click', function (e) {\n        return _classPrivateFieldGet(_update, _this3).call(_this3, i, e);\n      });\n    });\n    ['click', 'touchstart'].forEach(function (event) {\n      document.addEventListener(event, function (e) {\n        if (!_this3.wrapper.contains(e.target)) _this3.wrapper.classList.remove(_this3.openClassName, _this3.flipClassName);\n      }, {\n        passive: false\n      });\n    });\n  }\n  if (items instanceof NodeList || Array.isArray(items)) {\n    items.forEach(function (item) {\n      return new Select(item, props);\n    });\n  } else {\n    return new Select(items, props);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVrRSxPQUFPLEVBQUU7TUFBTSxDQUFDLENBQUM7SUFDdkIsQ0FBQyxDQUFDO0VBQ0g7RUFHRCxJQUFJMUYsS0FBSyxZQUFZMkYsUUFBUSxJQUFJQyxLQUFLLENBQUNDLE9BQU8sQ0FBQzdGLEtBQUssQ0FBQyxFQUFFO0lBQ3REQSxLQUFLLENBQUNnQyxPQUFPLENBQUMsVUFBQ0MsSUFBSTtNQUFBLE9BQUssSUFBSXhCLE1BQU0sQ0FBQ3dCLElBQUksRUFBRWhDLEtBQUssQ0FBQztJQUFBLEVBQUM7RUFDakQsQ0FBQyxNQUFNO0lBQ04sT0FBTyxJQUFJUSxNQUFNLENBQUNULEtBQUssRUFBRUMsS0FBSyxDQUFDO0VBQ2hDO0FBQ0QsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2d1bHAtc2Nzcy1zdGFydGVyLy4vc3JjL2pzL2xpYnMvdHdlYWtlclNlbGVjdC5qcz9lODViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFxyXG4qINCf0L7QtNC80LXQvdGP0LXRgiDRgdGC0LDQvdGC0LDRgNGC0L3Ri9C5INC80LDQu9C+0YPQv9GA0LDQstC70Y/QtdC80YvQuSBodG1sINGC0LXQsyBzZWxlY3QgXHJcbiog0L3QsCDQsdC+0LvQtdC1INGD0L/RgNCw0LLQu9GP0LXQvNGD0Y4g0YHRgtGA0YPQutGC0YPRgNGDLCDRgdC+0YXRgNCw0L3Rj9GPINGE0YPQvdC60YbQuNC+0L3QsNC70YzQvdC+0YHRgtGMINGB0LXQu9C10LrRgtCwXHJcbiogXHJcbiogQNC40YHRhdC+0LTQvdCw0Y8g0YDQsNC30LzQtdGC0LrQsDpcclxuKiBcclxuPHNlbGVjdCBjbGFzcz1cInNvbWVibG9ja19fc2VsZWN0XCI+XHJcblx0PG9wdGlvbiB2YWx1ZT1cIjBcIj5jb25zZWN0ZXR1cjwvb3B0aW9uPlxyXG5cdDxvcHRpb24gdmFsdWU9XCIxXCI+YWRpcGlzaWNpbmc8L29wdGlvbj5cclxuXHQ8b3B0aW9uIHZhbHVlPVwiMlwiPmV4cGVkaXRhPC9vcHRpb24+XHJcbjwvc2VsZWN0PlxyXG4qIFxyXG4qIEDRgNC10LfRg9C70YzRgtC40YDRg9GO0YnQsNGPINGA0LDQt9C80LXRgtC60LA6XHJcbiogXHJcbiogPGRpdiBjbGFzcz1cInNvbWVibG9ja19fc2VsZWN0IHNlbGVjdFwiPlxyXG4qIFx0PHNlbGVjdCBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XHJcbiogXHRcdDxvcHRpb24gdmFsdWU9XCIwXCI+Y29uc2VjdGV0dXI8L29wdGlvbj5cclxuKiBcdFx0PG9wdGlvbiB2YWx1ZT1cIjFcIj5hZGlwaXNpY2luZzwvb3B0aW9uPlxyXG4qIFx0XHQ8b3B0aW9uIHZhbHVlPVwiMlwiPmV4cGVkaXRhPC9vcHRpb24+XHJcbiogXHQ8L3NlbGVjdD5cclxuKiBcdDxkaXYgY2xhc3M9XCJzZWxlY3RfX2hlYWRcIj5jb25zZWN0ZXR1cjwvZGl2PlxyXG4qIFx0XHQ8dWwgY2xhc3M9XCJzZWxlY3RfX2xpc3RcIj5cclxuKiBcdFx0XHQ8bGkgY2xhc3M9XCJzZWxlY3RfX2l0ZW1cIiBkYXRhLXZhbHVlPVwiMFwiPmNvbnNlY3RldHVyPC9saT5cclxuKiBcdFx0XHQ8bGkgY2xhc3M9XCJzZWxlY3RfX2l0ZW1cIiBkYXRhLXZhbHVlPVwiMVwiPmFkaXBpc2ljaW5nPC9saT5cclxuKiBcdFx0XHQ8bGkgY2xhc3M9XCJzZWxlY3RfX2l0ZW1cIiBkYXRhLXZhbHVlPVwiMlwiPmV4cGVkaXRhPC9saT5cclxuKiBcdFx0PC91bD5cclxuKiBcdDwvZGl2PlxyXG4qIDwvZGl2PlxyXG4qIFxyXG4qIEDQstGL0LfQvtCyOlxyXG4qIFxyXG5pbXBvcnQgeyBzZWxlY3RUd2Vha2VyIH0gZnJvbSBcIi4uLy4uL2pzL2xpYnMvc2VsZWN0VHdlYWtlclwiO1xyXG5jb25zdCBzZWxlY3QgPSBzZWxlY3RUd2Vha2VyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zb21lYmxvY2tfX3NlbGVjdCcpLCB7XHJcblx0bmFtZTogJ3NlbGVjdCcsXHJcblx0c2VsZWN0OiBmdW5jdGlvbihpKSB7XHJcblx0XHRjb25zb2xlLmxvZyh0aGlzLCBpKTtcclxuXHR9XHJcbn0pO1xyXG4qL1xyXG5cclxuZXhwb3J0IGNvbnN0IHR3ZWFrZXJTZWxlY3QgPSAoaXRlbXMsIHByb3BzID0ge30pID0+IHtcclxuXHRjbGFzcyBTZWxlY3Qge1xyXG5cdFx0Y29uc3RydWN0b3Ioc2VsZWN0LCBwcm9wcykge1xyXG5cdFx0XHRpZighc2VsZWN0IHx8IHNlbGVjdC50YWdOYW1lICE9PSAnU0VMRUNUJykgcmV0dXJuO1xyXG5cclxuXHRcdFx0dGhpcy5wcm9wcyA9IHtcclxuXHRcdFx0XHRuYW1lOiAnc2VsZWN0JyxcclxuXHRcdFx0XHQuLi5wcm9wc1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dGhpcy5zZWxlY3QgPSBzZWxlY3Q7XHJcblx0XHRcdHRoaXMub3B0aW9ucyA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCdvcHRpb24nKTtcclxuXHRcdFx0dGhpcy5jdXJyZW50Q2xhc3MgPSBgJHt0aGlzLnByb3BzLm5hbWV9X19pdGVtX2N1cnJlbnRgO1xyXG5cdFx0XHR0aGlzLnNlbGVjdGVkSW5kZXggPSBbLi4udGhpcy5vcHRpb25zXS5maW5kSW5kZXgob3B0ID0+IG9wdC5zZWxlY3RlZCk7XHJcblxyXG5cdFx0XHR0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdFx0dGhpcy5oZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRcdHRoaXMuYm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0XHR0aGlzLmxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xyXG5cclxuXHRcdFx0dGhpcy53cmFwcGVyLmNsYXNzTmFtZSA9IGAke3NlbGVjdC5jbGFzc05hbWV9ICR7dGhpcy5wcm9wcy5uYW1lfWA7XHJcblx0XHRcdHRoaXMuaGVhZC5jbGFzc05hbWUgPSBgJHt0aGlzLnByb3BzLm5hbWV9X19oZWFkYDtcclxuXHRcdFx0dGhpcy5ib2R5LmNsYXNzTmFtZSA9IGAke3RoaXMucHJvcHMubmFtZX1fX2JvZHlgO1xyXG5cdFx0XHR0aGlzLmxpc3QuY2xhc3NOYW1lID0gYCR7dGhpcy5wcm9wcy5uYW1lfV9fbGlzdGA7XHJcblx0XHRcdHRoaXMub3BlbkNsYXNzTmFtZSA9IGAke3RoaXMucHJvcHMubmFtZX1fb3BlbmVkYDtcclxuXHRcdFx0dGhpcy5mbGlwQ2xhc3NOYW1lID0gYCR7dGhpcy5wcm9wcy5uYW1lfV9mbGlwcGVkYDtcclxuXHJcblx0XHRcdHRoaXMuI2luaXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQjZGF0YXNldChmcm9tLCB0bywgcmVtb3ZlID0gdHJ1ZSwgb21pdCA9ICd2YWx1ZScpIHtcclxuXHRcdFx0Y29uc3Qgb21pdHMgPSAob21pdCAmJiBvbWl0LnNwbGl0KCcsJykubWFwKGkgPT4gaS50cmltKCkpKSB8fCBbXTtcclxuXHJcblx0XHRcdGZvcihsZXQgZGF0YSBpbiBmcm9tLmRhdGFzZXQpIHtcclxuXHRcdFx0XHRpZiAob21pdHMuaW5jbHVkZXMoZGF0YSkpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHRvLmRhdGFzZXRbYCR7ZGF0YX1gXSA9IGZyb20uZGF0YXNldFtkYXRhXTtcclxuXHRcdFx0XHRyZW1vdmUgJiYgZnJvbS5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtJHtkYXRhfWApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0I3JlbmRlcigpIHtcclxuXHRcdFx0dGhpcy4jZGF0YXNldCh0aGlzLnNlbGVjdCwgdGhpcy53cmFwcGVyKTtcclxuXHRcdFx0dGhpcy5zZWxlY3QucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy53cmFwcGVyLCB0aGlzLnNlbGVjdC5uZXh0U2libGluZyB8fCBudWxsKTtcclxuXHJcblx0XHRcdHRoaXMuYm9keS5hcHBlbmQodGhpcy5saXN0KTtcclxuXHRcdFx0dGhpcy53cmFwcGVyLmFwcGVuZCh0aGlzLnNlbGVjdCwgdGhpcy5oZWFkLCB0aGlzLmJvZHkpO1xyXG5cdFx0XHR0aGlzLmhlYWQudGV4dENvbnRlbnQgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS50ZXh0Q29udGVudDtcclxuXHRcdFx0dGhpcy4jZGF0YXNldCh0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XSwgdGhpcy5oZWFkLCBmYWxzZSk7XHJcblx0XHRcdHRoaXMuc2VsZWN0LnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcclxuXHRcdFx0dGhpcy5zZWxlY3Quc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHJcblx0XHRcdFsuLi50aGlzLm9wdGlvbnNdLmZvckVhY2gob3B0ID0+IHtcclxuXHRcdFx0XHRjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcclxuXHJcblx0XHRcdFx0aXRlbS5jbGFzc05hbWUgPSBgJHt0aGlzLnByb3BzLm5hbWV9X19pdGVtYDtcclxuXHRcdFx0XHRpdGVtLmRhdGFzZXQudmFsdWUgPSBvcHQudmFsdWU7XHJcblx0XHRcdFx0aXRlbS5pbm5lclRleHQgPSBvcHQudGV4dDtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHR0aGlzLiNkYXRhc2V0KG9wdCwgaXRlbSk7XHJcblx0XHRcdFx0dGhpcy5saXN0LmFwcGVuZChpdGVtKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR0aGlzLml0ZW1zID0gWy4uLnRoaXMubGlzdC5jaGlsZHJlbl07XHJcblx0XHRcdHRoaXMuaXRlbXNbdGhpcy5zZWxlY3RlZEluZGV4XS5jbGFzc0xpc3QuYWRkKHRoaXMuY3VycmVudENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHQjdXBkYXRlID0gKGksIGUpID0+IHtcclxuXHRcdFx0ZT8ucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHRcdHRoaXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3BlbkNsYXNzTmFtZSwgdGhpcy5mbGlwQ2xhc3NOYW1lKTtcclxuXHRcdFx0dGhpcy5oZWFkLnRleHRDb250ZW50ID0gdGhpcy5pdGVtc1tpXS50ZXh0Q29udGVudDtcclxuXHRcdFx0dGhpcy4jZGF0YXNldCh0aGlzLml0ZW1zW2ldLCB0aGlzLmhlYWQsIGZhbHNlKTtcclxuXHRcdFx0dGhpcy5zZWxlY3QudmFsdWUgPSB0aGlzLml0ZW1zW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY3VycmVudENsYXNzKSk7XHJcblx0XHRcdHRoaXMuaXRlbXNbaV0uY2xhc3NMaXN0LmFkZCh0aGlzLmN1cnJlbnRDbGFzcyk7XHJcblx0XHRcdFxyXG5cdFx0XHRlICYmIHRoaXMuc2VsZWN0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiY2hhbmdlXCIpKTtcclxuXHRcdFx0ZSAmJiB0aGlzLnByb3BzLnNlbGVjdD8uY2FsbCh0aGlzLndyYXBwZXIsIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCNpbml0KCkge1xyXG5cdFx0XHR0aGlzLiNyZW5kZXIoKTtcclxuXHJcblx0XHRcdHRoaXMuaGVhZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuXHRcdFx0XHR0aGlzLndyYXBwZXIuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLm9wZW5DbGFzc05hbWUpO1xyXG5cdFx0XHRcdHRoaXMud3JhcHBlci5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcGVuQ2xhc3NOYW1lKVxyXG5cdFx0XHRcdFx0PyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gXHJcblx0XHRcdFx0XHRcdHRoaXMud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuZmxpcENsYXNzTmFtZSwgdGhpcy5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSA+IHdpbmRvdy5pbm5lckhlaWdodClcclxuXHRcdFx0XHRcdCkgOiB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmZsaXBDbGFzc05hbWUpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRoaXMub3B0aW9ucy5mb3JFYWNoKChvcHRpb24sIGkpID0+IG9wdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuI3VwZGF0ZShpKSkpO1xyXG5cdFx0XHR0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuI3VwZGF0ZShpLCBlKSkpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRbJ2NsaWNrJywndG91Y2hzdGFydCddLmZvckVhY2goZXZlbnQgPT4ge1xyXG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGUgPT4geyBcclxuXHRcdFx0XHRcdGlmICghdGhpcy53cmFwcGVyLmNvbnRhaW5zKGUudGFyZ2V0KSlcclxuXHRcdFx0XHRcdFx0dGhpcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcGVuQ2xhc3NOYW1lLCB0aGlzLmZsaXBDbGFzc05hbWUpO1xyXG5cdFx0XHRcdH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKGl0ZW1zIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcclxuXHRcdGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IG5ldyBTZWxlY3QoaXRlbSwgcHJvcHMpKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIG5ldyBTZWxlY3QoaXRlbXMsIHByb3BzKTtcclxuXHR9XHJcbn0iXSwibmFtZXMiOlsidHdlYWtlclNlbGVjdCIsIml0ZW1zIiwicHJvcHMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJfU2VsZWN0X2JyYW5kIiwiV2Vha1NldCIsIl91cGRhdGUiLCJXZWFrTWFwIiwiU2VsZWN0IiwiX2NyZWF0ZUNsYXNzIiwic2VsZWN0IiwiX3RoaXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMiLCJfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyIsImkiLCJlIiwiX3RoaXMkcHJvcHMkc2VsZWN0IiwicHJldmVudERlZmF1bHQiLCJ3cmFwcGVyIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwib3BlbkNsYXNzTmFtZSIsImZsaXBDbGFzc05hbWUiLCJoZWFkIiwidGV4dENvbnRlbnQiLCJfYXNzZXJ0Q2xhc3NCcmFuZCIsIl9kYXRhc2V0IiwiY2FsbCIsInZhbHVlIiwiZ2V0QXR0cmlidXRlIiwiZm9yRWFjaCIsIml0ZW0iLCJjdXJyZW50Q2xhc3MiLCJhZGQiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJ0YWdOYW1lIiwiX29iamVjdFNwcmVhZCIsIm5hbWUiLCJvcHRpb25zIiwicXVlcnlTZWxlY3RvckFsbCIsImNvbmNhdCIsInNlbGVjdGVkSW5kZXgiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJmaW5kSW5kZXgiLCJvcHQiLCJzZWxlY3RlZCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImJvZHkiLCJsaXN0IiwiY2xhc3NOYW1lIiwiX2luaXQiLCJmcm9tIiwidG8iLCJvbWl0Iiwib21pdHMiLCJzcGxpdCIsIm1hcCIsInRyaW0iLCJkYXRhIiwiZGF0YXNldCIsImluY2x1ZGVzIiwicmVtb3ZlQXR0cmlidXRlIiwiX3JlbmRlciIsIl90aGlzMiIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsImFwcGVuZCIsInN0eWxlIiwiZGlzcGxheSIsImlubmVyVGV4dCIsInRleHQiLCJjaGlsZHJlbiIsIl90aGlzMyIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0b2dnbGUiLCJjb250YWlucyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJvdHRvbSIsIndpbmRvdyIsImlubmVySGVpZ2h0Iiwib3B0aW9uIiwiX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwiZXZlbnQiLCJ0YXJnZXQiLCJwYXNzaXZlIiwiTm9kZUxpc3QiLCJBcnJheSIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/libs/tweakerSelect.js\n");

/***/ }),

/***/ "./src/js/libs/utils.js":
/*!******************************!*\
  !*** ./src/js/libs/utils.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cloneObj: () => (/* binding */ _cloneObj),\n/* harmony export */   getHeight: () => (/* binding */ getHeight),\n/* harmony export */   getScrollSize: () => (/* binding */ getScrollSize),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   mergeDeep: () => (/* binding */ _mergeDeep),\n/* harmony export */   scrollToId: () => (/* binding */ scrollToId),\n/* harmony export */   scrollToTop: () => (/* binding */ scrollToTop),\n/* harmony export */   textareaResize: () => (/* binding */ textareaResize),\n/* harmony export */   throttle: () => (/* binding */ throttle),\n/* harmony export */   updateLocalStorage: () => (/* binding */ updateLocalStorage),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\nvar _this = undefined;\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n// Проверка на объект (не массив)\nvar isObject = function isObject(item) {\n  return item && _typeof(item) === 'object' && !Array.isArray(item);\n};\n\n// Слияние двух объектов с глубокой вложенностью\nvar _mergeDeep = function mergeDeep(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n  if (!sources.length) return target;\n  var source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (var key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));\n        _mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, _defineProperty({}, key, source[key]));\n      }\n    }\n  }\n  return _mergeDeep.apply(void 0, [target].concat(sources));\n};\n\n// Глубокое клонирование объекта\n\nvar _cloneObj = function cloneObj(obj) {\n  if (obj === null || _typeof(obj) !== 'object') return obj;\n  var newObj = Array.isArray(obj) ? [] : {};\n  for (var prop in obj) {\n    obj.hasOwnProperty(prop) && (newObj[prop] = _cloneObj(obj[prop]));\n  }\n  return newObj;\n};\n\n// Отложить вызов функции\n\nvar throttle = function throttle(fn) {\n  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;\n  var timeout = null;\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    if (timeout === null) {\n      // fn.apply(this, args);\n\n      timeout = setTimeout(function () {\n        fn.apply(_this, args);\n        timeout = null;\n      }, delay);\n    }\n  };\n};\n\n/* window.addEventListener(\"resize\", throttle(() => {\r\n\tconsole.log('hello');\r\n}, 200)); */\n\n// Получить ширину прокрутки\nvar getScrollSize = function getScrollSize() {\n  var outer = document.createElement('div');\n  var inner = document.createElement('div');\n  outer.style.overflow = 'scroll';\n  outer.classList.add('scrollbar');\n  document.body.appendChild(outer);\n  outer.appendChild(inner);\n  var scrollbarSize = outer.offsetWidth - inner.offsetWidth;\n  document.body.removeChild(outer);\n  return scrollbarSize;\n};\n\n// Получить высоту скрытого элемента\nvar getHeight = function getHeight(el) {\n  if (!el) return;\n  var computed = window.getComputedStyle(el);\n  var height = el.offsetHeight;\n\n  // Если элемент с \"border-box\", учитываем паддинги и бордеры\n  if (computed.boxSizing !== \"border-box\") {\n    height -= parseFloat(computed.paddingTop) + parseFloat(computed.borderBottomWidth) + parseFloat(computed.borderTopWidth) + parseFloat(computed.paddingBottom);\n  }\n\n  // Если высота авто и элемент скрыт, клонируем его для вычислений\n  if (computed.height === 'auto' && computed.display === 'none') {\n    var clone = el.cloneNode(true);\n    Object.assign(clone.style, {\n      visibility: 'hidden',\n      overflow: 'visible',\n      maxHeight: 'none',\n      display: 'block',\n      opacity: '0'\n    });\n    el.after(clone);\n    height = clone.offsetHeight;\n    clone.remove();\n  }\n  return height;\n};\n\n/* \r\n* Плавная прокрутка к заданному элементу \r\n* @вызов:\r\n* \r\nimport { scrollToId } from \"../../js/libs/utils\";\r\nscrollToId(document.querySelectorAll('a[href^=\"#\"]'));\r\n* \r\n*/\n\nvar scrollToId = function scrollToId(items) {\n  items.forEach(function (item) {\n    item.addEventListener('click', function (e) {\n      e.preventDefault();\n      document.getElementById(item.getAttribute('href').substring(1)).scrollIntoView({\n        behavior: 'smooth',\n        block: 'start'\n      });\n    });\n  });\n};\n\n/* \r\n* Плавная прокрутка к верху страницы\r\n* @вызов:\r\n* \r\nimport { scrollToTop } from \"../../js/libs/utils\";\r\nscrollToTop(document.querySelector('a[href^=\"top\"]'));\r\n* \r\n*/\n\nvar scrollToTop = function scrollToTop(item) {\n  if (item) {\n    item.addEventListener('click', function (e) {\n      e.preventDefault();\n      window.scrollTo({\n        top: 0,\n        behavior: 'smooth'\n      });\n    });\n  }\n};\n\n/* \r\n* Обновление заданного массива в localStorage\r\n* @вызов:\r\n* \r\nimport { updateLocalStorage } from \"../../js/libs/utils\";\r\nupdateLocalStorage('myArray', 'item1');\r\nupdateLocalStorage('myArray', 'item1', false);\r\n* \r\n*/\n\nvar updateLocalStorage = function updateLocalStorage(key, item) {\n  var add = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var storage = JSON.parse(localStorage.getItem(key)) || [];\n  var updated = add ? _toConsumableArray(new Set([].concat(_toConsumableArray(storage), [item]))) : storage.filter(function (val) {\n    return val !== item;\n  });\n  localStorage.setItem(key, JSON.stringify(updated));\n};\n\n/* \r\n* Простая валидация формы\r\n* @вызов:\r\n* \r\nimport { validate } from \"../../js/libs/utils\";\r\ninput.classList.toggle('error', !validate(input));\r\n* \r\n*/\n\nvar validate = function validate(input) {\n  if (!input || !input.dataset.rules) return true;\n  var rules = input.dataset.rules.split(',').map(function (rule) {\n    return rule.trim();\n  }).filter(Boolean);\n  if (!rules.length) return true;\n  var value = input.value.trim();\n  var patterns = {\n    req: /.+/,\n    omit: /^$/,\n    num: /^\\d*$/,\n    name: /^[a-zA-Zа-яА-ЯёЁ\\s-]+$/,\n    phone: /^\\+?\\d{1,4}[-\\d()\\s]{5,20}$/,\n    email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\n    url: /^(https?:\\/\\/)?([\\w-]+\\.)+[\\w-]+(\\/[\\w-./?%&=]*)?$/i\n  };\n  var _iterator = _createForOfIteratorHelper(rules),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var rule = _step.value;\n      if (rule.startsWith('min:') && value.length < +rule.slice(4)) return false;\n      if (rule.startsWith('max:') && value.length > +rule.slice(4)) return false;\n      if (rule.startsWith('num:') && (isNaN(+value) || +value > +rule.slice(4))) return false;\n      if (patterns[rule] && !patterns[rule].test(value)) return false;\n      if (!patterns[rule] && !rule.includes(':')) {\n        console.warn(\"Unknown rule: \".concat(rule));\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return true;\n};\n\n/* \r\n* Изменение высоты формы по мере ввода текста\r\n* @вызов:\r\n* \r\nimport { textareaResize } from \"../../js/libs/utils\";\r\ndocument.querySelectorAll('textarea').forEach(autoResizeTextarea);\r\n* \r\n*/\n\nvar textareaResize = function textareaResize(textarea) {\n  if (!textarea) return;\n  var resize = function resize() {\n    var style = getComputedStyle(textarea);\n    var borderOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n    textarea.style.height = 'auto';\n    textarea.style.height = textarea.scrollHeight + borderOffset + 'px';\n  };\n  textarea.addEventListener('input', resize);\n  resize();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBQWIsU0FBQSxDQUFBYyxDQUFBO0VBQUE7RUFFRCxPQUFPLElBQUk7QUFDWixDQUFDOztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sSUFBTUMsY0FBYyxHQUFHLFNBQWpCQSxjQUFjQSxDQUFJQyxRQUFRLEVBQUs7RUFDM0MsSUFBSSxDQUFDQSxRQUFRLEVBQUU7RUFFZixJQUFNQyxNQUFNLEdBQUcsU0FBVEEsTUFBTUEsQ0FBQSxFQUFTO0lBQ3BCLElBQU03RixLQUFLLEdBQUdhLGdCQUFnQixDQUFDK0UsUUFBUSxDQUFDO0lBQ3hDLElBQU1FLFlBQVksR0FBRzdFLFVBQVUsQ0FBQ2pCLEtBQUssQ0FBQ29CLGNBQWMsQ0FBQyxHQUFHSCxVQUFVLENBQUNqQixLQUFLLENBQUNtQixpQkFBaUIsQ0FBQztJQUUzRnlFLFFBQVEsQ0FBQzVGLEtBQUssQ0FBQ2MsTUFBTSxHQUFHLE1BQU07SUFDOUI4RSxRQUFRLENBQUM1RixLQUFLLENBQUNjLE1BQU0sR0FBSThFLFFBQVEsQ0FBQ0csWUFBWSxHQUFHRCxZQUFZLEdBQUksSUFBSTtFQUN0RSxDQUFDO0VBRURGLFFBQVEsQ0FBQzNELGdCQUFnQixDQUFDLE9BQU8sRUFBRTRELE1BQU0sQ0FBQztFQUMxQ0EsTUFBTSxDQUFDLENBQUM7QUFDVCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3VscC1zY3NzLXN0YXJ0ZXIvLi9zcmMvanMvbGlicy91dGlscy5qcz80OWYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vINCf0YDQvtCy0LXRgNC60LAg0L3QsCDQvtCx0YrQtdC60YIgKNC90LUg0LzQsNGB0YHQuNCyKVxyXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSAoaXRlbSkgPT4ge1xyXG5cdHJldHVybiAoaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSkpO1xyXG59XHJcblxyXG5cclxuLy8g0KHQu9C40Y/QvdC40LUg0LTQstGD0YUg0L7QsdGK0LXQutGC0L7QsiDRgSDQs9C70YPQsdC+0LrQvtC5INCy0LvQvtC20LXQvdC90L7RgdGC0YzRjlxyXG5leHBvcnQgY29uc3QgbWVyZ2VEZWVwID0gKHRhcmdldCwgLi4uc291cmNlcykgPT4ge1xyXG5cdGlmICghc291cmNlcy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XHJcblx0Y29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xyXG5cclxuXHRpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XHJcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcclxuXHRcdFx0aWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xyXG5cdFx0XHRcdGlmICghdGFyZ2V0W2tleV0pIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XHJcblx0XHRcdFx0XHRba2V5XToge31cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRPYmplY3QuYXNzaWduKHRhcmdldCwge1xyXG5cdFx0XHRcdFx0W2tleV06IHNvdXJjZVtrZXldXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG1lcmdlRGVlcCh0YXJnZXQsIC4uLnNvdXJjZXMpO1xyXG59XHJcblxyXG5cclxuLy8g0JPQu9GD0LHQvtC60L7QtSDQutC70L7QvdC40YDQvtCy0LDQvdC40LUg0L7QsdGK0LXQutGC0LBcclxuZXhwb3J0IGNvbnN0IGNsb25lT2JqID0gKG9iaikgPT4ge1xyXG5cdGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHJldHVybiBvYmo7XHJcblxyXG5cdGNvbnN0IG5ld09iaiA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XHJcblxyXG5cdGZvciAobGV0IHByb3AgaW4gb2JqKSB7XHJcblx0XHRvYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgKG5ld09ialtwcm9wXSA9IGNsb25lT2JqKG9ialtwcm9wXSkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ld09iajtcclxufTtcclxuXHJcblxyXG4vLyDQntGC0LvQvtC20LjRgtGMINCy0YvQt9C+0LIg0YTRg9C90LrRhtC40LhcclxuZXhwb3J0IGNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSA9IDI1MCkgPT4ge1xyXG5cdGxldCB0aW1lb3V0ID0gbnVsbDtcclxuXHJcblx0cmV0dXJuICguLi5hcmdzKSA9PiB7XHJcblx0XHRpZiAodGltZW91dCA9PT0gbnVsbCkge1xyXG5cdFx0XHQvLyBmbi5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHRcdFx0XHJcblx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuXHRcdFx0XHRmbi5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHRcdFx0XHR0aW1lb3V0ID0gbnVsbDtcclxuXHRcdFx0fSwgZGVsYXkpXHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aHJvdHRsZSgoKSA9PiB7XHJcblx0Y29uc29sZS5sb2coJ2hlbGxvJyk7XHJcbn0sIDIwMCkpOyAqL1xyXG5cclxuXHJcbi8vINCf0L7Qu9GD0YfQuNGC0Ywg0YjQuNGA0LjQvdGDINC/0YDQvtC60YDRg9GC0LrQuFxyXG5leHBvcnQgY29uc3QgZ2V0U2Nyb2xsU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRjb25zdCBvdXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdGNvbnN0IGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0b3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcclxuXHRvdXRlci5jbGFzc0xpc3QuYWRkKCdzY3JvbGxiYXInKTtcclxuXHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcclxuXHRvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XHJcblx0XHJcblx0Y29uc3Qgc2Nyb2xsYmFyU2l6ZSA9IG91dGVyLm9mZnNldFdpZHRoIC0gaW5uZXIub2Zmc2V0V2lkdGg7XHJcblx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XHJcblx0XHJcblx0cmV0dXJuIHNjcm9sbGJhclNpemU7XHJcbn1cclxuXHJcblxyXG4vLyDQn9C+0LvRg9GH0LjRgtGMINCy0YvRgdC+0YLRgyDRgdC60YDRi9GC0L7Qs9C+INGN0LvQtdC80LXQvdGC0LBcclxuZXhwb3J0IGNvbnN0IGdldEhlaWdodCA9IChlbCkgPT4ge1xyXG5cdGlmICghZWwpIHJldHVybjtcclxuXHJcblx0Y29uc3QgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcblx0bGV0IGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcclxuXHJcblx0Ly8g0JXRgdC70Lgg0Y3Qu9C10LzQtdC90YIg0YEgXCJib3JkZXItYm94XCIsINGD0YfQuNGC0YvQstCw0LXQvCDQv9Cw0LTQtNC40L3Qs9C4INC4INCx0L7RgNC00LXRgNGLXHJcblx0aWYgKGNvbXB1dGVkLmJveFNpemluZyAhPT0gXCJib3JkZXItYm94XCIpIHtcclxuXHRcdGhlaWdodCAtPSBwYXJzZUZsb2F0KGNvbXB1dGVkLnBhZGRpbmdUb3ApIFxyXG5cdFx0XHQrIHBhcnNlRmxvYXQoY29tcHV0ZWQuYm9yZGVyQm90dG9tV2lkdGgpXHJcblx0XHRcdCsgcGFyc2VGbG9hdChjb21wdXRlZC5ib3JkZXJUb3BXaWR0aCkgXHJcblx0XHRcdCsgcGFyc2VGbG9hdChjb21wdXRlZC5wYWRkaW5nQm90dG9tKTtcclxuXHR9XHJcblxyXG5cdC8vINCV0YHQu9C4INCy0YvRgdC+0YLQsCDQsNCy0YLQviDQuCDRjdC70LXQvNC10L3RgiDRgdC60YDRi9GCLCDQutC70L7QvdC40YDRg9C10Lwg0LXQs9C+INC00LvRjyDQstGL0YfQuNGB0LvQtdC90LjQuVxyXG5cdGlmIChjb21wdXRlZC5oZWlnaHQgPT09ICdhdXRvJyAmJiBjb21wdXRlZC5kaXNwbGF5ID09PSAnbm9uZScpIHtcclxuXHRcdGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKHRydWUpO1xyXG5cdFx0XHJcblx0XHRPYmplY3QuYXNzaWduKGNsb25lLnN0eWxlLCB7XHJcblx0XHRcdHZpc2liaWxpdHk6ICdoaWRkZW4nLCBcclxuXHRcdFx0b3ZlcmZsb3c6ICd2aXNpYmxlJywgXHJcblx0XHRcdG1heEhlaWdodDogJ25vbmUnLCBcclxuXHRcdFx0ZGlzcGxheTogJ2Jsb2NrJywgXHJcblx0XHRcdG9wYWNpdHk6ICcwJ1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0ZWwuYWZ0ZXIoY2xvbmUpO1xyXG5cdFx0aGVpZ2h0ID0gY2xvbmUub2Zmc2V0SGVpZ2h0O1xyXG5cdFx0Y2xvbmUucmVtb3ZlKCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gaGVpZ2h0O1xyXG59O1xyXG4gIFxyXG5cclxuLyogXHJcbiog0J/Qu9Cw0LLQvdCw0Y8g0L/RgNC+0LrRgNGD0YLQutCwINC6INC30LDQtNCw0L3QvdC+0LzRgyDRjdC70LXQvNC10L3RgtGDIFxyXG4qIEDQstGL0LfQvtCyOlxyXG4qIFxyXG5pbXBvcnQgeyBzY3JvbGxUb0lkIH0gZnJvbSBcIi4uLy4uL2pzL2xpYnMvdXRpbHNcIjtcclxuc2Nyb2xsVG9JZChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhW2hyZWZePVwiI1wiXScpKTtcclxuKiBcclxuKi9cclxuXHJcbmV4cG9ydCBjb25zdCBzY3JvbGxUb0lkID0gKGl0ZW1zKSA9PiB7XHJcblx0aXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuXHRcdGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0uZ2V0QXR0cmlidXRlKCdocmVmJykuc3Vic3RyaW5nKDEpKS5zY3JvbGxJbnRvVmlldyh7XHJcblx0XHRcdFx0YmVoYXZpb3I6ICdzbW9vdGgnLFxyXG5cdFx0XHRcdGJsb2NrOiAnc3RhcnQnXHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHRcdFxyXG59XHJcblxyXG5cclxuLyogXHJcbiog0J/Qu9Cw0LLQvdCw0Y8g0L/RgNC+0LrRgNGD0YLQutCwINC6INCy0LXRgNGF0YMg0YHRgtGA0LDQvdC40YbRi1xyXG4qIEDQstGL0LfQvtCyOlxyXG4qIFxyXG5pbXBvcnQgeyBzY3JvbGxUb1RvcCB9IGZyb20gXCIuLi8uLi9qcy9saWJzL3V0aWxzXCI7XHJcbnNjcm9sbFRvVG9wKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2FbaHJlZl49XCJ0b3BcIl0nKSk7XHJcbiogXHJcbiovXHJcblxyXG5leHBvcnQgY29uc3Qgc2Nyb2xsVG9Ub3AgPSAoaXRlbSkgPT4ge1xyXG5cdGlmIChpdGVtKSB7XHJcblx0XHRpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHR3aW5kb3cuc2Nyb2xsVG8oeyB0b3A6IDAsIGJlaGF2aW9yOiAnc21vb3RoJyB9KTtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxuXHJcbi8qIFxyXG4qINCe0LHQvdC+0LLQu9C10L3QuNC1INC30LDQtNCw0L3QvdC+0LPQviDQvNCw0YHRgdC40LLQsCDQsiBsb2NhbFN0b3JhZ2VcclxuKiBA0LLRi9C30L7QsjpcclxuKiBcclxuaW1wb3J0IHsgdXBkYXRlTG9jYWxTdG9yYWdlIH0gZnJvbSBcIi4uLy4uL2pzL2xpYnMvdXRpbHNcIjtcclxudXBkYXRlTG9jYWxTdG9yYWdlKCdteUFycmF5JywgJ2l0ZW0xJyk7XHJcbnVwZGF0ZUxvY2FsU3RvcmFnZSgnbXlBcnJheScsICdpdGVtMScsIGZhbHNlKTtcclxuKiBcclxuKi9cclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVMb2NhbFN0b3JhZ2UgPSAoa2V5LCBpdGVtLCBhZGQgPSB0cnVlKSA9PiB7XHJcblx0Y29uc3Qgc3RvcmFnZSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkgfHwgW107XHJcblx0Y29uc3QgdXBkYXRlZCA9IGFkZCA/IFsuLi5uZXcgU2V0KFsuLi5zdG9yYWdlLCBpdGVtXSldIDogc3RvcmFnZS5maWx0ZXIodmFsID0+IHZhbCAhPT0gaXRlbSk7XHJcblx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkKSk7XHJcbn07XHJcblxyXG5cclxuLyogXHJcbiog0J/RgNC+0YHRgtCw0Y8g0LLQsNC70LjQtNCw0YbQuNGPINGE0L7RgNC80YtcclxuKiBA0LLRi9C30L7QsjpcclxuKiBcclxuaW1wb3J0IHsgdmFsaWRhdGUgfSBmcm9tIFwiLi4vLi4vanMvbGlicy91dGlsc1wiO1xyXG5pbnB1dC5jbGFzc0xpc3QudG9nZ2xlKCdlcnJvcicsICF2YWxpZGF0ZShpbnB1dCkpO1xyXG4qIFxyXG4qL1xyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlID0gKGlucHV0KSA9PiB7XHJcblx0aWYgKCFpbnB1dCB8fCAhaW5wdXQuZGF0YXNldC5ydWxlcykgcmV0dXJuIHRydWU7XHJcblxyXG5cdGNvbnN0IHJ1bGVzID0gaW5wdXQuZGF0YXNldC5ydWxlcy5zcGxpdCgnLCcpLm1hcChydWxlID0+IHJ1bGUudHJpbSgpKS5maWx0ZXIoQm9vbGVhbik7XHJcblx0aWYgKCFydWxlcy5sZW5ndGgpIHJldHVybiB0cnVlO1xyXG5cclxuXHRjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlLnRyaW0oKTtcclxuXHJcblx0Y29uc3QgcGF0dGVybnMgPSB7XHJcblx0XHRyZXE6IC8uKy8sXHJcblx0XHRvbWl0OiAvXiQvLFxyXG5cdFx0bnVtOiAvXlxcZCokLyxcclxuXHRcdG5hbWU6IC9eW2EtekEtWtCwLdGP0JAt0K/RkdCBXFxzLV0rJC8sXHJcblx0XHRwaG9uZTogL15cXCs/XFxkezEsNH1bLVxcZCgpXFxzXXs1LDIwfSQvLFxyXG5cdFx0ZW1haWw6IC9eW2EtekEtWjAtOS5fJSstXStAW2EtekEtWjAtOS4tXStcXC5bYS16QS1aXXsyLH0kLyxcclxuXHRcdHVybDogL14oaHR0cHM/OlxcL1xcLyk/KFtcXHctXStcXC4pK1tcXHctXSsoXFwvW1xcdy0uLz8lJj1dKik/JC9pLFxyXG5cdH07XHJcblxyXG5cdGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xyXG5cdFx0aWYgKHJ1bGUuc3RhcnRzV2l0aCgnbWluOicpICYmIHZhbHVlLmxlbmd0aCA8ICtydWxlLnNsaWNlKDQpKSByZXR1cm4gZmFsc2U7XHJcblx0XHRpZiAocnVsZS5zdGFydHNXaXRoKCdtYXg6JykgJiYgdmFsdWUubGVuZ3RoID4gK3J1bGUuc2xpY2UoNCkpIHJldHVybiBmYWxzZTtcclxuXHRcdGlmIChydWxlLnN0YXJ0c1dpdGgoJ251bTonKSAmJiAoaXNOYU4oK3ZhbHVlKSB8fCArdmFsdWUgPiArcnVsZS5zbGljZSg0KSkpIHJldHVybiBmYWxzZTtcclxuXHRcdGlmIChwYXR0ZXJuc1tydWxlXSAmJiAhcGF0dGVybnNbcnVsZV0udGVzdCh2YWx1ZSkpIHJldHVybiBmYWxzZTtcclxuXHRcdGlmICghcGF0dGVybnNbcnVsZV0gJiYgIXJ1bGUuaW5jbHVkZXMoJzonKSkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oYFVua25vd24gcnVsZTogJHtydWxlfWApO1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblxyXG4vKiBcclxuKiDQmNC30LzQtdC90LXQvdC40LUg0LLRi9GB0L7RgtGLINGE0L7RgNC80Ysg0L/QviDQvNC10YDQtSDQstCy0L7QtNCwINGC0LXQutGB0YLQsFxyXG4qIEDQstGL0LfQvtCyOlxyXG4qIFxyXG5pbXBvcnQgeyB0ZXh0YXJlYVJlc2l6ZSB9IGZyb20gXCIuLi8uLi9qcy9saWJzL3V0aWxzXCI7XHJcbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJykuZm9yRWFjaChhdXRvUmVzaXplVGV4dGFyZWEpO1xyXG4qIFxyXG4qL1xyXG5cclxuZXhwb3J0IGNvbnN0IHRleHRhcmVhUmVzaXplID0gKHRleHRhcmVhKSA9PiB7XHJcblx0aWYgKCF0ZXh0YXJlYSkgcmV0dXJuO1xyXG5cclxuXHRjb25zdCByZXNpemUgPSAoKSA9PiB7XHJcblx0XHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGV4dGFyZWEpO1xyXG5cdFx0Y29uc3QgYm9yZGVyT2Zmc2V0ID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCkgKyBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKTtcclxuXHJcblx0XHR0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XHJcblx0XHR0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAodGV4dGFyZWEuc2Nyb2xsSGVpZ2h0ICsgYm9yZGVyT2Zmc2V0KSArICdweCc7XHJcblx0fTtcclxuXHJcblx0dGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCByZXNpemUpO1xyXG5cdHJlc2l6ZSgpO1xyXG59OyJdLCJuYW1lcyI6WyJpc09iamVjdCIsIml0ZW0iLCJfdHlwZW9mIiwiQXJyYXkiLCJpc0FycmF5IiwibWVyZ2VEZWVwIiwidGFyZ2V0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZXMiLCJfa2V5Iiwic291cmNlIiwic2hpZnQiLCJrZXkiLCJPYmplY3QiLCJhc3NpZ24iLCJfZGVmaW5lUHJvcGVydHkiLCJhcHBseSIsImNvbmNhdCIsIl9tZXJnZURlZXAiLCJjbG9uZU9iaiIsIm9iaiIsIm5ld09iaiIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsIl9jbG9uZU9iaiIsInRocm90dGxlIiwiZm4iLCJkZWxheSIsInVuZGVmaW5lZCIsInRpbWVvdXQiLCJfbGVuMiIsImFyZ3MiLCJfa2V5MiIsInNldFRpbWVvdXQiLCJfdGhpcyIsImdldFNjcm9sbFNpemUiLCJvdXRlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVyIiwic3R5bGUiLCJvdmVyZmxvdyIsImNsYXNzTGlzdCIsImFkZCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInNjcm9sbGJhclNpemUiLCJvZmZzZXRXaWR0aCIsInJlbW92ZUNoaWxkIiwiZ2V0SGVpZ2h0IiwiZWwiLCJjb21wdXRlZCIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJoZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJib3hTaXppbmciLCJwYXJzZUZsb2F0IiwicGFkZGluZ1RvcCIsImJvcmRlckJvdHRvbVdpZHRoIiwiYm9yZGVyVG9wV2lkdGgiLCJwYWRkaW5nQm90dG9tIiwiZGlzcGxheSIsImNsb25lIiwiY2xvbmVOb2RlIiwidmlzaWJpbGl0eSIsIm1heEhlaWdodCIsIm9wYWNpdHkiLCJhZnRlciIsInJlbW92ZSIsInNjcm9sbFRvSWQiLCJpdGVtcyIsImZvckVhY2giLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInByZXZlbnREZWZhdWx0IiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRBdHRyaWJ1dGUiLCJzdWJzdHJpbmciLCJzY3JvbGxJbnRvVmlldyIsImJlaGF2aW9yIiwiYmxvY2siLCJzY3JvbGxUb1RvcCIsInNjcm9sbFRvIiwidG9wIiwidXBkYXRlTG9jYWxTdG9yYWdlIiwic3RvcmFnZSIsIkpTT04iLCJwYXJzZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ1cGRhdGVkIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiU2V0IiwiZmlsdGVyIiwidmFsIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInZhbGlkYXRlIiwiaW5wdXQiLCJkYXRhc2V0IiwicnVsZXMiLCJzcGxpdCIsIm1hcCIsInJ1bGUiLCJ0cmltIiwiQm9vbGVhbiIsInZhbHVlIiwicGF0dGVybnMiLCJyZXEiLCJvbWl0IiwibnVtIiwibmFtZSIsInBob25lIiwiZW1haWwiLCJ1cmwiLCJfaXRlcmF0b3IiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsIl9zdGVwIiwicyIsIm4iLCJkb25lIiwic3RhcnRzV2l0aCIsInNsaWNlIiwiaXNOYU4iLCJ0ZXN0IiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsImVyciIsImYiLCJ0ZXh0YXJlYVJlc2l6ZSIsInRleHRhcmVhIiwicmVzaXplIiwiYm9yZGVyT2Zmc2V0Iiwic2Nyb2xsSGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/libs/utils.js\n");

/***/ }),

/***/ "./src/js/polyfills.js":
/*!*****************************!*\
  !*** ./src/js/polyfills.js ***!
  \*****************************/
/***/ (() => {

eval("// глобальный объект для экспорта логики\nwindow.Site = {};\n\n/* Polyfills */\n(function (e) {\n  e.matches = e.matches || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector || e.webkitMatchesSelector;\n  e.closest = e.closest || function closest(selector) {\n    if (!this) return null;\n    if (this.matches(selector)) return this;\n    if (!this.parentElement) {\n      return null;\n    } else return this.parentElement.closest(selector);\n  };\n})(Element.prototype);\n(function (e) {\n  var matches = e.matches || e.matchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector;\n  !matches ? e.matches = e.matchesSelector = function matches(selector) {\n    var matches = document.querySelectorAll(selector);\n    var th = this;\n    return Array.prototype.some.call(matches, function (e) {\n      return e === th;\n    });\n  } : e.matches = e.matchesSelector = matches;\n})(Element.prototype);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvcG9seWZpbGxzLmpzIiwibmFtZXMiOlsid2luZG93IiwiU2l0ZSIsImUiLCJtYXRjaGVzIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiY2xvc2VzdCIsInNlbGVjdG9yIiwicGFyZW50RWxlbWVudCIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJtYXRjaGVzU2VsZWN0b3IiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0aCIsIkFycmF5Iiwic29tZSIsImNhbGwiXSwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsid2VicGFjazovL2d1bHAtc2Nzcy1zdGFydGVyLy4vc3JjL2pzL3BvbHlmaWxscy5qcz83MjVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vINCz0LvQvtCx0LDQu9GM0L3Ri9C5INC+0LHRitC10LrRgiDQtNC70Y8g0Y3QutGB0L/QvtGA0YLQsCDQu9C+0LPQuNC60Lhcclxud2luZG93LlNpdGUgPSB7fTtcclxuXHJcbi8qIFBvbHlmaWxscyAqL1xyXG4oZnVuY3Rpb24oZSkge1xyXG5cdGUubWF0Y2hlcyA9IGUubWF0Y2hlcyB8fCBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGUub01hdGNoZXNTZWxlY3RvciB8fCBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcclxuXHRlLmNsb3Nlc3QgPSBlLmNsb3Nlc3QgfHwgZnVuY3Rpb24gY2xvc2VzdChzZWxlY3Rvcikge1xyXG5cdFx0aWYgKCF0aGlzKSByZXR1cm4gbnVsbDtcclxuXHRcdGlmICh0aGlzLm1hdGNoZXMoc2VsZWN0b3IpKSByZXR1cm4gdGhpcztcclxuXHRcdGlmICghdGhpcy5wYXJlbnRFbGVtZW50KSB7cmV0dXJuIG51bGx9XHJcblx0XHRcdGVsc2UgcmV0dXJuIHRoaXMucGFyZW50RWxlbWVudC5jbG9zZXN0KHNlbGVjdG9yKVxyXG5cdFx0fTtcclxufShFbGVtZW50LnByb3RvdHlwZSkpO1xyXG5cclxuKGZ1bmN0aW9uKGUpIHtcclxuXHR2YXIgbWF0Y2hlcyA9IGUubWF0Y2hlcyB8fCBlLm1hdGNoZXNTZWxlY3RvciB8fCBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGUub01hdGNoZXNTZWxlY3RvcjtcclxuXHQhbWF0Y2hlcyA/IChlLm1hdGNoZXMgPSBlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3IpIHtcclxuXHRcdHZhciBtYXRjaGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XHJcblx0XHR2YXIgdGggPSB0aGlzO1xyXG5cdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwobWF0Y2hlcywgZnVuY3Rpb24oZSkge1xyXG5cdFx0XHRyZXR1cm4gZSA9PT0gdGg7XHJcblx0XHR9KTtcclxuXHR9KSA6IChlLm1hdGNoZXMgPSBlLm1hdGNoZXNTZWxlY3RvciA9IG1hdGNoZXMpO1xyXG59KShFbGVtZW50LnByb3RvdHlwZSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBQSxNQUFNLENBQUNDLElBQUksR0FBRyxDQUFDLENBQUM7O0FBRWhCO0FBQ0MsV0FBU0MsQ0FBQyxFQUFFO0VBQ1pBLENBQUMsQ0FBQ0MsT0FBTyxHQUFHRCxDQUFDLENBQUNDLE9BQU8sSUFBSUQsQ0FBQyxDQUFDRSxrQkFBa0IsSUFBSUYsQ0FBQyxDQUFDRyxpQkFBaUIsSUFBSUgsQ0FBQyxDQUFDSSxnQkFBZ0IsSUFBSUosQ0FBQyxDQUFDSyxxQkFBcUI7RUFDckhMLENBQUMsQ0FBQ00sT0FBTyxHQUFHTixDQUFDLENBQUNNLE9BQU8sSUFBSSxTQUFTQSxPQUFPQSxDQUFDQyxRQUFRLEVBQUU7SUFDbkQsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLElBQUk7SUFDdEIsSUFBSSxJQUFJLENBQUNOLE9BQU8sQ0FBQ00sUUFBUSxDQUFDLEVBQUUsT0FBTyxJQUFJO0lBQ3ZDLElBQUksQ0FBQyxJQUFJLENBQUNDLGFBQWEsRUFBRTtNQUFDLE9BQU8sSUFBSTtJQUFBLENBQUMsTUFDaEMsT0FBTyxJQUFJLENBQUNBLGFBQWEsQ0FBQ0YsT0FBTyxDQUFDQyxRQUFRLENBQUM7RUFDakQsQ0FBQztBQUNILENBQUMsRUFBQ0UsT0FBTyxDQUFDQyxTQUFTLENBQUM7QUFFcEIsQ0FBQyxVQUFTVixDQUFDLEVBQUU7RUFDWixJQUFJQyxPQUFPLEdBQUdELENBQUMsQ0FBQ0MsT0FBTyxJQUFJRCxDQUFDLENBQUNXLGVBQWUsSUFBSVgsQ0FBQyxDQUFDSyxxQkFBcUIsSUFBSUwsQ0FBQyxDQUFDRSxrQkFBa0IsSUFBSUYsQ0FBQyxDQUFDRyxpQkFBaUIsSUFBSUgsQ0FBQyxDQUFDSSxnQkFBZ0I7RUFDNUksQ0FBQ0gsT0FBTyxHQUFJRCxDQUFDLENBQUNDLE9BQU8sR0FBR0QsQ0FBQyxDQUFDVyxlQUFlLEdBQUcsU0FBU1YsT0FBT0EsQ0FBQ00sUUFBUSxFQUFFO0lBQ3RFLElBQUlOLE9BQU8sR0FBR1csUUFBUSxDQUFDQyxnQkFBZ0IsQ0FBQ04sUUFBUSxDQUFDO0lBQ2pELElBQUlPLEVBQUUsR0FBRyxJQUFJO0lBQ2IsT0FBT0MsS0FBSyxDQUFDTCxTQUFTLENBQUNNLElBQUksQ0FBQ0MsSUFBSSxDQUFDaEIsT0FBTyxFQUFFLFVBQVNELENBQUMsRUFBRTtNQUNyRCxPQUFPQSxDQUFDLEtBQUtjLEVBQUU7SUFDaEIsQ0FBQyxDQUFDO0VBQ0gsQ0FBQyxHQUFLZCxDQUFDLENBQUNDLE9BQU8sR0FBR0QsQ0FBQyxDQUFDVyxlQUFlLEdBQUdWLE9BQVE7QUFDL0MsQ0FBQyxFQUFFUSxPQUFPLENBQUNDLFNBQVMsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==\n//# sourceURL=webpack-internal:///./src/js/polyfills.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/common.js");
/******/ 	
/******/ })()
;